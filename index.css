(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const r of document.querySelectorAll('link[rel="modulepreload"]'))
        n(r);
    new MutationObserver(r => {
        for (const i of r)
            if (i.type === "childList")
                for (const a of i.addedNodes)
                    a.tagName === "LINK" && a.rel === "modulepreload" && n(a)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(r) {
        const i = {};
        return r.integrity && (i.integrity = r.integrity),
        r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),
        r.crossOrigin === "use-credentials" ? i.credentials = "include" : r.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin",
        i
    }
    function n(r) {
        if (r.ep)
            return;
        r.ep = !0;
        const i = t(r);
        fetch(r.href, i)
    }
}
)();
var mm = {
    exports: {}
}
  , Co = {}
  , gm = {
    exports: {}
}
  , ce = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _i = Symbol.for("react.element")
  , Ey = Symbol.for("react.portal")
  , Sy = Symbol.for("react.fragment")
  , Ty = Symbol.for("react.strict_mode")
  , Ly = Symbol.for("react.profiler")
  , Iy = Symbol.for("react.provider")
  , Ay = Symbol.for("react.context")
  , by = Symbol.for("react.forward_ref")
  , Ry = Symbol.for("react.suspense")
  , wy = Symbol.for("react.memo")
  , Cy = Symbol.for("react.lazy")
  , Fd = Symbol.iterator;
function ky(s) {
    return s === null || typeof s != "object" ? null : (s = Fd && s[Fd] || s["@@iterator"],
    typeof s == "function" ? s : null)
}
var pm = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , ym = Object.assign
  , xm = {};
function Ar(s, e, t) {
    this.props = s,
    this.context = e,
    this.refs = xm,
    this.updater = t || pm
}
Ar.prototype.isReactComponent = {};
Ar.prototype.setState = function(s, e) {
    if (typeof s != "object" && typeof s != "function" && s != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, s, e, "setState")
}
;
Ar.prototype.forceUpdate = function(s) {
    this.updater.enqueueForceUpdate(this, s, "forceUpdate")
}
;
function vm() {}
vm.prototype = Ar.prototype;
function hu(s, e, t) {
    this.props = s,
    this.context = e,
    this.refs = xm,
    this.updater = t || pm
}
var fu = hu.prototype = new vm;
fu.constructor = hu;
ym(fu, Ar.prototype);
fu.isPureReactComponent = !0;
var Ud = Array.isArray
  , Em = Object.prototype.hasOwnProperty
  , mu = {
    current: null
}
  , Sm = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Tm(s, e, t) {
    var n, r = {}, i = null, a = null;
    if (e != null)
        for (n in e.ref !== void 0 && (a = e.ref),
        e.key !== void 0 && (i = "" + e.key),
        e)
            Em.call(e, n) && !Sm.hasOwnProperty(n) && (r[n] = e[n]);
    var o = arguments.length - 2;
    if (o === 1)
        r.children = t;
    else if (1 < o) {
        for (var l = Array(o), c = 0; c < o; c++)
            l[c] = arguments[c + 2];
        r.children = l
    }
    if (s && s.defaultProps)
        for (n in o = s.defaultProps,
        o)
            r[n] === void 0 && (r[n] = o[n]);
    return {
        $$typeof: _i,
        type: s,
        key: i,
        ref: a,
        props: r,
        _owner: mu.current
    }
}
function _y(s, e) {
    return {
        $$typeof: _i,
        type: s.type,
        key: e,
        ref: s.ref,
        props: s.props,
        _owner: s._owner
    }
}
function gu(s) {
    return typeof s == "object" && s !== null && s.$$typeof === _i
}
function Dy(s) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + s.replace(/[=:]/g, function(t) {
        return e[t]
    })
}
var Bd = /\/+/g;
function el(s, e) {
    return typeof s == "object" && s !== null && s.key != null ? Dy("" + s.key) : e.toString(36)
}
function Ta(s, e, t, n, r) {
    var i = typeof s;
    (i === "undefined" || i === "boolean") && (s = null);
    var a = !1;
    if (s === null)
        a = !0;
    else
        switch (i) {
        case "string":
        case "number":
            a = !0;
            break;
        case "object":
            switch (s.$$typeof) {
            case _i:
            case Ey:
                a = !0
            }
        }
    if (a)
        return a = s,
        r = r(a),
        s = n === "" ? "." + el(a, 0) : n,
        Ud(r) ? (t = "",
        s != null && (t = s.replace(Bd, "$&/") + "/"),
        Ta(r, e, t, "", function(c) {
            return c
        })) : r != null && (gu(r) && (r = _y(r, t + (!r.key || a && a.key === r.key ? "" : ("" + r.key).replace(Bd, "$&/") + "/") + s)),
        e.push(r)),
        1;
    if (a = 0,
    n = n === "" ? "." : n + ":",
    Ud(s))
        for (var o = 0; o < s.length; o++) {
            i = s[o];
            var l = n + el(i, o);
            a += Ta(i, e, t, l, r)
        }
    else if (l = ky(s),
    typeof l == "function")
        for (s = l.call(s),
        o = 0; !(i = s.next()).done; )
            i = i.value,
            l = n + el(i, o++),
            a += Ta(i, e, t, l, r);
    else if (i === "object")
        throw e = String(s),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(s).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return a
}
function Gi(s, e, t) {
    if (s == null)
        return s;
    var n = []
      , r = 0;
    return Ta(s, n, "", "", function(i) {
        return e.call(t, i, r++)
    }),
    n
}
function Py(s) {
    if (s._status === -1) {
        var e = s._result;
        e = e(),
        e.then(function(t) {
            (s._status === 0 || s._status === -1) && (s._status = 1,
            s._result = t)
        }, function(t) {
            (s._status === 0 || s._status === -1) && (s._status = 2,
            s._result = t)
        }),
        s._status === -1 && (s._status = 0,
        s._result = e)
    }
    if (s._status === 1)
        return s._result.default;
    throw s._result
}
var ut = {
    current: null
}
  , La = {
    transition: null
}
  , Ny = {
    ReactCurrentDispatcher: ut,
    ReactCurrentBatchConfig: La,
    ReactCurrentOwner: mu
};
function Lm() {
    throw Error("act(...) is not supported in production builds of React.")
}
ce.Children = {
    map: Gi,
    forEach: function(s, e, t) {
        Gi(s, function() {
            e.apply(this, arguments)
        }, t)
    },
    count: function(s) {
        var e = 0;
        return Gi(s, function() {
            e++
        }),
        e
    },
    toArray: function(s) {
        return Gi(s, function(e) {
            return e
        }) || []
    },
    only: function(s) {
        if (!gu(s))
            throw Error("React.Children.only expected to receive a single React element child.");
        return s
    }
};
ce.Component = Ar;
ce.Fragment = Sy;
ce.Profiler = Ly;
ce.PureComponent = hu;
ce.StrictMode = Ty;
ce.Suspense = Ry;
ce.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Ny;
ce.act = Lm;
ce.cloneElement = function(s, e, t) {
    if (s == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + s + ".");
    var n = ym({}, s.props)
      , r = s.key
      , i = s.ref
      , a = s._owner;
    if (e != null) {
        if (e.ref !== void 0 && (i = e.ref,
        a = mu.current),
        e.key !== void 0 && (r = "" + e.key),
        s.type && s.type.defaultProps)
            var o = s.type.defaultProps;
        for (l in e)
            Em.call(e, l) && !Sm.hasOwnProperty(l) && (n[l] = e[l] === void 0 && o !== void 0 ? o[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        n.children = t;
    else if (1 < l) {
        o = Array(l);
        for (var c = 0; c < l; c++)
            o[c] = arguments[c + 2];
        n.children = o
    }
    return {
        $$typeof: _i,
        type: s.type,
        key: r,
        ref: i,
        props: n,
        _owner: a
    }
}
;
ce.createContext = function(s) {
    return s = {
        $$typeof: Ay,
        _currentValue: s,
        _currentValue2: s,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    s.Provider = {
        $$typeof: Iy,
        _context: s
    },
    s.Consumer = s
}
;
ce.createElement = Tm;
ce.createFactory = function(s) {
    var e = Tm.bind(null, s);
    return e.type = s,
    e
}
;
ce.createRef = function() {
    return {
        current: null
    }
}
;
ce.forwardRef = function(s) {
    return {
        $$typeof: by,
        render: s
    }
}
;
ce.isValidElement = gu;
ce.lazy = function(s) {
    return {
        $$typeof: Cy,
        _payload: {
            _status: -1,
            _result: s
        },
        _init: Py
    }
}
;
ce.memo = function(s, e) {
    return {
        $$typeof: wy,
        type: s,
        compare: e === void 0 ? null : e
    }
}
;
ce.startTransition = function(s) {
    var e = La.transition;
    La.transition = {};
    try {
        s()
    } finally {
        La.transition = e
    }
}
;
ce.unstable_act = Lm;
ce.useCallback = function(s, e) {
    return ut.current.useCallback(s, e)
}
;
ce.useContext = function(s) {
    return ut.current.useContext(s)
}
;
ce.useDebugValue = function() {}
;
ce.useDeferredValue = function(s) {
    return ut.current.useDeferredValue(s)
}
;
ce.useEffect = function(s, e) {
    return ut.current.useEffect(s, e)
}
;
ce.useId = function() {
    return ut.current.useId()
}
;
ce.useImperativeHandle = function(s, e, t) {
    return ut.current.useImperativeHandle(s, e, t)
}
;
ce.useInsertionEffect = function(s, e) {
    return ut.current.useInsertionEffect(s, e)
}
;
ce.useLayoutEffect = function(s, e) {
    return ut.current.useLayoutEffect(s, e)
}
;
ce.useMemo = function(s, e) {
    return ut.current.useMemo(s, e)
}
;
ce.useReducer = function(s, e, t) {
    return ut.current.useReducer(s, e, t)
}
;
ce.useRef = function(s) {
    return ut.current.useRef(s)
}
;
ce.useState = function(s) {
    return ut.current.useState(s)
}
;
ce.useSyncExternalStore = function(s, e, t) {
    return ut.current.useSyncExternalStore(s, e, t)
}
;
ce.useTransition = function() {
    return ut.current.useTransition()
}
;
ce.version = "18.3.1";
gm.exports = ce;
var w = gm.exports;
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Oy = w
  , My = Symbol.for("react.element")
  , Fy = Symbol.for("react.fragment")
  , Uy = Object.prototype.hasOwnProperty
  , By = Oy.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , $y = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function Im(s, e, t) {
    var n, r = {}, i = null, a = null;
    t !== void 0 && (i = "" + t),
    e.key !== void 0 && (i = "" + e.key),
    e.ref !== void 0 && (a = e.ref);
    for (n in e)
        Uy.call(e, n) && !$y.hasOwnProperty(n) && (r[n] = e[n]);
    if (s && s.defaultProps)
        for (n in e = s.defaultProps,
        e)
            r[n] === void 0 && (r[n] = e[n]);
    return {
        $$typeof: My,
        type: s,
        key: i,
        ref: a,
        props: r,
        _owner: By.current
    }
}
Co.Fragment = Fy;
Co.jsx = Im;
Co.jsxs = Im;
mm.exports = Co;
var g = mm.exports
  , Am = {
    exports: {}
}
  , kt = {}
  , bm = {
    exports: {}
}
  , Rm = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(s) {
    function e(D, B) {
        var k = D.length;
        D.push(B);
        e: for (; 0 < k; ) {
            var F = k - 1 >>> 1
              , j = D[F];
            if (0 < r(j, B))
                D[F] = B,
                D[k] = j,
                k = F;
            else
                break e
        }
    }
    function t(D) {
        return D.length === 0 ? null : D[0]
    }
    function n(D) {
        if (D.length === 0)
            return null;
        var B = D[0]
          , k = D.pop();
        if (k !== B) {
            D[0] = k;
            e: for (var F = 0, j = D.length, J = j >>> 1; F < J; ) {
                var re = 2 * (F + 1) - 1
                  , Q = D[re]
                  , se = re + 1
                  , Le = D[se];
                if (0 > r(Q, k))
                    se < j && 0 > r(Le, Q) ? (D[F] = Le,
                    D[se] = k,
                    F = se) : (D[F] = Q,
                    D[re] = k,
                    F = re);
                else if (se < j && 0 > r(Le, k))
                    D[F] = Le,
                    D[se] = k,
                    F = se;
                else
                    break e
            }
        }
        return B
    }
    function r(D, B) {
        var k = D.sortIndex - B.sortIndex;
        return k !== 0 ? k : D.id - B.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var i = performance;
        s.unstable_now = function() {
            return i.now()
        }
    } else {
        var a = Date
          , o = a.now();
        s.unstable_now = function() {
            return a.now() - o
        }
    }
    var l = []
      , c = []
      , u = 1
      , d = null
      , h = 3
      , f = !1
      , m = !1
      , p = !1
      , x = typeof setTimeout == "function" ? setTimeout : null
      , y = typeof clearTimeout == "function" ? clearTimeout : null
      , v = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function E(D) {
        for (var B = t(c); B !== null; ) {
            if (B.callback === null)
                n(c);
            else if (B.startTime <= D)
                n(c),
                B.sortIndex = B.expirationTime,
                e(l, B);
            else
                break;
            B = t(c)
        }
    }
    function T(D) {
        if (p = !1,
        E(D),
        !m)
            if (t(l) !== null)
                m = !0,
                G(L);
            else {
                var B = t(c);
                B !== null && V(T, B.startTime - D)
            }
    }
    function L(D, B) {
        m = !1,
        p && (p = !1,
        y(A),
        A = -1),
        f = !0;
        var k = h;
        try {
            for (E(B),
            d = t(l); d !== null && (!(d.expirationTime > B) || D && !O()); ) {
                var F = d.callback;
                if (typeof F == "function") {
                    d.callback = null,
                    h = d.priorityLevel;
                    var j = F(d.expirationTime <= B);
                    B = s.unstable_now(),
                    typeof j == "function" ? d.callback = j : d === t(l) && n(l),
                    E(B)
                } else
                    n(l);
                d = t(l)
            }
            if (d !== null)
                var J = !0;
            else {
                var re = t(c);
                re !== null && V(T, re.startTime - B),
                J = !1
            }
            return J
        } finally {
            d = null,
            h = k,
            f = !1
        }
    }
    var R = !1
      , I = null
      , A = -1
      , C = 5
      , b = -1;
    function O() {
        return !(s.unstable_now() - b < C)
    }
    function _() {
        if (I !== null) {
            var D = s.unstable_now();
            b = D;
            var B = !0;
            try {
                B = I(!0, D)
            } finally {
                B ? $() : (R = !1,
                I = null)
            }
        } else
            R = !1
    }
    var $;
    if (typeof v == "function")
        $ = function() {
            v(_)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var K = new MessageChannel
          , W = K.port2;
        K.port1.onmessage = _,
        $ = function() {
            W.postMessage(null)
        }
    } else
        $ = function() {
            x(_, 0)
        }
        ;
    function G(D) {
        I = D,
        R || (R = !0,
        $())
    }
    function V(D, B) {
        A = x(function() {
            D(s.unstable_now())
        }, B)
    }
    s.unstable_IdlePriority = 5,
    s.unstable_ImmediatePriority = 1,
    s.unstable_LowPriority = 4,
    s.unstable_NormalPriority = 3,
    s.unstable_Profiling = null,
    s.unstable_UserBlockingPriority = 2,
    s.unstable_cancelCallback = function(D) {
        D.callback = null
    }
    ,
    s.unstable_continueExecution = function() {
        m || f || (m = !0,
        G(L))
    }
    ,
    s.unstable_forceFrameRate = function(D) {
        0 > D || 125 < D ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < D ? Math.floor(1e3 / D) : 5
    }
    ,
    s.unstable_getCurrentPriorityLevel = function() {
        return h
    }
    ,
    s.unstable_getFirstCallbackNode = function() {
        return t(l)
    }
    ,
    s.unstable_next = function(D) {
        switch (h) {
        case 1:
        case 2:
        case 3:
            var B = 3;
            break;
        default:
            B = h
        }
        var k = h;
        h = B;
        try {
            return D()
        } finally {
            h = k
        }
    }
    ,
    s.unstable_pauseExecution = function() {}
    ,
    s.unstable_requestPaint = function() {}
    ,
    s.unstable_runWithPriority = function(D, B) {
        switch (D) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            D = 3
        }
        var k = h;
        h = D;
        try {
            return B()
        } finally {
            h = k
        }
    }
    ,
    s.unstable_scheduleCallback = function(D, B, k) {
        var F = s.unstable_now();
        switch (typeof k == "object" && k !== null ? (k = k.delay,
        k = typeof k == "number" && 0 < k ? F + k : F) : k = F,
        D) {
        case 1:
            var j = -1;
            break;
        case 2:
            j = 250;
            break;
        case 5:
            j = 1073741823;
            break;
        case 4:
            j = 1e4;
            break;
        default:
            j = 5e3
        }
        return j = k + j,
        D = {
            id: u++,
            callback: B,
            priorityLevel: D,
            startTime: k,
            expirationTime: j,
            sortIndex: -1
        },
        k > F ? (D.sortIndex = k,
        e(c, D),
        t(l) === null && D === t(c) && (p ? (y(A),
        A = -1) : p = !0,
        V(T, k - F))) : (D.sortIndex = j,
        e(l, D),
        m || f || (m = !0,
        G(L))),
        D
    }
    ,
    s.unstable_shouldYield = O,
    s.unstable_wrapCallback = function(D) {
        var B = h;
        return function() {
            var k = h;
            h = B;
            try {
                return D.apply(this, arguments)
            } finally {
                h = k
            }
        }
    }
}
)(Rm);
bm.exports = Rm;
var jy = bm.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Gy = w
  , Ct = jy;
function H(s) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, t = 1; t < arguments.length; t++)
        e += "&args[]=" + encodeURIComponent(arguments[t]);
    return "Minified React error #" + s + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var wm = new Set
  , ai = {};
function Nn(s, e) {
    pr(s, e),
    pr(s + "Capture", e)
}
function pr(s, e) {
    for (ai[s] = e,
    s = 0; s < e.length; s++)
        wm.add(e[s])
}
var _s = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , Ql = Object.prototype.hasOwnProperty
  , Vy = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , $d = {}
  , jd = {};
function Hy(s) {
    return Ql.call(jd, s) ? !0 : Ql.call($d, s) ? !1 : Vy.test(s) ? jd[s] = !0 : ($d[s] = !0,
    !1)
}
function Ky(s, e, t, n) {
    if (t !== null && t.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return n ? !1 : t !== null ? !t.acceptsBooleans : (s = s.toLowerCase().slice(0, 5),
        s !== "data-" && s !== "aria-");
    default:
        return !1
    }
}
function Wy(s, e, t, n) {
    if (e === null || typeof e > "u" || Ky(s, e, t, n))
        return !0;
    if (n)
        return !1;
    if (t !== null)
        switch (t.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function dt(s, e, t, n, r, i, a) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = n,
    this.attributeNamespace = r,
    this.mustUseProperty = t,
    this.propertyName = s,
    this.type = e,
    this.sanitizeURL = i,
    this.removeEmptyString = a
}
var et = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(s) {
    et[s] = new dt(s,0,!1,s,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(s) {
    var e = s[0];
    et[e] = new dt(e,1,!1,s[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(s) {
    et[s] = new dt(s,2,!1,s.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(s) {
    et[s] = new dt(s,2,!1,s,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(s) {
    et[s] = new dt(s,3,!1,s.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(s) {
    et[s] = new dt(s,3,!0,s,null,!1,!1)
});
["capture", "download"].forEach(function(s) {
    et[s] = new dt(s,4,!1,s,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(s) {
    et[s] = new dt(s,6,!1,s,null,!1,!1)
});
["rowSpan", "start"].forEach(function(s) {
    et[s] = new dt(s,5,!1,s.toLowerCase(),null,!1,!1)
});
var pu = /[\-:]([a-z])/g;
function yu(s) {
    return s[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(s) {
    var e = s.replace(pu, yu);
    et[e] = new dt(e,1,!1,s,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(s) {
    var e = s.replace(pu, yu);
    et[e] = new dt(e,1,!1,s,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(s) {
    var e = s.replace(pu, yu);
    et[e] = new dt(e,1,!1,s,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(s) {
    et[s] = new dt(s,1,!1,s.toLowerCase(),null,!1,!1)
});
et.xlinkHref = new dt("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(s) {
    et[s] = new dt(s,1,!1,s.toLowerCase(),null,!0,!0)
});
function xu(s, e, t, n) {
    var r = et.hasOwnProperty(e) ? et[e] : null;
    (r !== null ? r.type !== 0 : n || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (Wy(e, t, r, n) && (t = null),
    n || r === null ? Hy(e) && (t === null ? s.removeAttribute(e) : s.setAttribute(e, "" + t)) : r.mustUseProperty ? s[r.propertyName] = t === null ? r.type === 3 ? !1 : "" : t : (e = r.attributeName,
    n = r.attributeNamespace,
    t === null ? s.removeAttribute(e) : (r = r.type,
    t = r === 3 || r === 4 && t === !0 ? "" : "" + t,
    n ? s.setAttributeNS(n, e, t) : s.setAttribute(e, t))))
}
var Ms = Gy.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , Vi = Symbol.for("react.element")
  , Kn = Symbol.for("react.portal")
  , Wn = Symbol.for("react.fragment")
  , vu = Symbol.for("react.strict_mode")
  , Jl = Symbol.for("react.profiler")
  , Cm = Symbol.for("react.provider")
  , km = Symbol.for("react.context")
  , Eu = Symbol.for("react.forward_ref")
  , ec = Symbol.for("react.suspense")
  , tc = Symbol.for("react.suspense_list")
  , Su = Symbol.for("react.memo")
  , js = Symbol.for("react.lazy")
  , _m = Symbol.for("react.offscreen")
  , Gd = Symbol.iterator;
function Pr(s) {
    return s === null || typeof s != "object" ? null : (s = Gd && s[Gd] || s["@@iterator"],
    typeof s == "function" ? s : null)
}
var Ce = Object.assign, tl;
function Vr(s) {
    if (tl === void 0)
        try {
            throw Error()
        } catch (t) {
            var e = t.stack.trim().match(/\n( *(at )?)/);
            tl = e && e[1] || ""
        }
    return `
` + tl + s
}
var sl = !1;
function nl(s, e) {
    if (!s || sl)
        return "";
    sl = !0;
    var t = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var n = c
                }
                Reflect.construct(s, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    n = c
                }
                s.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                n = c
            }
            s()
        }
    } catch (c) {
        if (c && n && typeof c.stack == "string") {
            for (var r = c.stack.split(`
`), i = n.stack.split(`
`), a = r.length - 1, o = i.length - 1; 1 <= a && 0 <= o && r[a] !== i[o]; )
                o--;
            for (; 1 <= a && 0 <= o; a--,
            o--)
                if (r[a] !== i[o]) {
                    if (a !== 1 || o !== 1)
                        do
                            if (a--,
                            o--,
                            0 > o || r[a] !== i[o]) {
                                var l = `
` + r[a].replace(" at new ", " at ");
                                return s.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", s.displayName)),
                                l
                            }
                        while (1 <= a && 0 <= o);
                    break
                }
        }
    } finally {
        sl = !1,
        Error.prepareStackTrace = t
    }
    return (s = s ? s.displayName || s.name : "") ? Vr(s) : ""
}
function zy(s) {
    switch (s.tag) {
    case 5:
        return Vr(s.type);
    case 16:
        return Vr("Lazy");
    case 13:
        return Vr("Suspense");
    case 19:
        return Vr("SuspenseList");
    case 0:
    case 2:
    case 15:
        return s = nl(s.type, !1),
        s;
    case 11:
        return s = nl(s.type.render, !1),
        s;
    case 1:
        return s = nl(s.type, !0),
        s;
    default:
        return ""
    }
}
function sc(s) {
    if (s == null)
        return null;
    if (typeof s == "function")
        return s.displayName || s.name || null;
    if (typeof s == "string")
        return s;
    switch (s) {
    case Wn:
        return "Fragment";
    case Kn:
        return "Portal";
    case Jl:
        return "Profiler";
    case vu:
        return "StrictMode";
    case ec:
        return "Suspense";
    case tc:
        return "SuspenseList"
    }
    if (typeof s == "object")
        switch (s.$$typeof) {
        case km:
            return (s.displayName || "Context") + ".Consumer";
        case Cm:
            return (s._context.displayName || "Context") + ".Provider";
        case Eu:
            var e = s.render;
            return s = s.displayName,
            s || (s = e.displayName || e.name || "",
            s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"),
            s;
        case Su:
            return e = s.displayName || null,
            e !== null ? e : sc(s.type) || "Memo";
        case js:
            e = s._payload,
            s = s._init;
            try {
                return sc(s(e))
            } catch {}
        }
    return null
}
function Yy(s) {
    var e = s.type;
    switch (s.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return s = e.render,
        s = s.displayName || s.name || "",
        e.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return sc(e);
    case 8:
        return e === vu ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function rn(s) {
    switch (typeof s) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return s;
    case "object":
        return s;
    default:
        return ""
    }
}
function Dm(s) {
    var e = s.type;
    return (s = s.nodeName) && s.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function Xy(s) {
    var e = Dm(s) ? "checked" : "value"
      , t = Object.getOwnPropertyDescriptor(s.constructor.prototype, e)
      , n = "" + s[e];
    if (!s.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
        var r = t.get
          , i = t.set;
        return Object.defineProperty(s, e, {
            configurable: !0,
            get: function() {
                return r.call(this)
            },
            set: function(a) {
                n = "" + a,
                i.call(this, a)
            }
        }),
        Object.defineProperty(s, e, {
            enumerable: t.enumerable
        }),
        {
            getValue: function() {
                return n
            },
            setValue: function(a) {
                n = "" + a
            },
            stopTracking: function() {
                s._valueTracker = null,
                delete s[e]
            }
        }
    }
}
function Hi(s) {
    s._valueTracker || (s._valueTracker = Xy(s))
}
function Pm(s) {
    if (!s)
        return !1;
    var e = s._valueTracker;
    if (!e)
        return !0;
    var t = e.getValue()
      , n = "";
    return s && (n = Dm(s) ? s.checked ? "true" : "false" : s.value),
    s = n,
    s !== t ? (e.setValue(s),
    !0) : !1
}
function Ha(s) {
    if (s = s || (typeof document < "u" ? document : void 0),
    typeof s > "u")
        return null;
    try {
        return s.activeElement || s.body
    } catch {
        return s.body
    }
}
function nc(s, e) {
    var t = e.checked;
    return Ce({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: t ?? s._wrapperState.initialChecked
    })
}
function Vd(s, e) {
    var t = e.defaultValue == null ? "" : e.defaultValue
      , n = e.checked != null ? e.checked : e.defaultChecked;
    t = rn(e.value != null ? e.value : t),
    s._wrapperState = {
        initialChecked: n,
        initialValue: t,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function Nm(s, e) {
    e = e.checked,
    e != null && xu(s, "checked", e, !1)
}
function rc(s, e) {
    Nm(s, e);
    var t = rn(e.value)
      , n = e.type;
    if (t != null)
        n === "number" ? (t === 0 && s.value === "" || s.value != t) && (s.value = "" + t) : s.value !== "" + t && (s.value = "" + t);
    else if (n === "submit" || n === "reset") {
        s.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? ic(s, e.type, t) : e.hasOwnProperty("defaultValue") && ic(s, e.type, rn(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (s.defaultChecked = !!e.defaultChecked)
}
function Hd(s, e, t) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var n = e.type;
        if (!(n !== "submit" && n !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + s._wrapperState.initialValue,
        t || e === s.value || (s.value = e),
        s.defaultValue = e
    }
    t = s.name,
    t !== "" && (s.name = ""),
    s.defaultChecked = !!s._wrapperState.initialChecked,
    t !== "" && (s.name = t)
}
function ic(s, e, t) {
    (e !== "number" || Ha(s.ownerDocument) !== s) && (t == null ? s.defaultValue = "" + s._wrapperState.initialValue : s.defaultValue !== "" + t && (s.defaultValue = "" + t))
}
var Hr = Array.isArray;
function rr(s, e, t, n) {
    if (s = s.options,
    e) {
        e = {};
        for (var r = 0; r < t.length; r++)
            e["$" + t[r]] = !0;
        for (t = 0; t < s.length; t++)
            r = e.hasOwnProperty("$" + s[t].value),
            s[t].selected !== r && (s[t].selected = r),
            r && n && (s[t].defaultSelected = !0)
    } else {
        for (t = "" + rn(t),
        e = null,
        r = 0; r < s.length; r++) {
            if (s[r].value === t) {
                s[r].selected = !0,
                n && (s[r].defaultSelected = !0);
                return
            }
            e !== null || s[r].disabled || (e = s[r])
        }
        e !== null && (e.selected = !0)
    }
}
function ac(s, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(H(91));
    return Ce({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + s._wrapperState.initialValue
    })
}
function Kd(s, e) {
    var t = e.value;
    if (t == null) {
        if (t = e.children,
        e = e.defaultValue,
        t != null) {
            if (e != null)
                throw Error(H(92));
            if (Hr(t)) {
                if (1 < t.length)
                    throw Error(H(93));
                t = t[0]
            }
            e = t
        }
        e == null && (e = ""),
        t = e
    }
    s._wrapperState = {
        initialValue: rn(t)
    }
}
function Om(s, e) {
    var t = rn(e.value)
      , n = rn(e.defaultValue);
    t != null && (t = "" + t,
    t !== s.value && (s.value = t),
    e.defaultValue == null && s.defaultValue !== t && (s.defaultValue = t)),
    n != null && (s.defaultValue = "" + n)
}
function Wd(s) {
    var e = s.textContent;
    e === s._wrapperState.initialValue && e !== "" && e !== null && (s.value = e)
}
function Mm(s) {
    switch (s) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function oc(s, e) {
    return s == null || s === "http://www.w3.org/1999/xhtml" ? Mm(e) : s === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : s
}
var Ki, Fm = function(s) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, n, r) {
        MSApp.execUnsafeLocalFunction(function() {
            return s(e, t, n, r)
        })
    }
    : s
}(function(s, e) {
    if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in s)
        s.innerHTML = e;
    else {
        for (Ki = Ki || document.createElement("div"),
        Ki.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = Ki.firstChild; s.firstChild; )
            s.removeChild(s.firstChild);
        for (; e.firstChild; )
            s.appendChild(e.firstChild)
    }
});
function oi(s, e) {
    if (e) {
        var t = s.firstChild;
        if (t && t === s.lastChild && t.nodeType === 3) {
            t.nodeValue = e;
            return
        }
    }
    s.textContent = e
}
var Yr = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , Zy = ["Webkit", "ms", "Moz", "O"];
Object.keys(Yr).forEach(function(s) {
    Zy.forEach(function(e) {
        e = e + s.charAt(0).toUpperCase() + s.substring(1),
        Yr[e] = Yr[s]
    })
});
function Um(s, e, t) {
    return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || Yr.hasOwnProperty(s) && Yr[s] ? ("" + e).trim() : e + "px"
}
function Bm(s, e) {
    s = s.style;
    for (var t in e)
        if (e.hasOwnProperty(t)) {
            var n = t.indexOf("--") === 0
              , r = Um(t, e[t], n);
            t === "float" && (t = "cssFloat"),
            n ? s.setProperty(t, r) : s[t] = r
        }
}
var qy = Ce({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function lc(s, e) {
    if (e) {
        if (qy[s] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(H(137, s));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(H(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(H(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(H(62))
    }
}
function cc(s, e) {
    if (s.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (s) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var uc = null;
function Tu(s) {
    return s = s.target || s.srcElement || window,
    s.correspondingUseElement && (s = s.correspondingUseElement),
    s.nodeType === 3 ? s.parentNode : s
}
var dc = null
  , ir = null
  , ar = null;
function zd(s) {
    if (s = Ni(s)) {
        if (typeof dc != "function")
            throw Error(H(280));
        var e = s.stateNode;
        e && (e = No(e),
        dc(s.stateNode, s.type, e))
    }
}
function $m(s) {
    ir ? ar ? ar.push(s) : ar = [s] : ir = s
}
function jm() {
    if (ir) {
        var s = ir
          , e = ar;
        if (ar = ir = null,
        zd(s),
        e)
            for (s = 0; s < e.length; s++)
                zd(e[s])
    }
}
function Gm(s, e) {
    return s(e)
}
function Vm() {}
var rl = !1;
function Hm(s, e, t) {
    if (rl)
        return s(e, t);
    rl = !0;
    try {
        return Gm(s, e, t)
    } finally {
        rl = !1,
        (ir !== null || ar !== null) && (Vm(),
        jm())
    }
}
function li(s, e) {
    var t = s.stateNode;
    if (t === null)
        return null;
    var n = No(t);
    if (n === null)
        return null;
    t = n[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (n = !n.disabled) || (s = s.type,
        n = !(s === "button" || s === "input" || s === "select" || s === "textarea")),
        s = !n;
        break e;
    default:
        s = !1
    }
    if (s)
        return null;
    if (t && typeof t != "function")
        throw Error(H(231, e, typeof t));
    return t
}
var hc = !1;
if (_s)
    try {
        var Nr = {};
        Object.defineProperty(Nr, "passive", {
            get: function() {
                hc = !0
            }
        }),
        window.addEventListener("test", Nr, Nr),
        window.removeEventListener("test", Nr, Nr)
    } catch {
        hc = !1
    }
function Qy(s, e, t, n, r, i, a, o, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(t, c)
    } catch (u) {
        this.onError(u)
    }
}
var Xr = !1
  , Ka = null
  , Wa = !1
  , fc = null
  , Jy = {
    onError: function(s) {
        Xr = !0,
        Ka = s
    }
};
function ex(s, e, t, n, r, i, a, o, l) {
    Xr = !1,
    Ka = null,
    Qy.apply(Jy, arguments)
}
function tx(s, e, t, n, r, i, a, o, l) {
    if (ex.apply(this, arguments),
    Xr) {
        if (Xr) {
            var c = Ka;
            Xr = !1,
            Ka = null
        } else
            throw Error(H(198));
        Wa || (Wa = !0,
        fc = c)
    }
}
function On(s) {
    var e = s
      , t = s;
    if (s.alternate)
        for (; e.return; )
            e = e.return;
    else {
        s = e;
        do
            e = s,
            e.flags & 4098 && (t = e.return),
            s = e.return;
        while (s)
    }
    return e.tag === 3 ? t : null
}
function Km(s) {
    if (s.tag === 13) {
        var e = s.memoizedState;
        if (e === null && (s = s.alternate,
        s !== null && (e = s.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function Yd(s) {
    if (On(s) !== s)
        throw Error(H(188))
}
function sx(s) {
    var e = s.alternate;
    if (!e) {
        if (e = On(s),
        e === null)
            throw Error(H(188));
        return e !== s ? null : s
    }
    for (var t = s, n = e; ; ) {
        var r = t.return;
        if (r === null)
            break;
        var i = r.alternate;
        if (i === null) {
            if (n = r.return,
            n !== null) {
                t = n;
                continue
            }
            break
        }
        if (r.child === i.child) {
            for (i = r.child; i; ) {
                if (i === t)
                    return Yd(r),
                    s;
                if (i === n)
                    return Yd(r),
                    e;
                i = i.sibling
            }
            throw Error(H(188))
        }
        if (t.return !== n.return)
            t = r,
            n = i;
        else {
            for (var a = !1, o = r.child; o; ) {
                if (o === t) {
                    a = !0,
                    t = r,
                    n = i;
                    break
                }
                if (o === n) {
                    a = !0,
                    n = r,
                    t = i;
                    break
                }
                o = o.sibling
            }
            if (!a) {
                for (o = i.child; o; ) {
                    if (o === t) {
                        a = !0,
                        t = i,
                        n = r;
                        break
                    }
                    if (o === n) {
                        a = !0,
                        n = i,
                        t = r;
                        break
                    }
                    o = o.sibling
                }
                if (!a)
                    throw Error(H(189))
            }
        }
        if (t.alternate !== n)
            throw Error(H(190))
    }
    if (t.tag !== 3)
        throw Error(H(188));
    return t.stateNode.current === t ? s : e
}
function Wm(s) {
    return s = sx(s),
    s !== null ? zm(s) : null
}
function zm(s) {
    if (s.tag === 5 || s.tag === 6)
        return s;
    for (s = s.child; s !== null; ) {
        var e = zm(s);
        if (e !== null)
            return e;
        s = s.sibling
    }
    return null
}
var Ym = Ct.unstable_scheduleCallback
  , Xd = Ct.unstable_cancelCallback
  , nx = Ct.unstable_shouldYield
  , rx = Ct.unstable_requestPaint
  , Me = Ct.unstable_now
  , ix = Ct.unstable_getCurrentPriorityLevel
  , Lu = Ct.unstable_ImmediatePriority
  , Xm = Ct.unstable_UserBlockingPriority
  , za = Ct.unstable_NormalPriority
  , ax = Ct.unstable_LowPriority
  , Zm = Ct.unstable_IdlePriority
  , ko = null
  , us = null;
function ox(s) {
    if (us && typeof us.onCommitFiberRoot == "function")
        try {
            us.onCommitFiberRoot(ko, s, void 0, (s.current.flags & 128) === 128)
        } catch {}
}
var Qt = Math.clz32 ? Math.clz32 : ux
  , lx = Math.log
  , cx = Math.LN2;
function ux(s) {
    return s >>>= 0,
    s === 0 ? 32 : 31 - (lx(s) / cx | 0) | 0
}
var Wi = 64
  , zi = 4194304;
function Kr(s) {
    switch (s & -s) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return s & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return s & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return s
    }
}
function Ya(s, e) {
    var t = s.pendingLanes;
    if (t === 0)
        return 0;
    var n = 0
      , r = s.suspendedLanes
      , i = s.pingedLanes
      , a = t & 268435455;
    if (a !== 0) {
        var o = a & ~r;
        o !== 0 ? n = Kr(o) : (i &= a,
        i !== 0 && (n = Kr(i)))
    } else
        a = t & ~r,
        a !== 0 ? n = Kr(a) : i !== 0 && (n = Kr(i));
    if (n === 0)
        return 0;
    if (e !== 0 && e !== n && !(e & r) && (r = n & -n,
    i = e & -e,
    r >= i || r === 16 && (i & 4194240) !== 0))
        return e;
    if (n & 4 && (n |= t & 16),
    e = s.entangledLanes,
    e !== 0)
        for (s = s.entanglements,
        e &= n; 0 < e; )
            t = 31 - Qt(e),
            r = 1 << t,
            n |= s[t],
            e &= ~r;
    return n
}
function dx(s, e) {
    switch (s) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function hx(s, e) {
    for (var t = s.suspendedLanes, n = s.pingedLanes, r = s.expirationTimes, i = s.pendingLanes; 0 < i; ) {
        var a = 31 - Qt(i)
          , o = 1 << a
          , l = r[a];
        l === -1 ? (!(o & t) || o & n) && (r[a] = dx(o, e)) : l <= e && (s.expiredLanes |= o),
        i &= ~o
    }
}
function mc(s) {
    return s = s.pendingLanes & -1073741825,
    s !== 0 ? s : s & 1073741824 ? 1073741824 : 0
}
function qm() {
    var s = Wi;
    return Wi <<= 1,
    !(Wi & 4194240) && (Wi = 64),
    s
}
function il(s) {
    for (var e = [], t = 0; 31 > t; t++)
        e.push(s);
    return e
}
function Di(s, e, t) {
    s.pendingLanes |= e,
    e !== 536870912 && (s.suspendedLanes = 0,
    s.pingedLanes = 0),
    s = s.eventTimes,
    e = 31 - Qt(e),
    s[e] = t
}
function fx(s, e) {
    var t = s.pendingLanes & ~e;
    s.pendingLanes = e,
    s.suspendedLanes = 0,
    s.pingedLanes = 0,
    s.expiredLanes &= e,
    s.mutableReadLanes &= e,
    s.entangledLanes &= e,
    e = s.entanglements;
    var n = s.eventTimes;
    for (s = s.expirationTimes; 0 < t; ) {
        var r = 31 - Qt(t)
          , i = 1 << r;
        e[r] = 0,
        n[r] = -1,
        s[r] = -1,
        t &= ~i
    }
}
function Iu(s, e) {
    var t = s.entangledLanes |= e;
    for (s = s.entanglements; t; ) {
        var n = 31 - Qt(t)
          , r = 1 << n;
        r & e | s[n] & e && (s[n] |= e),
        t &= ~r
    }
}
var me = 0;
function Qm(s) {
    return s &= -s,
    1 < s ? 4 < s ? s & 268435455 ? 16 : 536870912 : 4 : 1
}
var Jm, Au, eg, tg, sg, gc = !1, Yi = [], Xs = null, Zs = null, qs = null, ci = new Map, ui = new Map, Ks = [], mx = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Zd(s, e) {
    switch (s) {
    case "focusin":
    case "focusout":
        Xs = null;
        break;
    case "dragenter":
    case "dragleave":
        Zs = null;
        break;
    case "mouseover":
    case "mouseout":
        qs = null;
        break;
    case "pointerover":
    case "pointerout":
        ci.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        ui.delete(e.pointerId)
    }
}
function Or(s, e, t, n, r, i) {
    return s === null || s.nativeEvent !== i ? (s = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: n,
        nativeEvent: i,
        targetContainers: [r]
    },
    e !== null && (e = Ni(e),
    e !== null && Au(e)),
    s) : (s.eventSystemFlags |= n,
    e = s.targetContainers,
    r !== null && e.indexOf(r) === -1 && e.push(r),
    s)
}
function gx(s, e, t, n, r) {
    switch (e) {
    case "focusin":
        return Xs = Or(Xs, s, e, t, n, r),
        !0;
    case "dragenter":
        return Zs = Or(Zs, s, e, t, n, r),
        !0;
    case "mouseover":
        return qs = Or(qs, s, e, t, n, r),
        !0;
    case "pointerover":
        var i = r.pointerId;
        return ci.set(i, Or(ci.get(i) || null, s, e, t, n, r)),
        !0;
    case "gotpointercapture":
        return i = r.pointerId,
        ui.set(i, Or(ui.get(i) || null, s, e, t, n, r)),
        !0
    }
    return !1
}
function ng(s) {
    var e = Tn(s.target);
    if (e !== null) {
        var t = On(e);
        if (t !== null) {
            if (e = t.tag,
            e === 13) {
                if (e = Km(t),
                e !== null) {
                    s.blockedOn = e,
                    sg(s.priority, function() {
                        eg(t)
                    });
                    return
                }
            } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
                s.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
                return
            }
        }
    }
    s.blockedOn = null
}
function Ia(s) {
    if (s.blockedOn !== null)
        return !1;
    for (var e = s.targetContainers; 0 < e.length; ) {
        var t = pc(s.domEventName, s.eventSystemFlags, e[0], s.nativeEvent);
        if (t === null) {
            t = s.nativeEvent;
            var n = new t.constructor(t.type,t);
            uc = n,
            t.target.dispatchEvent(n),
            uc = null
        } else
            return e = Ni(t),
            e !== null && Au(e),
            s.blockedOn = t,
            !1;
        e.shift()
    }
    return !0
}
function qd(s, e, t) {
    Ia(s) && t.delete(e)
}
function px() {
    gc = !1,
    Xs !== null && Ia(Xs) && (Xs = null),
    Zs !== null && Ia(Zs) && (Zs = null),
    qs !== null && Ia(qs) && (qs = null),
    ci.forEach(qd),
    ui.forEach(qd)
}
function Mr(s, e) {
    s.blockedOn === e && (s.blockedOn = null,
    gc || (gc = !0,
    Ct.unstable_scheduleCallback(Ct.unstable_NormalPriority, px)))
}
function di(s) {
    function e(r) {
        return Mr(r, s)
    }
    if (0 < Yi.length) {
        Mr(Yi[0], s);
        for (var t = 1; t < Yi.length; t++) {
            var n = Yi[t];
            n.blockedOn === s && (n.blockedOn = null)
        }
    }
    for (Xs !== null && Mr(Xs, s),
    Zs !== null && Mr(Zs, s),
    qs !== null && Mr(qs, s),
    ci.forEach(e),
    ui.forEach(e),
    t = 0; t < Ks.length; t++)
        n = Ks[t],
        n.blockedOn === s && (n.blockedOn = null);
    for (; 0 < Ks.length && (t = Ks[0],
    t.blockedOn === null); )
        ng(t),
        t.blockedOn === null && Ks.shift()
}
var or = Ms.ReactCurrentBatchConfig
  , Xa = !0;
function yx(s, e, t, n) {
    var r = me
      , i = or.transition;
    or.transition = null;
    try {
        me = 1,
        bu(s, e, t, n)
    } finally {
        me = r,
        or.transition = i
    }
}
function xx(s, e, t, n) {
    var r = me
      , i = or.transition;
    or.transition = null;
    try {
        me = 4,
        bu(s, e, t, n)
    } finally {
        me = r,
        or.transition = i
    }
}
function bu(s, e, t, n) {
    if (Xa) {
        var r = pc(s, e, t, n);
        if (r === null)
            gl(s, e, n, Za, t),
            Zd(s, n);
        else if (gx(r, s, e, t, n))
            n.stopPropagation();
        else if (Zd(s, n),
        e & 4 && -1 < mx.indexOf(s)) {
            for (; r !== null; ) {
                var i = Ni(r);
                if (i !== null && Jm(i),
                i = pc(s, e, t, n),
                i === null && gl(s, e, n, Za, t),
                i === r)
                    break;
                r = i
            }
            r !== null && n.stopPropagation()
        } else
            gl(s, e, n, null, t)
    }
}
var Za = null;
function pc(s, e, t, n) {
    if (Za = null,
    s = Tu(n),
    s = Tn(s),
    s !== null)
        if (e = On(s),
        e === null)
            s = null;
        else if (t = e.tag,
        t === 13) {
            if (s = Km(e),
            s !== null)
                return s;
            s = null
        } else if (t === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            s = null
        } else
            e !== s && (s = null);
    return Za = s,
    null
}
function rg(s) {
    switch (s) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (ix()) {
        case Lu:
            return 1;
        case Xm:
            return 4;
        case za:
        case ax:
            return 16;
        case Zm:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var zs = null
  , Ru = null
  , Aa = null;
function ig() {
    if (Aa)
        return Aa;
    var s, e = Ru, t = e.length, n, r = "value"in zs ? zs.value : zs.textContent, i = r.length;
    for (s = 0; s < t && e[s] === r[s]; s++)
        ;
    var a = t - s;
    for (n = 1; n <= a && e[t - n] === r[i - n]; n++)
        ;
    return Aa = r.slice(s, 1 < n ? 1 - n : void 0)
}
function ba(s) {
    var e = s.keyCode;
    return "charCode"in s ? (s = s.charCode,
    s === 0 && e === 13 && (s = 13)) : s = e,
    s === 10 && (s = 13),
    32 <= s || s === 13 ? s : 0
}
function Xi() {
    return !0
}
function Qd() {
    return !1
}
function _t(s) {
    function e(t, n, r, i, a) {
        this._reactName = t,
        this._targetInst = r,
        this.type = n,
        this.nativeEvent = i,
        this.target = a,
        this.currentTarget = null;
        for (var o in s)
            s.hasOwnProperty(o) && (t = s[o],
            this[o] = t ? t(i) : i[o]);
        return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? Xi : Qd,
        this.isPropagationStopped = Qd,
        this
    }
    return Ce(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var t = this.nativeEvent;
            t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = !1),
            this.isDefaultPrevented = Xi)
        },
        stopPropagation: function() {
            var t = this.nativeEvent;
            t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
            this.isPropagationStopped = Xi)
        },
        persist: function() {},
        isPersistent: Xi
    }),
    e
}
var br = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(s) {
        return s.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, wu = _t(br), Pi = Ce({}, br, {
    view: 0,
    detail: 0
}), vx = _t(Pi), al, ol, Fr, _o = Ce({}, Pi, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Cu,
    button: 0,
    buttons: 0,
    relatedTarget: function(s) {
        return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget
    },
    movementX: function(s) {
        return "movementX"in s ? s.movementX : (s !== Fr && (Fr && s.type === "mousemove" ? (al = s.screenX - Fr.screenX,
        ol = s.screenY - Fr.screenY) : ol = al = 0,
        Fr = s),
        al)
    },
    movementY: function(s) {
        return "movementY"in s ? s.movementY : ol
    }
}), Jd = _t(_o), Ex = Ce({}, _o, {
    dataTransfer: 0
}), Sx = _t(Ex), Tx = Ce({}, Pi, {
    relatedTarget: 0
}), ll = _t(Tx), Lx = Ce({}, br, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Ix = _t(Lx), Ax = Ce({}, br, {
    clipboardData: function(s) {
        return "clipboardData"in s ? s.clipboardData : window.clipboardData
    }
}), bx = _t(Ax), Rx = Ce({}, br, {
    data: 0
}), eh = _t(Rx), wx = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, Cx = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, kx = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function _x(s) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(s) : (s = kx[s]) ? !!e[s] : !1
}
function Cu() {
    return _x
}
var Dx = Ce({}, Pi, {
    key: function(s) {
        if (s.key) {
            var e = wx[s.key] || s.key;
            if (e !== "Unidentified")
                return e
        }
        return s.type === "keypress" ? (s = ba(s),
        s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? Cx[s.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Cu,
    charCode: function(s) {
        return s.type === "keypress" ? ba(s) : 0
    },
    keyCode: function(s) {
        return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
    },
    which: function(s) {
        return s.type === "keypress" ? ba(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
    }
})
  , Px = _t(Dx)
  , Nx = Ce({}, _o, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , th = _t(Nx)
  , Ox = Ce({}, Pi, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Cu
})
  , Mx = _t(Ox)
  , Fx = Ce({}, br, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , Ux = _t(Fx)
  , Bx = Ce({}, _o, {
    deltaX: function(s) {
        return "deltaX"in s ? s.deltaX : "wheelDeltaX"in s ? -s.wheelDeltaX : 0
    },
    deltaY: function(s) {
        return "deltaY"in s ? s.deltaY : "wheelDeltaY"in s ? -s.wheelDeltaY : "wheelDelta"in s ? -s.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , $x = _t(Bx)
  , jx = [9, 13, 27, 32]
  , ku = _s && "CompositionEvent"in window
  , Zr = null;
_s && "documentMode"in document && (Zr = document.documentMode);
var Gx = _s && "TextEvent"in window && !Zr
  , ag = _s && (!ku || Zr && 8 < Zr && 11 >= Zr)
  , sh = " "
  , nh = !1;
function og(s, e) {
    switch (s) {
    case "keyup":
        return jx.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function lg(s) {
    return s = s.detail,
    typeof s == "object" && "data"in s ? s.data : null
}
var zn = !1;
function Vx(s, e) {
    switch (s) {
    case "compositionend":
        return lg(e);
    case "keypress":
        return e.which !== 32 ? null : (nh = !0,
        sh);
    case "textInput":
        return s = e.data,
        s === sh && nh ? null : s;
    default:
        return null
    }
}
function Hx(s, e) {
    if (zn)
        return s === "compositionend" || !ku && og(s, e) ? (s = ig(),
        Aa = Ru = zs = null,
        zn = !1,
        s) : null;
    switch (s) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return ag && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var Kx = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function rh(s) {
    var e = s && s.nodeName && s.nodeName.toLowerCase();
    return e === "input" ? !!Kx[s.type] : e === "textarea"
}
function cg(s, e, t, n) {
    $m(n),
    e = qa(e, "onChange"),
    0 < e.length && (t = new wu("onChange","change",null,t,n),
    s.push({
        event: t,
        listeners: e
    }))
}
var qr = null
  , hi = null;
function Wx(s) {
    Eg(s, 0)
}
function Do(s) {
    var e = Zn(s);
    if (Pm(e))
        return s
}
function zx(s, e) {
    if (s === "change")
        return e
}
var ug = !1;
if (_s) {
    var cl;
    if (_s) {
        var ul = "oninput"in document;
        if (!ul) {
            var ih = document.createElement("div");
            ih.setAttribute("oninput", "return;"),
            ul = typeof ih.oninput == "function"
        }
        cl = ul
    } else
        cl = !1;
    ug = cl && (!document.documentMode || 9 < document.documentMode)
}
function ah() {
    qr && (qr.detachEvent("onpropertychange", dg),
    hi = qr = null)
}
function dg(s) {
    if (s.propertyName === "value" && Do(hi)) {
        var e = [];
        cg(e, hi, s, Tu(s)),
        Hm(Wx, e)
    }
}
function Yx(s, e, t) {
    s === "focusin" ? (ah(),
    qr = e,
    hi = t,
    qr.attachEvent("onpropertychange", dg)) : s === "focusout" && ah()
}
function Xx(s) {
    if (s === "selectionchange" || s === "keyup" || s === "keydown")
        return Do(hi)
}
function Zx(s, e) {
    if (s === "click")
        return Do(e)
}
function qx(s, e) {
    if (s === "input" || s === "change")
        return Do(e)
}
function Qx(s, e) {
    return s === e && (s !== 0 || 1 / s === 1 / e) || s !== s && e !== e
}
var es = typeof Object.is == "function" ? Object.is : Qx;
function fi(s, e) {
    if (es(s, e))
        return !0;
    if (typeof s != "object" || s === null || typeof e != "object" || e === null)
        return !1;
    var t = Object.keys(s)
      , n = Object.keys(e);
    if (t.length !== n.length)
        return !1;
    for (n = 0; n < t.length; n++) {
        var r = t[n];
        if (!Ql.call(e, r) || !es(s[r], e[r]))
            return !1
    }
    return !0
}
function oh(s) {
    for (; s && s.firstChild; )
        s = s.firstChild;
    return s
}
function lh(s, e) {
    var t = oh(s);
    s = 0;
    for (var n; t; ) {
        if (t.nodeType === 3) {
            if (n = s + t.textContent.length,
            s <= e && n >= e)
                return {
                    node: t,
                    offset: e - s
                };
            s = n
        }
        e: {
            for (; t; ) {
                if (t.nextSibling) {
                    t = t.nextSibling;
                    break e
                }
                t = t.parentNode
            }
            t = void 0
        }
        t = oh(t)
    }
}
function hg(s, e) {
    return s && e ? s === e ? !0 : s && s.nodeType === 3 ? !1 : e && e.nodeType === 3 ? hg(s, e.parentNode) : "contains"in s ? s.contains(e) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(e) & 16) : !1 : !1
}
function fg() {
    for (var s = window, e = Ha(); e instanceof s.HTMLIFrameElement; ) {
        try {
            var t = typeof e.contentWindow.location.href == "string"
        } catch {
            t = !1
        }
        if (t)
            s = e.contentWindow;
        else
            break;
        e = Ha(s.document)
    }
    return e
}
function _u(s) {
    var e = s && s.nodeName && s.nodeName.toLowerCase();
    return e && (e === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || e === "textarea" || s.contentEditable === "true")
}
function Jx(s) {
    var e = fg()
      , t = s.focusedElem
      , n = s.selectionRange;
    if (e !== t && t && t.ownerDocument && hg(t.ownerDocument.documentElement, t)) {
        if (n !== null && _u(t)) {
            if (e = n.start,
            s = n.end,
            s === void 0 && (s = e),
            "selectionStart"in t)
                t.selectionStart = e,
                t.selectionEnd = Math.min(s, t.value.length);
            else if (s = (e = t.ownerDocument || document) && e.defaultView || window,
            s.getSelection) {
                s = s.getSelection();
                var r = t.textContent.length
                  , i = Math.min(n.start, r);
                n = n.end === void 0 ? i : Math.min(n.end, r),
                !s.extend && i > n && (r = n,
                n = i,
                i = r),
                r = lh(t, i);
                var a = lh(t, n);
                r && a && (s.rangeCount !== 1 || s.anchorNode !== r.node || s.anchorOffset !== r.offset || s.focusNode !== a.node || s.focusOffset !== a.offset) && (e = e.createRange(),
                e.setStart(r.node, r.offset),
                s.removeAllRanges(),
                i > n ? (s.addRange(e),
                s.extend(a.node, a.offset)) : (e.setEnd(a.node, a.offset),
                s.addRange(e)))
            }
        }
        for (e = [],
        s = t; s = s.parentNode; )
            s.nodeType === 1 && e.push({
                element: s,
                left: s.scrollLeft,
                top: s.scrollTop
            });
        for (typeof t.focus == "function" && t.focus(),
        t = 0; t < e.length; t++)
            s = e[t],
            s.element.scrollLeft = s.left,
            s.element.scrollTop = s.top
    }
}
var ev = _s && "documentMode"in document && 11 >= document.documentMode
  , Yn = null
  , yc = null
  , Qr = null
  , xc = !1;
function ch(s, e, t) {
    var n = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
    xc || Yn == null || Yn !== Ha(n) || (n = Yn,
    "selectionStart"in n && _u(n) ? n = {
        start: n.selectionStart,
        end: n.selectionEnd
    } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(),
    n = {
        anchorNode: n.anchorNode,
        anchorOffset: n.anchorOffset,
        focusNode: n.focusNode,
        focusOffset: n.focusOffset
    }),
    Qr && fi(Qr, n) || (Qr = n,
    n = qa(yc, "onSelect"),
    0 < n.length && (e = new wu("onSelect","select",null,e,t),
    s.push({
        event: e,
        listeners: n
    }),
    e.target = Yn)))
}
function Zi(s, e) {
    var t = {};
    return t[s.toLowerCase()] = e.toLowerCase(),
    t["Webkit" + s] = "webkit" + e,
    t["Moz" + s] = "moz" + e,
    t
}
var Xn = {
    animationend: Zi("Animation", "AnimationEnd"),
    animationiteration: Zi("Animation", "AnimationIteration"),
    animationstart: Zi("Animation", "AnimationStart"),
    transitionend: Zi("Transition", "TransitionEnd")
}
  , dl = {}
  , mg = {};
_s && (mg = document.createElement("div").style,
"AnimationEvent"in window || (delete Xn.animationend.animation,
delete Xn.animationiteration.animation,
delete Xn.animationstart.animation),
"TransitionEvent"in window || delete Xn.transitionend.transition);
function Po(s) {
    if (dl[s])
        return dl[s];
    if (!Xn[s])
        return s;
    var e = Xn[s], t;
    for (t in e)
        if (e.hasOwnProperty(t) && t in mg)
            return dl[s] = e[t];
    return s
}
var gg = Po("animationend")
  , pg = Po("animationiteration")
  , yg = Po("animationstart")
  , xg = Po("transitionend")
  , vg = new Map
  , uh = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function cn(s, e) {
    vg.set(s, e),
    Nn(e, [s])
}
for (var hl = 0; hl < uh.length; hl++) {
    var fl = uh[hl]
      , tv = fl.toLowerCase()
      , sv = fl[0].toUpperCase() + fl.slice(1);
    cn(tv, "on" + sv)
}
cn(gg, "onAnimationEnd");
cn(pg, "onAnimationIteration");
cn(yg, "onAnimationStart");
cn("dblclick", "onDoubleClick");
cn("focusin", "onFocus");
cn("focusout", "onBlur");
cn(xg, "onTransitionEnd");
pr("onMouseEnter", ["mouseout", "mouseover"]);
pr("onMouseLeave", ["mouseout", "mouseover"]);
pr("onPointerEnter", ["pointerout", "pointerover"]);
pr("onPointerLeave", ["pointerout", "pointerover"]);
Nn("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Nn("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Nn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Nn("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Nn("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Nn("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Wr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , nv = new Set("cancel close invalid load scroll toggle".split(" ").concat(Wr));
function dh(s, e, t) {
    var n = s.type || "unknown-event";
    s.currentTarget = t,
    tx(n, e, void 0, s),
    s.currentTarget = null
}
function Eg(s, e) {
    e = (e & 4) !== 0;
    for (var t = 0; t < s.length; t++) {
        var n = s[t]
          , r = n.event;
        n = n.listeners;
        e: {
            var i = void 0;
            if (e)
                for (var a = n.length - 1; 0 <= a; a--) {
                    var o = n[a]
                      , l = o.instance
                      , c = o.currentTarget;
                    if (o = o.listener,
                    l !== i && r.isPropagationStopped())
                        break e;
                    dh(r, o, c),
                    i = l
                }
            else
                for (a = 0; a < n.length; a++) {
                    if (o = n[a],
                    l = o.instance,
                    c = o.currentTarget,
                    o = o.listener,
                    l !== i && r.isPropagationStopped())
                        break e;
                    dh(r, o, c),
                    i = l
                }
        }
    }
    if (Wa)
        throw s = fc,
        Wa = !1,
        fc = null,
        s
}
function Ee(s, e) {
    var t = e[Lc];
    t === void 0 && (t = e[Lc] = new Set);
    var n = s + "__bubble";
    t.has(n) || (Sg(e, s, 2, !1),
    t.add(n))
}
function ml(s, e, t) {
    var n = 0;
    e && (n |= 4),
    Sg(t, s, n, e)
}
var qi = "_reactListening" + Math.random().toString(36).slice(2);
function mi(s) {
    if (!s[qi]) {
        s[qi] = !0,
        wm.forEach(function(t) {
            t !== "selectionchange" && (nv.has(t) || ml(t, !1, s),
            ml(t, !0, s))
        });
        var e = s.nodeType === 9 ? s : s.ownerDocument;
        e === null || e[qi] || (e[qi] = !0,
        ml("selectionchange", !1, e))
    }
}
function Sg(s, e, t, n) {
    switch (rg(e)) {
    case 1:
        var r = yx;
        break;
    case 4:
        r = xx;
        break;
    default:
        r = bu
    }
    t = r.bind(null, e, t, s),
    r = void 0,
    !hc || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = !0),
    n ? r !== void 0 ? s.addEventListener(e, t, {
        capture: !0,
        passive: r
    }) : s.addEventListener(e, t, !0) : r !== void 0 ? s.addEventListener(e, t, {
        passive: r
    }) : s.addEventListener(e, t, !1)
}
function gl(s, e, t, n, r) {
    var i = n;
    if (!(e & 1) && !(e & 2) && n !== null)
        e: for (; ; ) {
            if (n === null)
                return;
            var a = n.tag;
            if (a === 3 || a === 4) {
                var o = n.stateNode.containerInfo;
                if (o === r || o.nodeType === 8 && o.parentNode === r)
                    break;
                if (a === 4)
                    for (a = n.return; a !== null; ) {
                        var l = a.tag;
                        if ((l === 3 || l === 4) && (l = a.stateNode.containerInfo,
                        l === r || l.nodeType === 8 && l.parentNode === r))
                            return;
                        a = a.return
                    }
                for (; o !== null; ) {
                    if (a = Tn(o),
                    a === null)
                        return;
                    if (l = a.tag,
                    l === 5 || l === 6) {
                        n = i = a;
                        continue e
                    }
                    o = o.parentNode
                }
            }
            n = n.return
        }
    Hm(function() {
        var c = i
          , u = Tu(t)
          , d = [];
        e: {
            var h = vg.get(s);
            if (h !== void 0) {
                var f = wu
                  , m = s;
                switch (s) {
                case "keypress":
                    if (ba(t) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    f = Px;
                    break;
                case "focusin":
                    m = "focus",
                    f = ll;
                    break;
                case "focusout":
                    m = "blur",
                    f = ll;
                    break;
                case "beforeblur":
                case "afterblur":
                    f = ll;
                    break;
                case "click":
                    if (t.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    f = Jd;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    f = Sx;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    f = Mx;
                    break;
                case gg:
                case pg:
                case yg:
                    f = Ix;
                    break;
                case xg:
                    f = Ux;
                    break;
                case "scroll":
                    f = vx;
                    break;
                case "wheel":
                    f = $x;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    f = bx;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    f = th
                }
                var p = (e & 4) !== 0
                  , x = !p && s === "scroll"
                  , y = p ? h !== null ? h + "Capture" : null : h;
                p = [];
                for (var v = c, E; v !== null; ) {
                    E = v;
                    var T = E.stateNode;
                    if (E.tag === 5 && T !== null && (E = T,
                    y !== null && (T = li(v, y),
                    T != null && p.push(gi(v, T, E)))),
                    x)
                        break;
                    v = v.return
                }
                0 < p.length && (h = new f(h,m,null,t,u),
                d.push({
                    event: h,
                    listeners: p
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (h = s === "mouseover" || s === "pointerover",
                f = s === "mouseout" || s === "pointerout",
                h && t !== uc && (m = t.relatedTarget || t.fromElement) && (Tn(m) || m[Ds]))
                    break e;
                if ((f || h) && (h = u.window === u ? u : (h = u.ownerDocument) ? h.defaultView || h.parentWindow : window,
                f ? (m = t.relatedTarget || t.toElement,
                f = c,
                m = m ? Tn(m) : null,
                m !== null && (x = On(m),
                m !== x || m.tag !== 5 && m.tag !== 6) && (m = null)) : (f = null,
                m = c),
                f !== m)) {
                    if (p = Jd,
                    T = "onMouseLeave",
                    y = "onMouseEnter",
                    v = "mouse",
                    (s === "pointerout" || s === "pointerover") && (p = th,
                    T = "onPointerLeave",
                    y = "onPointerEnter",
                    v = "pointer"),
                    x = f == null ? h : Zn(f),
                    E = m == null ? h : Zn(m),
                    h = new p(T,v + "leave",f,t,u),
                    h.target = x,
                    h.relatedTarget = E,
                    T = null,
                    Tn(u) === c && (p = new p(y,v + "enter",m,t,u),
                    p.target = E,
                    p.relatedTarget = x,
                    T = p),
                    x = T,
                    f && m)
                        t: {
                            for (p = f,
                            y = m,
                            v = 0,
                            E = p; E; E = Bn(E))
                                v++;
                            for (E = 0,
                            T = y; T; T = Bn(T))
                                E++;
                            for (; 0 < v - E; )
                                p = Bn(p),
                                v--;
                            for (; 0 < E - v; )
                                y = Bn(y),
                                E--;
                            for (; v--; ) {
                                if (p === y || y !== null && p === y.alternate)
                                    break t;
                                p = Bn(p),
                                y = Bn(y)
                            }
                            p = null
                        }
                    else
                        p = null;
                    f !== null && hh(d, h, f, p, !1),
                    m !== null && x !== null && hh(d, x, m, p, !0)
                }
            }
            e: {
                if (h = c ? Zn(c) : window,
                f = h.nodeName && h.nodeName.toLowerCase(),
                f === "select" || f === "input" && h.type === "file")
                    var L = zx;
                else if (rh(h))
                    if (ug)
                        L = qx;
                    else {
                        L = Xx;
                        var R = Yx
                    }
                else
                    (f = h.nodeName) && f.toLowerCase() === "input" && (h.type === "checkbox" || h.type === "radio") && (L = Zx);
                if (L && (L = L(s, c))) {
                    cg(d, L, t, u);
                    break e
                }
                R && R(s, h, c),
                s === "focusout" && (R = h._wrapperState) && R.controlled && h.type === "number" && ic(h, "number", h.value)
            }
            switch (R = c ? Zn(c) : window,
            s) {
            case "focusin":
                (rh(R) || R.contentEditable === "true") && (Yn = R,
                yc = c,
                Qr = null);
                break;
            case "focusout":
                Qr = yc = Yn = null;
                break;
            case "mousedown":
                xc = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                xc = !1,
                ch(d, t, u);
                break;
            case "selectionchange":
                if (ev)
                    break;
            case "keydown":
            case "keyup":
                ch(d, t, u)
            }
            var I;
            if (ku)
                e: {
                    switch (s) {
                    case "compositionstart":
                        var A = "onCompositionStart";
                        break e;
                    case "compositionend":
                        A = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        A = "onCompositionUpdate";
                        break e
                    }
                    A = void 0
                }
            else
                zn ? og(s, t) && (A = "onCompositionEnd") : s === "keydown" && t.keyCode === 229 && (A = "onCompositionStart");
            A && (ag && t.locale !== "ko" && (zn || A !== "onCompositionStart" ? A === "onCompositionEnd" && zn && (I = ig()) : (zs = u,
            Ru = "value"in zs ? zs.value : zs.textContent,
            zn = !0)),
            R = qa(c, A),
            0 < R.length && (A = new eh(A,s,null,t,u),
            d.push({
                event: A,
                listeners: R
            }),
            I ? A.data = I : (I = lg(t),
            I !== null && (A.data = I)))),
            (I = Gx ? Vx(s, t) : Hx(s, t)) && (c = qa(c, "onBeforeInput"),
            0 < c.length && (u = new eh("onBeforeInput","beforeinput",null,t,u),
            d.push({
                event: u,
                listeners: c
            }),
            u.data = I))
        }
        Eg(d, e)
    })
}
function gi(s, e, t) {
    return {
        instance: s,
        listener: e,
        currentTarget: t
    }
}
function qa(s, e) {
    for (var t = e + "Capture", n = []; s !== null; ) {
        var r = s
          , i = r.stateNode;
        r.tag === 5 && i !== null && (r = i,
        i = li(s, t),
        i != null && n.unshift(gi(s, i, r)),
        i = li(s, e),
        i != null && n.push(gi(s, i, r))),
        s = s.return
    }
    return n
}
function Bn(s) {
    if (s === null)
        return null;
    do
        s = s.return;
    while (s && s.tag !== 5);
    return s || null
}
function hh(s, e, t, n, r) {
    for (var i = e._reactName, a = []; t !== null && t !== n; ) {
        var o = t
          , l = o.alternate
          , c = o.stateNode;
        if (l !== null && l === n)
            break;
        o.tag === 5 && c !== null && (o = c,
        r ? (l = li(t, i),
        l != null && a.unshift(gi(t, l, o))) : r || (l = li(t, i),
        l != null && a.push(gi(t, l, o)))),
        t = t.return
    }
    a.length !== 0 && s.push({
        event: e,
        listeners: a
    })
}
var rv = /\r\n?/g
  , iv = /\u0000|\uFFFD/g;
function fh(s) {
    return (typeof s == "string" ? s : "" + s).replace(rv, `
`).replace(iv, "")
}
function Qi(s, e, t) {
    if (e = fh(e),
    fh(s) !== e && t)
        throw Error(H(425))
}
function Qa() {}
var vc = null
  , Ec = null;
function Sc(s, e) {
    return s === "textarea" || s === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var Tc = typeof setTimeout == "function" ? setTimeout : void 0
  , av = typeof clearTimeout == "function" ? clearTimeout : void 0
  , mh = typeof Promise == "function" ? Promise : void 0
  , ov = typeof queueMicrotask == "function" ? queueMicrotask : typeof mh < "u" ? function(s) {
    return mh.resolve(null).then(s).catch(lv)
}
: Tc;
function lv(s) {
    setTimeout(function() {
        throw s
    })
}
function pl(s, e) {
    var t = e
      , n = 0;
    do {
        var r = t.nextSibling;
        if (s.removeChild(t),
        r && r.nodeType === 8)
            if (t = r.data,
            t === "/$") {
                if (n === 0) {
                    s.removeChild(r),
                    di(e);
                    return
                }
                n--
            } else
                t !== "$" && t !== "$?" && t !== "$!" || n++;
        t = r
    } while (t);
    di(e)
}
function Qs(s) {
    for (; s != null; s = s.nextSibling) {
        var e = s.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = s.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return s
}
function gh(s) {
    s = s.previousSibling;
    for (var e = 0; s; ) {
        if (s.nodeType === 8) {
            var t = s.data;
            if (t === "$" || t === "$!" || t === "$?") {
                if (e === 0)
                    return s;
                e--
            } else
                t === "/$" && e++
        }
        s = s.previousSibling
    }
    return null
}
var Rr = Math.random().toString(36).slice(2)
  , os = "__reactFiber$" + Rr
  , pi = "__reactProps$" + Rr
  , Ds = "__reactContainer$" + Rr
  , Lc = "__reactEvents$" + Rr
  , cv = "__reactListeners$" + Rr
  , uv = "__reactHandles$" + Rr;
function Tn(s) {
    var e = s[os];
    if (e)
        return e;
    for (var t = s.parentNode; t; ) {
        if (e = t[Ds] || t[os]) {
            if (t = e.alternate,
            e.child !== null || t !== null && t.child !== null)
                for (s = gh(s); s !== null; ) {
                    if (t = s[os])
                        return t;
                    s = gh(s)
                }
            return e
        }
        s = t,
        t = s.parentNode
    }
    return null
}
function Ni(s) {
    return s = s[os] || s[Ds],
    !s || s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3 ? null : s
}
function Zn(s) {
    if (s.tag === 5 || s.tag === 6)
        return s.stateNode;
    throw Error(H(33))
}
function No(s) {
    return s[pi] || null
}
var Ic = []
  , qn = -1;
function un(s) {
    return {
        current: s
    }
}
function Se(s) {
    0 > qn || (s.current = Ic[qn],
    Ic[qn] = null,
    qn--)
}
function ve(s, e) {
    qn++,
    Ic[qn] = s.current,
    s.current = e
}
var an = {}
  , it = un(an)
  , xt = un(!1)
  , wn = an;
function yr(s, e) {
    var t = s.type.contextTypes;
    if (!t)
        return an;
    var n = s.stateNode;
    if (n && n.__reactInternalMemoizedUnmaskedChildContext === e)
        return n.__reactInternalMemoizedMaskedChildContext;
    var r = {}, i;
    for (i in t)
        r[i] = e[i];
    return n && (s = s.stateNode,
    s.__reactInternalMemoizedUnmaskedChildContext = e,
    s.__reactInternalMemoizedMaskedChildContext = r),
    r
}
function vt(s) {
    return s = s.childContextTypes,
    s != null
}
function Ja() {
    Se(xt),
    Se(it)
}
function ph(s, e, t) {
    if (it.current !== an)
        throw Error(H(168));
    ve(it, e),
    ve(xt, t)
}
function Tg(s, e, t) {
    var n = s.stateNode;
    if (e = e.childContextTypes,
    typeof n.getChildContext != "function")
        return t;
    n = n.getChildContext();
    for (var r in n)
        if (!(r in e))
            throw Error(H(108, Yy(s) || "Unknown", r));
    return Ce({}, t, n)
}
function eo(s) {
    return s = (s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext || an,
    wn = it.current,
    ve(it, s),
    ve(xt, xt.current),
    !0
}
function yh(s, e, t) {
    var n = s.stateNode;
    if (!n)
        throw Error(H(169));
    t ? (s = Tg(s, e, wn),
    n.__reactInternalMemoizedMergedChildContext = s,
    Se(xt),
    Se(it),
    ve(it, s)) : Se(xt),
    ve(xt, t)
}
var As = null
  , Oo = !1
  , yl = !1;
function Lg(s) {
    As === null ? As = [s] : As.push(s)
}
function dv(s) {
    Oo = !0,
    Lg(s)
}
function dn() {
    if (!yl && As !== null) {
        yl = !0;
        var s = 0
          , e = me;
        try {
            var t = As;
            for (me = 1; s < t.length; s++) {
                var n = t[s];
                do
                    n = n(!0);
                while (n !== null)
            }
            As = null,
            Oo = !1
        } catch (r) {
            throw As !== null && (As = As.slice(s + 1)),
            Ym(Lu, dn),
            r
        } finally {
            me = e,
            yl = !1
        }
    }
    return null
}
var Qn = []
  , Jn = 0
  , to = null
  , so = 0
  , Nt = []
  , Ot = 0
  , Cn = null
  , bs = 1
  , Rs = "";
function vn(s, e) {
    Qn[Jn++] = so,
    Qn[Jn++] = to,
    to = s,
    so = e
}
function Ig(s, e, t) {
    Nt[Ot++] = bs,
    Nt[Ot++] = Rs,
    Nt[Ot++] = Cn,
    Cn = s;
    var n = bs;
    s = Rs;
    var r = 32 - Qt(n) - 1;
    n &= ~(1 << r),
    t += 1;
    var i = 32 - Qt(e) + r;
    if (30 < i) {
        var a = r - r % 5;
        i = (n & (1 << a) - 1).toString(32),
        n >>= a,
        r -= a,
        bs = 1 << 32 - Qt(e) + r | t << r | n,
        Rs = i + s
    } else
        bs = 1 << i | t << r | n,
        Rs = s
}
function Du(s) {
    s.return !== null && (vn(s, 1),
    Ig(s, 1, 0))
}
function Pu(s) {
    for (; s === to; )
        to = Qn[--Jn],
        Qn[Jn] = null,
        so = Qn[--Jn],
        Qn[Jn] = null;
    for (; s === Cn; )
        Cn = Nt[--Ot],
        Nt[Ot] = null,
        Rs = Nt[--Ot],
        Nt[Ot] = null,
        bs = Nt[--Ot],
        Nt[Ot] = null
}
var Rt = null
  , bt = null
  , Ie = !1
  , qt = null;
function Ag(s, e) {
    var t = Mt(5, null, null, 0);
    t.elementType = "DELETED",
    t.stateNode = e,
    t.return = s,
    e = s.deletions,
    e === null ? (s.deletions = [t],
    s.flags |= 16) : e.push(t)
}
function xh(s, e) {
    switch (s.tag) {
    case 5:
        var t = s.type;
        return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (s.stateNode = e,
        Rt = s,
        bt = Qs(e.firstChild),
        !0) : !1;
    case 6:
        return e = s.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (s.stateNode = e,
        Rt = s,
        bt = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (t = Cn !== null ? {
            id: bs,
            overflow: Rs
        } : null,
        s.memoizedState = {
            dehydrated: e,
            treeContext: t,
            retryLane: 1073741824
        },
        t = Mt(18, null, null, 0),
        t.stateNode = e,
        t.return = s,
        s.child = t,
        Rt = s,
        bt = null,
        !0) : !1;
    default:
        return !1
    }
}
function Ac(s) {
    return (s.mode & 1) !== 0 && (s.flags & 128) === 0
}
function bc(s) {
    if (Ie) {
        var e = bt;
        if (e) {
            var t = e;
            if (!xh(s, e)) {
                if (Ac(s))
                    throw Error(H(418));
                e = Qs(t.nextSibling);
                var n = Rt;
                e && xh(s, e) ? Ag(n, t) : (s.flags = s.flags & -4097 | 2,
                Ie = !1,
                Rt = s)
            }
        } else {
            if (Ac(s))
                throw Error(H(418));
            s.flags = s.flags & -4097 | 2,
            Ie = !1,
            Rt = s
        }
    }
}
function vh(s) {
    for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13; )
        s = s.return;
    Rt = s
}
function Ji(s) {
    if (s !== Rt)
        return !1;
    if (!Ie)
        return vh(s),
        Ie = !0,
        !1;
    var e;
    if ((e = s.tag !== 3) && !(e = s.tag !== 5) && (e = s.type,
    e = e !== "head" && e !== "body" && !Sc(s.type, s.memoizedProps)),
    e && (e = bt)) {
        if (Ac(s))
            throw bg(),
            Error(H(418));
        for (; e; )
            Ag(s, e),
            e = Qs(e.nextSibling)
    }
    if (vh(s),
    s.tag === 13) {
        if (s = s.memoizedState,
        s = s !== null ? s.dehydrated : null,
        !s)
            throw Error(H(317));
        e: {
            for (s = s.nextSibling,
            e = 0; s; ) {
                if (s.nodeType === 8) {
                    var t = s.data;
                    if (t === "/$") {
                        if (e === 0) {
                            bt = Qs(s.nextSibling);
                            break e
                        }
                        e--
                    } else
                        t !== "$" && t !== "$!" && t !== "$?" || e++
                }
                s = s.nextSibling
            }
            bt = null
        }
    } else
        bt = Rt ? Qs(s.stateNode.nextSibling) : null;
    return !0
}
function bg() {
    for (var s = bt; s; )
        s = Qs(s.nextSibling)
}
function xr() {
    bt = Rt = null,
    Ie = !1
}
function Nu(s) {
    qt === null ? qt = [s] : qt.push(s)
}
var hv = Ms.ReactCurrentBatchConfig;
function Ur(s, e, t) {
    if (s = t.ref,
    s !== null && typeof s != "function" && typeof s != "object") {
        if (t._owner) {
            if (t = t._owner,
            t) {
                if (t.tag !== 1)
                    throw Error(H(309));
                var n = t.stateNode
            }
            if (!n)
                throw Error(H(147, s));
            var r = n
              , i = "" + s;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === i ? e.ref : (e = function(a) {
                var o = r.refs;
                a === null ? delete o[i] : o[i] = a
            }
            ,
            e._stringRef = i,
            e)
        }
        if (typeof s != "string")
            throw Error(H(284));
        if (!t._owner)
            throw Error(H(290, s))
    }
    return s
}
function ea(s, e) {
    throw s = Object.prototype.toString.call(e),
    Error(H(31, s === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : s))
}
function Eh(s) {
    var e = s._init;
    return e(s._payload)
}
function Rg(s) {
    function e(y, v) {
        if (s) {
            var E = y.deletions;
            E === null ? (y.deletions = [v],
            y.flags |= 16) : E.push(v)
        }
    }
    function t(y, v) {
        if (!s)
            return null;
        for (; v !== null; )
            e(y, v),
            v = v.sibling;
        return null
    }
    function n(y, v) {
        for (y = new Map; v !== null; )
            v.key !== null ? y.set(v.key, v) : y.set(v.index, v),
            v = v.sibling;
        return y
    }
    function r(y, v) {
        return y = sn(y, v),
        y.index = 0,
        y.sibling = null,
        y
    }
    function i(y, v, E) {
        return y.index = E,
        s ? (E = y.alternate,
        E !== null ? (E = E.index,
        E < v ? (y.flags |= 2,
        v) : E) : (y.flags |= 2,
        v)) : (y.flags |= 1048576,
        v)
    }
    function a(y) {
        return s && y.alternate === null && (y.flags |= 2),
        y
    }
    function o(y, v, E, T) {
        return v === null || v.tag !== 6 ? (v = Il(E, y.mode, T),
        v.return = y,
        v) : (v = r(v, E),
        v.return = y,
        v)
    }
    function l(y, v, E, T) {
        var L = E.type;
        return L === Wn ? u(y, v, E.props.children, T, E.key) : v !== null && (v.elementType === L || typeof L == "object" && L !== null && L.$$typeof === js && Eh(L) === v.type) ? (T = r(v, E.props),
        T.ref = Ur(y, v, E),
        T.return = y,
        T) : (T = Pa(E.type, E.key, E.props, null, y.mode, T),
        T.ref = Ur(y, v, E),
        T.return = y,
        T)
    }
    function c(y, v, E, T) {
        return v === null || v.tag !== 4 || v.stateNode.containerInfo !== E.containerInfo || v.stateNode.implementation !== E.implementation ? (v = Al(E, y.mode, T),
        v.return = y,
        v) : (v = r(v, E.children || []),
        v.return = y,
        v)
    }
    function u(y, v, E, T, L) {
        return v === null || v.tag !== 7 ? (v = bn(E, y.mode, T, L),
        v.return = y,
        v) : (v = r(v, E),
        v.return = y,
        v)
    }
    function d(y, v, E) {
        if (typeof v == "string" && v !== "" || typeof v == "number")
            return v = Il("" + v, y.mode, E),
            v.return = y,
            v;
        if (typeof v == "object" && v !== null) {
            switch (v.$$typeof) {
            case Vi:
                return E = Pa(v.type, v.key, v.props, null, y.mode, E),
                E.ref = Ur(y, null, v),
                E.return = y,
                E;
            case Kn:
                return v = Al(v, y.mode, E),
                v.return = y,
                v;
            case js:
                var T = v._init;
                return d(y, T(v._payload), E)
            }
            if (Hr(v) || Pr(v))
                return v = bn(v, y.mode, E, null),
                v.return = y,
                v;
            ea(y, v)
        }
        return null
    }
    function h(y, v, E, T) {
        var L = v !== null ? v.key : null;
        if (typeof E == "string" && E !== "" || typeof E == "number")
            return L !== null ? null : o(y, v, "" + E, T);
        if (typeof E == "object" && E !== null) {
            switch (E.$$typeof) {
            case Vi:
                return E.key === L ? l(y, v, E, T) : null;
            case Kn:
                return E.key === L ? c(y, v, E, T) : null;
            case js:
                return L = E._init,
                h(y, v, L(E._payload), T)
            }
            if (Hr(E) || Pr(E))
                return L !== null ? null : u(y, v, E, T, null);
            ea(y, E)
        }
        return null
    }
    function f(y, v, E, T, L) {
        if (typeof T == "string" && T !== "" || typeof T == "number")
            return y = y.get(E) || null,
            o(v, y, "" + T, L);
        if (typeof T == "object" && T !== null) {
            switch (T.$$typeof) {
            case Vi:
                return y = y.get(T.key === null ? E : T.key) || null,
                l(v, y, T, L);
            case Kn:
                return y = y.get(T.key === null ? E : T.key) || null,
                c(v, y, T, L);
            case js:
                var R = T._init;
                return f(y, v, E, R(T._payload), L)
            }
            if (Hr(T) || Pr(T))
                return y = y.get(E) || null,
                u(v, y, T, L, null);
            ea(v, T)
        }
        return null
    }
    function m(y, v, E, T) {
        for (var L = null, R = null, I = v, A = v = 0, C = null; I !== null && A < E.length; A++) {
            I.index > A ? (C = I,
            I = null) : C = I.sibling;
            var b = h(y, I, E[A], T);
            if (b === null) {
                I === null && (I = C);
                break
            }
            s && I && b.alternate === null && e(y, I),
            v = i(b, v, A),
            R === null ? L = b : R.sibling = b,
            R = b,
            I = C
        }
        if (A === E.length)
            return t(y, I),
            Ie && vn(y, A),
            L;
        if (I === null) {
            for (; A < E.length; A++)
                I = d(y, E[A], T),
                I !== null && (v = i(I, v, A),
                R === null ? L = I : R.sibling = I,
                R = I);
            return Ie && vn(y, A),
            L
        }
        for (I = n(y, I); A < E.length; A++)
            C = f(I, y, A, E[A], T),
            C !== null && (s && C.alternate !== null && I.delete(C.key === null ? A : C.key),
            v = i(C, v, A),
            R === null ? L = C : R.sibling = C,
            R = C);
        return s && I.forEach(function(O) {
            return e(y, O)
        }),
        Ie && vn(y, A),
        L
    }
    function p(y, v, E, T) {
        var L = Pr(E);
        if (typeof L != "function")
            throw Error(H(150));
        if (E = L.call(E),
        E == null)
            throw Error(H(151));
        for (var R = L = null, I = v, A = v = 0, C = null, b = E.next(); I !== null && !b.done; A++,
        b = E.next()) {
            I.index > A ? (C = I,
            I = null) : C = I.sibling;
            var O = h(y, I, b.value, T);
            if (O === null) {
                I === null && (I = C);
                break
            }
            s && I && O.alternate === null && e(y, I),
            v = i(O, v, A),
            R === null ? L = O : R.sibling = O,
            R = O,
            I = C
        }
        if (b.done)
            return t(y, I),
            Ie && vn(y, A),
            L;
        if (I === null) {
            for (; !b.done; A++,
            b = E.next())
                b = d(y, b.value, T),
                b !== null && (v = i(b, v, A),
                R === null ? L = b : R.sibling = b,
                R = b);
            return Ie && vn(y, A),
            L
        }
        for (I = n(y, I); !b.done; A++,
        b = E.next())
            b = f(I, y, A, b.value, T),
            b !== null && (s && b.alternate !== null && I.delete(b.key === null ? A : b.key),
            v = i(b, v, A),
            R === null ? L = b : R.sibling = b,
            R = b);
        return s && I.forEach(function(_) {
            return e(y, _)
        }),
        Ie && vn(y, A),
        L
    }
    function x(y, v, E, T) {
        if (typeof E == "object" && E !== null && E.type === Wn && E.key === null && (E = E.props.children),
        typeof E == "object" && E !== null) {
            switch (E.$$typeof) {
            case Vi:
                e: {
                    for (var L = E.key, R = v; R !== null; ) {
                        if (R.key === L) {
                            if (L = E.type,
                            L === Wn) {
                                if (R.tag === 7) {
                                    t(y, R.sibling),
                                    v = r(R, E.props.children),
                                    v.return = y,
                                    y = v;
                                    break e
                                }
                            } else if (R.elementType === L || typeof L == "object" && L !== null && L.$$typeof === js && Eh(L) === R.type) {
                                t(y, R.sibling),
                                v = r(R, E.props),
                                v.ref = Ur(y, R, E),
                                v.return = y,
                                y = v;
                                break e
                            }
                            t(y, R);
                            break
                        } else
                            e(y, R);
                        R = R.sibling
                    }
                    E.type === Wn ? (v = bn(E.props.children, y.mode, T, E.key),
                    v.return = y,
                    y = v) : (T = Pa(E.type, E.key, E.props, null, y.mode, T),
                    T.ref = Ur(y, v, E),
                    T.return = y,
                    y = T)
                }
                return a(y);
            case Kn:
                e: {
                    for (R = E.key; v !== null; ) {
                        if (v.key === R)
                            if (v.tag === 4 && v.stateNode.containerInfo === E.containerInfo && v.stateNode.implementation === E.implementation) {
                                t(y, v.sibling),
                                v = r(v, E.children || []),
                                v.return = y,
                                y = v;
                                break e
                            } else {
                                t(y, v);
                                break
                            }
                        else
                            e(y, v);
                        v = v.sibling
                    }
                    v = Al(E, y.mode, T),
                    v.return = y,
                    y = v
                }
                return a(y);
            case js:
                return R = E._init,
                x(y, v, R(E._payload), T)
            }
            if (Hr(E))
                return m(y, v, E, T);
            if (Pr(E))
                return p(y, v, E, T);
            ea(y, E)
        }
        return typeof E == "string" && E !== "" || typeof E == "number" ? (E = "" + E,
        v !== null && v.tag === 6 ? (t(y, v.sibling),
        v = r(v, E),
        v.return = y,
        y = v) : (t(y, v),
        v = Il(E, y.mode, T),
        v.return = y,
        y = v),
        a(y)) : t(y, v)
    }
    return x
}
var vr = Rg(!0)
  , wg = Rg(!1)
  , no = un(null)
  , ro = null
  , er = null
  , Ou = null;
function Mu() {
    Ou = er = ro = null
}
function Fu(s) {
    var e = no.current;
    Se(no),
    s._currentValue = e
}
function Rc(s, e, t) {
    for (; s !== null; ) {
        var n = s.alternate;
        if ((s.childLanes & e) !== e ? (s.childLanes |= e,
        n !== null && (n.childLanes |= e)) : n !== null && (n.childLanes & e) !== e && (n.childLanes |= e),
        s === t)
            break;
        s = s.return
    }
}
function lr(s, e) {
    ro = s,
    Ou = er = null,
    s = s.dependencies,
    s !== null && s.firstContext !== null && (s.lanes & e && (pt = !0),
    s.firstContext = null)
}
function Bt(s) {
    var e = s._currentValue;
    if (Ou !== s)
        if (s = {
            context: s,
            memoizedValue: e,
            next: null
        },
        er === null) {
            if (ro === null)
                throw Error(H(308));
            er = s,
            ro.dependencies = {
                lanes: 0,
                firstContext: s
            }
        } else
            er = er.next = s;
    return e
}
var Ln = null;
function Uu(s) {
    Ln === null ? Ln = [s] : Ln.push(s)
}
function Cg(s, e, t, n) {
    var r = e.interleaved;
    return r === null ? (t.next = t,
    Uu(e)) : (t.next = r.next,
    r.next = t),
    e.interleaved = t,
    Ps(s, n)
}
function Ps(s, e) {
    s.lanes |= e;
    var t = s.alternate;
    for (t !== null && (t.lanes |= e),
    t = s,
    s = s.return; s !== null; )
        s.childLanes |= e,
        t = s.alternate,
        t !== null && (t.childLanes |= e),
        t = s,
        s = s.return;
    return t.tag === 3 ? t.stateNode : null
}
var Gs = !1;
function Bu(s) {
    s.updateQueue = {
        baseState: s.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function kg(s, e) {
    s = s.updateQueue,
    e.updateQueue === s && (e.updateQueue = {
        baseState: s.baseState,
        firstBaseUpdate: s.firstBaseUpdate,
        lastBaseUpdate: s.lastBaseUpdate,
        shared: s.shared,
        effects: s.effects
    })
}
function Cs(s, e) {
    return {
        eventTime: s,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function Js(s, e, t) {
    var n = s.updateQueue;
    if (n === null)
        return null;
    if (n = n.shared,
    de & 2) {
        var r = n.pending;
        return r === null ? e.next = e : (e.next = r.next,
        r.next = e),
        n.pending = e,
        Ps(s, t)
    }
    return r = n.interleaved,
    r === null ? (e.next = e,
    Uu(n)) : (e.next = r.next,
    r.next = e),
    n.interleaved = e,
    Ps(s, t)
}
function Ra(s, e, t) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (t & 4194240) !== 0)) {
        var n = e.lanes;
        n &= s.pendingLanes,
        t |= n,
        e.lanes = t,
        Iu(s, t)
    }
}
function Sh(s, e) {
    var t = s.updateQueue
      , n = s.alternate;
    if (n !== null && (n = n.updateQueue,
    t === n)) {
        var r = null
          , i = null;
        if (t = t.firstBaseUpdate,
        t !== null) {
            do {
                var a = {
                    eventTime: t.eventTime,
                    lane: t.lane,
                    tag: t.tag,
                    payload: t.payload,
                    callback: t.callback,
                    next: null
                };
                i === null ? r = i = a : i = i.next = a,
                t = t.next
            } while (t !== null);
            i === null ? r = i = e : i = i.next = e
        } else
            r = i = e;
        t = {
            baseState: n.baseState,
            firstBaseUpdate: r,
            lastBaseUpdate: i,
            shared: n.shared,
            effects: n.effects
        },
        s.updateQueue = t;
        return
    }
    s = t.lastBaseUpdate,
    s === null ? t.firstBaseUpdate = e : s.next = e,
    t.lastBaseUpdate = e
}
function io(s, e, t, n) {
    var r = s.updateQueue;
    Gs = !1;
    var i = r.firstBaseUpdate
      , a = r.lastBaseUpdate
      , o = r.shared.pending;
    if (o !== null) {
        r.shared.pending = null;
        var l = o
          , c = l.next;
        l.next = null,
        a === null ? i = c : a.next = c,
        a = l;
        var u = s.alternate;
        u !== null && (u = u.updateQueue,
        o = u.lastBaseUpdate,
        o !== a && (o === null ? u.firstBaseUpdate = c : o.next = c,
        u.lastBaseUpdate = l))
    }
    if (i !== null) {
        var d = r.baseState;
        a = 0,
        u = c = l = null,
        o = i;
        do {
            var h = o.lane
              , f = o.eventTime;
            if ((n & h) === h) {
                u !== null && (u = u.next = {
                    eventTime: f,
                    lane: 0,
                    tag: o.tag,
                    payload: o.payload,
                    callback: o.callback,
                    next: null
                });
                e: {
                    var m = s
                      , p = o;
                    switch (h = e,
                    f = t,
                    p.tag) {
                    case 1:
                        if (m = p.payload,
                        typeof m == "function") {
                            d = m.call(f, d, h);
                            break e
                        }
                        d = m;
                        break e;
                    case 3:
                        m.flags = m.flags & -65537 | 128;
                    case 0:
                        if (m = p.payload,
                        h = typeof m == "function" ? m.call(f, d, h) : m,
                        h == null)
                            break e;
                        d = Ce({}, d, h);
                        break e;
                    case 2:
                        Gs = !0
                    }
                }
                o.callback !== null && o.lane !== 0 && (s.flags |= 64,
                h = r.effects,
                h === null ? r.effects = [o] : h.push(o))
            } else
                f = {
                    eventTime: f,
                    lane: h,
                    tag: o.tag,
                    payload: o.payload,
                    callback: o.callback,
                    next: null
                },
                u === null ? (c = u = f,
                l = d) : u = u.next = f,
                a |= h;
            if (o = o.next,
            o === null) {
                if (o = r.shared.pending,
                o === null)
                    break;
                h = o,
                o = h.next,
                h.next = null,
                r.lastBaseUpdate = h,
                r.shared.pending = null
            }
        } while (!0);
        if (u === null && (l = d),
        r.baseState = l,
        r.firstBaseUpdate = c,
        r.lastBaseUpdate = u,
        e = r.shared.interleaved,
        e !== null) {
            r = e;
            do
                a |= r.lane,
                r = r.next;
            while (r !== e)
        } else
            i === null && (r.shared.lanes = 0);
        _n |= a,
        s.lanes = a,
        s.memoizedState = d
    }
}
function Th(s, e, t) {
    if (s = e.effects,
    e.effects = null,
    s !== null)
        for (e = 0; e < s.length; e++) {
            var n = s[e]
              , r = n.callback;
            if (r !== null) {
                if (n.callback = null,
                n = t,
                typeof r != "function")
                    throw Error(H(191, r));
                r.call(n)
            }
        }
}
var Oi = {}
  , ds = un(Oi)
  , yi = un(Oi)
  , xi = un(Oi);
function In(s) {
    if (s === Oi)
        throw Error(H(174));
    return s
}
function $u(s, e) {
    switch (ve(xi, e),
    ve(yi, s),
    ve(ds, Oi),
    s = e.nodeType,
    s) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : oc(null, "");
        break;
    default:
        s = s === 8 ? e.parentNode : e,
        e = s.namespaceURI || null,
        s = s.tagName,
        e = oc(e, s)
    }
    Se(ds),
    ve(ds, e)
}
function Er() {
    Se(ds),
    Se(yi),
    Se(xi)
}
function _g(s) {
    In(xi.current);
    var e = In(ds.current)
      , t = oc(e, s.type);
    e !== t && (ve(yi, s),
    ve(ds, t))
}
function ju(s) {
    yi.current === s && (Se(ds),
    Se(yi))
}
var be = un(0);
function ao(s) {
    for (var e = s; e !== null; ) {
        if (e.tag === 13) {
            var t = e.memoizedState;
            if (t !== null && (t = t.dehydrated,
            t === null || t.data === "$?" || t.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === s)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === s)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var xl = [];
function Gu() {
    for (var s = 0; s < xl.length; s++)
        xl[s]._workInProgressVersionPrimary = null;
    xl.length = 0
}
var wa = Ms.ReactCurrentDispatcher
  , vl = Ms.ReactCurrentBatchConfig
  , kn = 0
  , Re = null
  , Ge = null
  , ze = null
  , oo = !1
  , Jr = !1
  , vi = 0
  , fv = 0;
function tt() {
    throw Error(H(321))
}
function Vu(s, e) {
    if (e === null)
        return !1;
    for (var t = 0; t < e.length && t < s.length; t++)
        if (!es(s[t], e[t]))
            return !1;
    return !0
}
function Hu(s, e, t, n, r, i) {
    if (kn = i,
    Re = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    wa.current = s === null || s.memoizedState === null ? yv : xv,
    s = t(n, r),
    Jr) {
        i = 0;
        do {
            if (Jr = !1,
            vi = 0,
            25 <= i)
                throw Error(H(301));
            i += 1,
            ze = Ge = null,
            e.updateQueue = null,
            wa.current = vv,
            s = t(n, r)
        } while (Jr)
    }
    if (wa.current = lo,
    e = Ge !== null && Ge.next !== null,
    kn = 0,
    ze = Ge = Re = null,
    oo = !1,
    e)
        throw Error(H(300));
    return s
}
function Ku() {
    var s = vi !== 0;
    return vi = 0,
    s
}
function rs() {
    var s = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return ze === null ? Re.memoizedState = ze = s : ze = ze.next = s,
    ze
}
function $t() {
    if (Ge === null) {
        var s = Re.alternate;
        s = s !== null ? s.memoizedState : null
    } else
        s = Ge.next;
    var e = ze === null ? Re.memoizedState : ze.next;
    if (e !== null)
        ze = e,
        Ge = s;
    else {
        if (s === null)
            throw Error(H(310));
        Ge = s,
        s = {
            memoizedState: Ge.memoizedState,
            baseState: Ge.baseState,
            baseQueue: Ge.baseQueue,
            queue: Ge.queue,
            next: null
        },
        ze === null ? Re.memoizedState = ze = s : ze = ze.next = s
    }
    return ze
}
function Ei(s, e) {
    return typeof e == "function" ? e(s) : e
}
function El(s) {
    var e = $t()
      , t = e.queue;
    if (t === null)
        throw Error(H(311));
    t.lastRenderedReducer = s;
    var n = Ge
      , r = n.baseQueue
      , i = t.pending;
    if (i !== null) {
        if (r !== null) {
            var a = r.next;
            r.next = i.next,
            i.next = a
        }
        n.baseQueue = r = i,
        t.pending = null
    }
    if (r !== null) {
        i = r.next,
        n = n.baseState;
        var o = a = null
          , l = null
          , c = i;
        do {
            var u = c.lane;
            if ((kn & u) === u)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                n = c.hasEagerState ? c.eagerState : s(n, c.action);
            else {
                var d = {
                    lane: u,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (o = l = d,
                a = n) : l = l.next = d,
                Re.lanes |= u,
                _n |= u
            }
            c = c.next
        } while (c !== null && c !== i);
        l === null ? a = n : l.next = o,
        es(n, e.memoizedState) || (pt = !0),
        e.memoizedState = n,
        e.baseState = a,
        e.baseQueue = l,
        t.lastRenderedState = n
    }
    if (s = t.interleaved,
    s !== null) {
        r = s;
        do
            i = r.lane,
            Re.lanes |= i,
            _n |= i,
            r = r.next;
        while (r !== s)
    } else
        r === null && (t.lanes = 0);
    return [e.memoizedState, t.dispatch]
}
function Sl(s) {
    var e = $t()
      , t = e.queue;
    if (t === null)
        throw Error(H(311));
    t.lastRenderedReducer = s;
    var n = t.dispatch
      , r = t.pending
      , i = e.memoizedState;
    if (r !== null) {
        t.pending = null;
        var a = r = r.next;
        do
            i = s(i, a.action),
            a = a.next;
        while (a !== r);
        es(i, e.memoizedState) || (pt = !0),
        e.memoizedState = i,
        e.baseQueue === null && (e.baseState = i),
        t.lastRenderedState = i
    }
    return [i, n]
}
function Dg() {}
function Pg(s, e) {
    var t = Re
      , n = $t()
      , r = e()
      , i = !es(n.memoizedState, r);
    if (i && (n.memoizedState = r,
    pt = !0),
    n = n.queue,
    Wu(Mg.bind(null, t, n, s), [s]),
    n.getSnapshot !== e || i || ze !== null && ze.memoizedState.tag & 1) {
        if (t.flags |= 2048,
        Si(9, Og.bind(null, t, n, r, e), void 0, null),
        Ye === null)
            throw Error(H(349));
        kn & 30 || Ng(t, e, r)
    }
    return r
}
function Ng(s, e, t) {
    s.flags |= 16384,
    s = {
        getSnapshot: e,
        value: t
    },
    e = Re.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    Re.updateQueue = e,
    e.stores = [s]) : (t = e.stores,
    t === null ? e.stores = [s] : t.push(s))
}
function Og(s, e, t, n) {
    e.value = t,
    e.getSnapshot = n,
    Fg(e) && Ug(s)
}
function Mg(s, e, t) {
    return t(function() {
        Fg(e) && Ug(s)
    })
}
function Fg(s) {
    var e = s.getSnapshot;
    s = s.value;
    try {
        var t = e();
        return !es(s, t)
    } catch {
        return !0
    }
}
function Ug(s) {
    var e = Ps(s, 1);
    e !== null && Jt(e, s, 1, -1)
}
function Lh(s) {
    var e = rs();
    return typeof s == "function" && (s = s()),
    e.memoizedState = e.baseState = s,
    s = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Ei,
        lastRenderedState: s
    },
    e.queue = s,
    s = s.dispatch = pv.bind(null, Re, s),
    [e.memoizedState, s]
}
function Si(s, e, t, n) {
    return s = {
        tag: s,
        create: e,
        destroy: t,
        deps: n,
        next: null
    },
    e = Re.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    Re.updateQueue = e,
    e.lastEffect = s.next = s) : (t = e.lastEffect,
    t === null ? e.lastEffect = s.next = s : (n = t.next,
    t.next = s,
    s.next = n,
    e.lastEffect = s)),
    s
}
function Bg() {
    return $t().memoizedState
}
function Ca(s, e, t, n) {
    var r = rs();
    Re.flags |= s,
    r.memoizedState = Si(1 | e, t, void 0, n === void 0 ? null : n)
}
function Mo(s, e, t, n) {
    var r = $t();
    n = n === void 0 ? null : n;
    var i = void 0;
    if (Ge !== null) {
        var a = Ge.memoizedState;
        if (i = a.destroy,
        n !== null && Vu(n, a.deps)) {
            r.memoizedState = Si(e, t, i, n);
            return
        }
    }
    Re.flags |= s,
    r.memoizedState = Si(1 | e, t, i, n)
}
function Ih(s, e) {
    return Ca(8390656, 8, s, e)
}
function Wu(s, e) {
    return Mo(2048, 8, s, e)
}
function $g(s, e) {
    return Mo(4, 2, s, e)
}
function jg(s, e) {
    return Mo(4, 4, s, e)
}
function Gg(s, e) {
    if (typeof e == "function")
        return s = s(),
        e(s),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return s = s(),
        e.current = s,
        function() {
            e.current = null
        }
}
function Vg(s, e, t) {
    return t = t != null ? t.concat([s]) : null,
    Mo(4, 4, Gg.bind(null, e, s), t)
}
function zu() {}
function Hg(s, e) {
    var t = $t();
    e = e === void 0 ? null : e;
    var n = t.memoizedState;
    return n !== null && e !== null && Vu(e, n[1]) ? n[0] : (t.memoizedState = [s, e],
    s)
}
function Kg(s, e) {
    var t = $t();
    e = e === void 0 ? null : e;
    var n = t.memoizedState;
    return n !== null && e !== null && Vu(e, n[1]) ? n[0] : (s = s(),
    t.memoizedState = [s, e],
    s)
}
function Wg(s, e, t) {
    return kn & 21 ? (es(t, e) || (t = qm(),
    Re.lanes |= t,
    _n |= t,
    s.baseState = !0),
    e) : (s.baseState && (s.baseState = !1,
    pt = !0),
    s.memoizedState = t)
}
function mv(s, e) {
    var t = me;
    me = t !== 0 && 4 > t ? t : 4,
    s(!0);
    var n = vl.transition;
    vl.transition = {};
    try {
        s(!1),
        e()
    } finally {
        me = t,
        vl.transition = n
    }
}
function zg() {
    return $t().memoizedState
}
function gv(s, e, t) {
    var n = tn(s);
    if (t = {
        lane: n,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    Yg(s))
        Xg(e, t);
    else if (t = Cg(s, e, t, n),
    t !== null) {
        var r = ct();
        Jt(t, s, n, r),
        Zg(t, e, n)
    }
}
function pv(s, e, t) {
    var n = tn(s)
      , r = {
        lane: n,
        action: t,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (Yg(s))
        Xg(e, r);
    else {
        var i = s.alternate;
        if (s.lanes === 0 && (i === null || i.lanes === 0) && (i = e.lastRenderedReducer,
        i !== null))
            try {
                var a = e.lastRenderedState
                  , o = i(a, t);
                if (r.hasEagerState = !0,
                r.eagerState = o,
                es(o, a)) {
                    var l = e.interleaved;
                    l === null ? (r.next = r,
                    Uu(e)) : (r.next = l.next,
                    l.next = r),
                    e.interleaved = r;
                    return
                }
            } catch {} finally {}
        t = Cg(s, e, r, n),
        t !== null && (r = ct(),
        Jt(t, s, n, r),
        Zg(t, e, n))
    }
}
function Yg(s) {
    var e = s.alternate;
    return s === Re || e !== null && e === Re
}
function Xg(s, e) {
    Jr = oo = !0;
    var t = s.pending;
    t === null ? e.next = e : (e.next = t.next,
    t.next = e),
    s.pending = e
}
function Zg(s, e, t) {
    if (t & 4194240) {
        var n = e.lanes;
        n &= s.pendingLanes,
        t |= n,
        e.lanes = t,
        Iu(s, t)
    }
}
var lo = {
    readContext: Bt,
    useCallback: tt,
    useContext: tt,
    useEffect: tt,
    useImperativeHandle: tt,
    useInsertionEffect: tt,
    useLayoutEffect: tt,
    useMemo: tt,
    useReducer: tt,
    useRef: tt,
    useState: tt,
    useDebugValue: tt,
    useDeferredValue: tt,
    useTransition: tt,
    useMutableSource: tt,
    useSyncExternalStore: tt,
    useId: tt,
    unstable_isNewReconciler: !1
}
  , yv = {
    readContext: Bt,
    useCallback: function(s, e) {
        return rs().memoizedState = [s, e === void 0 ? null : e],
        s
    },
    useContext: Bt,
    useEffect: Ih,
    useImperativeHandle: function(s, e, t) {
        return t = t != null ? t.concat([s]) : null,
        Ca(4194308, 4, Gg.bind(null, e, s), t)
    },
    useLayoutEffect: function(s, e) {
        return Ca(4194308, 4, s, e)
    },
    useInsertionEffect: function(s, e) {
        return Ca(4, 2, s, e)
    },
    useMemo: function(s, e) {
        var t = rs();
        return e = e === void 0 ? null : e,
        s = s(),
        t.memoizedState = [s, e],
        s
    },
    useReducer: function(s, e, t) {
        var n = rs();
        return e = t !== void 0 ? t(e) : e,
        n.memoizedState = n.baseState = e,
        s = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: s,
            lastRenderedState: e
        },
        n.queue = s,
        s = s.dispatch = gv.bind(null, Re, s),
        [n.memoizedState, s]
    },
    useRef: function(s) {
        var e = rs();
        return s = {
            current: s
        },
        e.memoizedState = s
    },
    useState: Lh,
    useDebugValue: zu,
    useDeferredValue: function(s) {
        return rs().memoizedState = s
    },
    useTransition: function() {
        var s = Lh(!1)
          , e = s[0];
        return s = mv.bind(null, s[1]),
        rs().memoizedState = s,
        [e, s]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(s, e, t) {
        var n = Re
          , r = rs();
        if (Ie) {
            if (t === void 0)
                throw Error(H(407));
            t = t()
        } else {
            if (t = e(),
            Ye === null)
                throw Error(H(349));
            kn & 30 || Ng(n, e, t)
        }
        r.memoizedState = t;
        var i = {
            value: t,
            getSnapshot: e
        };
        return r.queue = i,
        Ih(Mg.bind(null, n, i, s), [s]),
        n.flags |= 2048,
        Si(9, Og.bind(null, n, i, t, e), void 0, null),
        t
    },
    useId: function() {
        var s = rs()
          , e = Ye.identifierPrefix;
        if (Ie) {
            var t = Rs
              , n = bs;
            t = (n & ~(1 << 32 - Qt(n) - 1)).toString(32) + t,
            e = ":" + e + "R" + t,
            t = vi++,
            0 < t && (e += "H" + t.toString(32)),
            e += ":"
        } else
            t = fv++,
            e = ":" + e + "r" + t.toString(32) + ":";
        return s.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , xv = {
    readContext: Bt,
    useCallback: Hg,
    useContext: Bt,
    useEffect: Wu,
    useImperativeHandle: Vg,
    useInsertionEffect: $g,
    useLayoutEffect: jg,
    useMemo: Kg,
    useReducer: El,
    useRef: Bg,
    useState: function() {
        return El(Ei)
    },
    useDebugValue: zu,
    useDeferredValue: function(s) {
        var e = $t();
        return Wg(e, Ge.memoizedState, s)
    },
    useTransition: function() {
        var s = El(Ei)[0]
          , e = $t().memoizedState;
        return [s, e]
    },
    useMutableSource: Dg,
    useSyncExternalStore: Pg,
    useId: zg,
    unstable_isNewReconciler: !1
}
  , vv = {
    readContext: Bt,
    useCallback: Hg,
    useContext: Bt,
    useEffect: Wu,
    useImperativeHandle: Vg,
    useInsertionEffect: $g,
    useLayoutEffect: jg,
    useMemo: Kg,
    useReducer: Sl,
    useRef: Bg,
    useState: function() {
        return Sl(Ei)
    },
    useDebugValue: zu,
    useDeferredValue: function(s) {
        var e = $t();
        return Ge === null ? e.memoizedState = s : Wg(e, Ge.memoizedState, s)
    },
    useTransition: function() {
        var s = Sl(Ei)[0]
          , e = $t().memoizedState;
        return [s, e]
    },
    useMutableSource: Dg,
    useSyncExternalStore: Pg,
    useId: zg,
    unstable_isNewReconciler: !1
};
function Xt(s, e) {
    if (s && s.defaultProps) {
        e = Ce({}, e),
        s = s.defaultProps;
        for (var t in s)
            e[t] === void 0 && (e[t] = s[t]);
        return e
    }
    return e
}
function wc(s, e, t, n) {
    e = s.memoizedState,
    t = t(n, e),
    t = t == null ? e : Ce({}, e, t),
    s.memoizedState = t,
    s.lanes === 0 && (s.updateQueue.baseState = t)
}
var Fo = {
    isMounted: function(s) {
        return (s = s._reactInternals) ? On(s) === s : !1
    },
    enqueueSetState: function(s, e, t) {
        s = s._reactInternals;
        var n = ct()
          , r = tn(s)
          , i = Cs(n, r);
        i.payload = e,
        t != null && (i.callback = t),
        e = Js(s, i, r),
        e !== null && (Jt(e, s, r, n),
        Ra(e, s, r))
    },
    enqueueReplaceState: function(s, e, t) {
        s = s._reactInternals;
        var n = ct()
          , r = tn(s)
          , i = Cs(n, r);
        i.tag = 1,
        i.payload = e,
        t != null && (i.callback = t),
        e = Js(s, i, r),
        e !== null && (Jt(e, s, r, n),
        Ra(e, s, r))
    },
    enqueueForceUpdate: function(s, e) {
        s = s._reactInternals;
        var t = ct()
          , n = tn(s)
          , r = Cs(t, n);
        r.tag = 2,
        e != null && (r.callback = e),
        e = Js(s, r, n),
        e !== null && (Jt(e, s, n, t),
        Ra(e, s, n))
    }
};
function Ah(s, e, t, n, r, i, a) {
    return s = s.stateNode,
    typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(n, i, a) : e.prototype && e.prototype.isPureReactComponent ? !fi(t, n) || !fi(r, i) : !0
}
function qg(s, e, t) {
    var n = !1
      , r = an
      , i = e.contextType;
    return typeof i == "object" && i !== null ? i = Bt(i) : (r = vt(e) ? wn : it.current,
    n = e.contextTypes,
    i = (n = n != null) ? yr(s, r) : an),
    e = new e(t,i),
    s.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = Fo,
    s.stateNode = e,
    e._reactInternals = s,
    n && (s = s.stateNode,
    s.__reactInternalMemoizedUnmaskedChildContext = r,
    s.__reactInternalMemoizedMaskedChildContext = i),
    e
}
function bh(s, e, t, n) {
    s = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, n),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, n),
    e.state !== s && Fo.enqueueReplaceState(e, e.state, null)
}
function Cc(s, e, t, n) {
    var r = s.stateNode;
    r.props = t,
    r.state = s.memoizedState,
    r.refs = {},
    Bu(s);
    var i = e.contextType;
    typeof i == "object" && i !== null ? r.context = Bt(i) : (i = vt(e) ? wn : it.current,
    r.context = yr(s, i)),
    r.state = s.memoizedState,
    i = e.getDerivedStateFromProps,
    typeof i == "function" && (wc(s, e, i, t),
    r.state = s.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state,
    typeof r.componentWillMount == "function" && r.componentWillMount(),
    typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(),
    e !== r.state && Fo.enqueueReplaceState(r, r.state, null),
    io(s, t, r, n),
    r.state = s.memoizedState),
    typeof r.componentDidMount == "function" && (s.flags |= 4194308)
}
function Sr(s, e) {
    try {
        var t = ""
          , n = e;
        do
            t += zy(n),
            n = n.return;
        while (n);
        var r = t
    } catch (i) {
        r = `
Error generating stack: ` + i.message + `
` + i.stack
    }
    return {
        value: s,
        source: e,
        stack: r,
        digest: null
    }
}
function Tl(s, e, t) {
    return {
        value: s,
        source: null,
        stack: t ?? null,
        digest: e ?? null
    }
}
function kc(s, e) {
    try {
        console.error(e.value)
    } catch (t) {
        setTimeout(function() {
            throw t
        })
    }
}
var Ev = typeof WeakMap == "function" ? WeakMap : Map;
function Qg(s, e, t) {
    t = Cs(-1, t),
    t.tag = 3,
    t.payload = {
        element: null
    };
    var n = e.value;
    return t.callback = function() {
        uo || (uo = !0,
        $c = n),
        kc(s, e)
    }
    ,
    t
}
function Jg(s, e, t) {
    t = Cs(-1, t),
    t.tag = 3;
    var n = s.type.getDerivedStateFromError;
    if (typeof n == "function") {
        var r = e.value;
        t.payload = function() {
            return n(r)
        }
        ,
        t.callback = function() {
            kc(s, e)
        }
    }
    var i = s.stateNode;
    return i !== null && typeof i.componentDidCatch == "function" && (t.callback = function() {
        kc(s, e),
        typeof n != "function" && (en === null ? en = new Set([this]) : en.add(this));
        var a = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: a !== null ? a : ""
        })
    }
    ),
    t
}
function Rh(s, e, t) {
    var n = s.pingCache;
    if (n === null) {
        n = s.pingCache = new Ev;
        var r = new Set;
        n.set(e, r)
    } else
        r = n.get(e),
        r === void 0 && (r = new Set,
        n.set(e, r));
    r.has(t) || (r.add(t),
    s = Nv.bind(null, s, e, t),
    e.then(s, s))
}
function wh(s) {
    do {
        var e;
        if ((e = s.tag === 13) && (e = s.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return s;
        s = s.return
    } while (s !== null);
    return null
}
function Ch(s, e, t, n, r) {
    return s.mode & 1 ? (s.flags |= 65536,
    s.lanes = r,
    s) : (s === e ? s.flags |= 65536 : (s.flags |= 128,
    t.flags |= 131072,
    t.flags &= -52805,
    t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = Cs(-1, 1),
    e.tag = 2,
    Js(t, e, 1))),
    t.lanes |= 1),
    s)
}
var Sv = Ms.ReactCurrentOwner
  , pt = !1;
function at(s, e, t, n) {
    e.child = s === null ? wg(e, null, t, n) : vr(e, s.child, t, n)
}
function kh(s, e, t, n, r) {
    t = t.render;
    var i = e.ref;
    return lr(e, r),
    n = Hu(s, e, t, n, i, r),
    t = Ku(),
    s !== null && !pt ? (e.updateQueue = s.updateQueue,
    e.flags &= -2053,
    s.lanes &= ~r,
    Ns(s, e, r)) : (Ie && t && Du(e),
    e.flags |= 1,
    at(s, e, n, r),
    e.child)
}
function _h(s, e, t, n, r) {
    if (s === null) {
        var i = t.type;
        return typeof i == "function" && !td(i) && i.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15,
        e.type = i,
        ep(s, e, i, n, r)) : (s = Pa(t.type, null, n, e, e.mode, r),
        s.ref = e.ref,
        s.return = e,
        e.child = s)
    }
    if (i = s.child,
    !(s.lanes & r)) {
        var a = i.memoizedProps;
        if (t = t.compare,
        t = t !== null ? t : fi,
        t(a, n) && s.ref === e.ref)
            return Ns(s, e, r)
    }
    return e.flags |= 1,
    s = sn(i, n),
    s.ref = e.ref,
    s.return = e,
    e.child = s
}
function ep(s, e, t, n, r) {
    if (s !== null) {
        var i = s.memoizedProps;
        if (fi(i, n) && s.ref === e.ref)
            if (pt = !1,
            e.pendingProps = n = i,
            (s.lanes & r) !== 0)
                s.flags & 131072 && (pt = !0);
            else
                return e.lanes = s.lanes,
                Ns(s, e, r)
    }
    return _c(s, e, t, n, r)
}
function tp(s, e, t) {
    var n = e.pendingProps
      , r = n.children
      , i = s !== null ? s.memoizedState : null;
    if (n.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            ve(sr, Lt),
            Lt |= t;
        else {
            if (!(t & 1073741824))
                return s = i !== null ? i.baseLanes | t : t,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: s,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                ve(sr, Lt),
                Lt |= s,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            n = i !== null ? i.baseLanes : t,
            ve(sr, Lt),
            Lt |= n
        }
    else
        i !== null ? (n = i.baseLanes | t,
        e.memoizedState = null) : n = t,
        ve(sr, Lt),
        Lt |= n;
    return at(s, e, r, t),
    e.child
}
function sp(s, e) {
    var t = e.ref;
    (s === null && t !== null || s !== null && s.ref !== t) && (e.flags |= 512,
    e.flags |= 2097152)
}
function _c(s, e, t, n, r) {
    var i = vt(t) ? wn : it.current;
    return i = yr(e, i),
    lr(e, r),
    t = Hu(s, e, t, n, i, r),
    n = Ku(),
    s !== null && !pt ? (e.updateQueue = s.updateQueue,
    e.flags &= -2053,
    s.lanes &= ~r,
    Ns(s, e, r)) : (Ie && n && Du(e),
    e.flags |= 1,
    at(s, e, t, r),
    e.child)
}
function Dh(s, e, t, n, r) {
    if (vt(t)) {
        var i = !0;
        eo(e)
    } else
        i = !1;
    if (lr(e, r),
    e.stateNode === null)
        ka(s, e),
        qg(e, t, n),
        Cc(e, t, n, r),
        n = !0;
    else if (s === null) {
        var a = e.stateNode
          , o = e.memoizedProps;
        a.props = o;
        var l = a.context
          , c = t.contextType;
        typeof c == "object" && c !== null ? c = Bt(c) : (c = vt(t) ? wn : it.current,
        c = yr(e, c));
        var u = t.getDerivedStateFromProps
          , d = typeof u == "function" || typeof a.getSnapshotBeforeUpdate == "function";
        d || typeof a.UNSAFE_componentWillReceiveProps != "function" && typeof a.componentWillReceiveProps != "function" || (o !== n || l !== c) && bh(e, a, n, c),
        Gs = !1;
        var h = e.memoizedState;
        a.state = h,
        io(e, n, a, r),
        l = e.memoizedState,
        o !== n || h !== l || xt.current || Gs ? (typeof u == "function" && (wc(e, t, u, n),
        l = e.memoizedState),
        (o = Gs || Ah(e, t, o, n, h, l, c)) ? (d || typeof a.UNSAFE_componentWillMount != "function" && typeof a.componentWillMount != "function" || (typeof a.componentWillMount == "function" && a.componentWillMount(),
        typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount()),
        typeof a.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof a.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = n,
        e.memoizedState = l),
        a.props = n,
        a.state = l,
        a.context = c,
        n = o) : (typeof a.componentDidMount == "function" && (e.flags |= 4194308),
        n = !1)
    } else {
        a = e.stateNode,
        kg(s, e),
        o = e.memoizedProps,
        c = e.type === e.elementType ? o : Xt(e.type, o),
        a.props = c,
        d = e.pendingProps,
        h = a.context,
        l = t.contextType,
        typeof l == "object" && l !== null ? l = Bt(l) : (l = vt(t) ? wn : it.current,
        l = yr(e, l));
        var f = t.getDerivedStateFromProps;
        (u = typeof f == "function" || typeof a.getSnapshotBeforeUpdate == "function") || typeof a.UNSAFE_componentWillReceiveProps != "function" && typeof a.componentWillReceiveProps != "function" || (o !== d || h !== l) && bh(e, a, n, l),
        Gs = !1,
        h = e.memoizedState,
        a.state = h,
        io(e, n, a, r);
        var m = e.memoizedState;
        o !== d || h !== m || xt.current || Gs ? (typeof f == "function" && (wc(e, t, f, n),
        m = e.memoizedState),
        (c = Gs || Ah(e, t, c, n, h, m, l) || !1) ? (u || typeof a.UNSAFE_componentWillUpdate != "function" && typeof a.componentWillUpdate != "function" || (typeof a.componentWillUpdate == "function" && a.componentWillUpdate(n, m, l),
        typeof a.UNSAFE_componentWillUpdate == "function" && a.UNSAFE_componentWillUpdate(n, m, l)),
        typeof a.componentDidUpdate == "function" && (e.flags |= 4),
        typeof a.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof a.componentDidUpdate != "function" || o === s.memoizedProps && h === s.memoizedState || (e.flags |= 4),
        typeof a.getSnapshotBeforeUpdate != "function" || o === s.memoizedProps && h === s.memoizedState || (e.flags |= 1024),
        e.memoizedProps = n,
        e.memoizedState = m),
        a.props = n,
        a.state = m,
        a.context = l,
        n = c) : (typeof a.componentDidUpdate != "function" || o === s.memoizedProps && h === s.memoizedState || (e.flags |= 4),
        typeof a.getSnapshotBeforeUpdate != "function" || o === s.memoizedProps && h === s.memoizedState || (e.flags |= 1024),
        n = !1)
    }
    return Dc(s, e, t, n, i, r)
}
function Dc(s, e, t, n, r, i) {
    sp(s, e);
    var a = (e.flags & 128) !== 0;
    if (!n && !a)
        return r && yh(e, t, !1),
        Ns(s, e, i);
    n = e.stateNode,
    Sv.current = e;
    var o = a && typeof t.getDerivedStateFromError != "function" ? null : n.render();
    return e.flags |= 1,
    s !== null && a ? (e.child = vr(e, s.child, null, i),
    e.child = vr(e, null, o, i)) : at(s, e, o, i),
    e.memoizedState = n.state,
    r && yh(e, t, !0),
    e.child
}
function np(s) {
    var e = s.stateNode;
    e.pendingContext ? ph(s, e.pendingContext, e.pendingContext !== e.context) : e.context && ph(s, e.context, !1),
    $u(s, e.containerInfo)
}
function Ph(s, e, t, n, r) {
    return xr(),
    Nu(r),
    e.flags |= 256,
    at(s, e, t, n),
    e.child
}
var Pc = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function Nc(s) {
    return {
        baseLanes: s,
        cachePool: null,
        transitions: null
    }
}
function rp(s, e, t) {
    var n = e.pendingProps, r = be.current, i = !1, a = (e.flags & 128) !== 0, o;
    if ((o = a) || (o = s !== null && s.memoizedState === null ? !1 : (r & 2) !== 0),
    o ? (i = !0,
    e.flags &= -129) : (s === null || s.memoizedState !== null) && (r |= 1),
    ve(be, r & 1),
    s === null)
        return bc(e),
        s = e.memoizedState,
        s !== null && (s = s.dehydrated,
        s !== null) ? (e.mode & 1 ? s.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (a = n.children,
        s = n.fallback,
        i ? (n = e.mode,
        i = e.child,
        a = {
            mode: "hidden",
            children: a
        },
        !(n & 1) && i !== null ? (i.childLanes = 0,
        i.pendingProps = a) : i = $o(a, n, 0, null),
        s = bn(s, n, t, null),
        i.return = e,
        s.return = e,
        i.sibling = s,
        e.child = i,
        e.child.memoizedState = Nc(t),
        e.memoizedState = Pc,
        s) : Yu(e, a));
    if (r = s.memoizedState,
    r !== null && (o = r.dehydrated,
    o !== null))
        return Tv(s, e, a, n, o, r, t);
    if (i) {
        i = n.fallback,
        a = e.mode,
        r = s.child,
        o = r.sibling;
        var l = {
            mode: "hidden",
            children: n.children
        };
        return !(a & 1) && e.child !== r ? (n = e.child,
        n.childLanes = 0,
        n.pendingProps = l,
        e.deletions = null) : (n = sn(r, l),
        n.subtreeFlags = r.subtreeFlags & 14680064),
        o !== null ? i = sn(o, i) : (i = bn(i, a, t, null),
        i.flags |= 2),
        i.return = e,
        n.return = e,
        n.sibling = i,
        e.child = n,
        n = i,
        i = e.child,
        a = s.child.memoizedState,
        a = a === null ? Nc(t) : {
            baseLanes: a.baseLanes | t,
            cachePool: null,
            transitions: a.transitions
        },
        i.memoizedState = a,
        i.childLanes = s.childLanes & ~t,
        e.memoizedState = Pc,
        n
    }
    return i = s.child,
    s = i.sibling,
    n = sn(i, {
        mode: "visible",
        children: n.children
    }),
    !(e.mode & 1) && (n.lanes = t),
    n.return = e,
    n.sibling = null,
    s !== null && (t = e.deletions,
    t === null ? (e.deletions = [s],
    e.flags |= 16) : t.push(s)),
    e.child = n,
    e.memoizedState = null,
    n
}
function Yu(s, e) {
    return e = $o({
        mode: "visible",
        children: e
    }, s.mode, 0, null),
    e.return = s,
    s.child = e
}
function ta(s, e, t, n) {
    return n !== null && Nu(n),
    vr(e, s.child, null, t),
    s = Yu(e, e.pendingProps.children),
    s.flags |= 2,
    e.memoizedState = null,
    s
}
function Tv(s, e, t, n, r, i, a) {
    if (t)
        return e.flags & 256 ? (e.flags &= -257,
        n = Tl(Error(H(422))),
        ta(s, e, a, n)) : e.memoizedState !== null ? (e.child = s.child,
        e.flags |= 128,
        null) : (i = n.fallback,
        r = e.mode,
        n = $o({
            mode: "visible",
            children: n.children
        }, r, 0, null),
        i = bn(i, r, a, null),
        i.flags |= 2,
        n.return = e,
        i.return = e,
        n.sibling = i,
        e.child = n,
        e.mode & 1 && vr(e, s.child, null, a),
        e.child.memoizedState = Nc(a),
        e.memoizedState = Pc,
        i);
    if (!(e.mode & 1))
        return ta(s, e, a, null);
    if (r.data === "$!") {
        if (n = r.nextSibling && r.nextSibling.dataset,
        n)
            var o = n.dgst;
        return n = o,
        i = Error(H(419)),
        n = Tl(i, n, void 0),
        ta(s, e, a, n)
    }
    if (o = (a & s.childLanes) !== 0,
    pt || o) {
        if (n = Ye,
        n !== null) {
            switch (a & -a) {
            case 4:
                r = 2;
                break;
            case 16:
                r = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                r = 32;
                break;
            case 536870912:
                r = 268435456;
                break;
            default:
                r = 0
            }
            r = r & (n.suspendedLanes | a) ? 0 : r,
            r !== 0 && r !== i.retryLane && (i.retryLane = r,
            Ps(s, r),
            Jt(n, s, r, -1))
        }
        return ed(),
        n = Tl(Error(H(421))),
        ta(s, e, a, n)
    }
    return r.data === "$?" ? (e.flags |= 128,
    e.child = s.child,
    e = Ov.bind(null, s),
    r._reactRetry = e,
    null) : (s = i.treeContext,
    bt = Qs(r.nextSibling),
    Rt = e,
    Ie = !0,
    qt = null,
    s !== null && (Nt[Ot++] = bs,
    Nt[Ot++] = Rs,
    Nt[Ot++] = Cn,
    bs = s.id,
    Rs = s.overflow,
    Cn = e),
    e = Yu(e, n.children),
    e.flags |= 4096,
    e)
}
function Nh(s, e, t) {
    s.lanes |= e;
    var n = s.alternate;
    n !== null && (n.lanes |= e),
    Rc(s.return, e, t)
}
function Ll(s, e, t, n, r) {
    var i = s.memoizedState;
    i === null ? s.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: n,
        tail: t,
        tailMode: r
    } : (i.isBackwards = e,
    i.rendering = null,
    i.renderingStartTime = 0,
    i.last = n,
    i.tail = t,
    i.tailMode = r)
}
function ip(s, e, t) {
    var n = e.pendingProps
      , r = n.revealOrder
      , i = n.tail;
    if (at(s, e, n.children, t),
    n = be.current,
    n & 2)
        n = n & 1 | 2,
        e.flags |= 128;
    else {
        if (s !== null && s.flags & 128)
            e: for (s = e.child; s !== null; ) {
                if (s.tag === 13)
                    s.memoizedState !== null && Nh(s, t, e);
                else if (s.tag === 19)
                    Nh(s, t, e);
                else if (s.child !== null) {
                    s.child.return = s,
                    s = s.child;
                    continue
                }
                if (s === e)
                    break e;
                for (; s.sibling === null; ) {
                    if (s.return === null || s.return === e)
                        break e;
                    s = s.return
                }
                s.sibling.return = s.return,
                s = s.sibling
            }
        n &= 1
    }
    if (ve(be, n),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (r) {
        case "forwards":
            for (t = e.child,
            r = null; t !== null; )
                s = t.alternate,
                s !== null && ao(s) === null && (r = t),
                t = t.sibling;
            t = r,
            t === null ? (r = e.child,
            e.child = null) : (r = t.sibling,
            t.sibling = null),
            Ll(e, !1, r, t, i);
            break;
        case "backwards":
            for (t = null,
            r = e.child,
            e.child = null; r !== null; ) {
                if (s = r.alternate,
                s !== null && ao(s) === null) {
                    e.child = r;
                    break
                }
                s = r.sibling,
                r.sibling = t,
                t = r,
                r = s
            }
            Ll(e, !0, t, null, i);
            break;
        case "together":
            Ll(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function ka(s, e) {
    !(e.mode & 1) && s !== null && (s.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function Ns(s, e, t) {
    if (s !== null && (e.dependencies = s.dependencies),
    _n |= e.lanes,
    !(t & e.childLanes))
        return null;
    if (s !== null && e.child !== s.child)
        throw Error(H(153));
    if (e.child !== null) {
        for (s = e.child,
        t = sn(s, s.pendingProps),
        e.child = t,
        t.return = e; s.sibling !== null; )
            s = s.sibling,
            t = t.sibling = sn(s, s.pendingProps),
            t.return = e;
        t.sibling = null
    }
    return e.child
}
function Lv(s, e, t) {
    switch (e.tag) {
    case 3:
        np(e),
        xr();
        break;
    case 5:
        _g(e);
        break;
    case 1:
        vt(e.type) && eo(e);
        break;
    case 4:
        $u(e, e.stateNode.containerInfo);
        break;
    case 10:
        var n = e.type._context
          , r = e.memoizedProps.value;
        ve(no, n._currentValue),
        n._currentValue = r;
        break;
    case 13:
        if (n = e.memoizedState,
        n !== null)
            return n.dehydrated !== null ? (ve(be, be.current & 1),
            e.flags |= 128,
            null) : t & e.child.childLanes ? rp(s, e, t) : (ve(be, be.current & 1),
            s = Ns(s, e, t),
            s !== null ? s.sibling : null);
        ve(be, be.current & 1);
        break;
    case 19:
        if (n = (t & e.childLanes) !== 0,
        s.flags & 128) {
            if (n)
                return ip(s, e, t);
            e.flags |= 128
        }
        if (r = e.memoizedState,
        r !== null && (r.rendering = null,
        r.tail = null,
        r.lastEffect = null),
        ve(be, be.current),
        n)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        tp(s, e, t)
    }
    return Ns(s, e, t)
}
var ap, Oc, op, lp;
ap = function(s, e) {
    for (var t = e.child; t !== null; ) {
        if (t.tag === 5 || t.tag === 6)
            s.appendChild(t.stateNode);
        else if (t.tag !== 4 && t.child !== null) {
            t.child.return = t,
            t = t.child;
            continue
        }
        if (t === e)
            break;
        for (; t.sibling === null; ) {
            if (t.return === null || t.return === e)
                return;
            t = t.return
        }
        t.sibling.return = t.return,
        t = t.sibling
    }
}
;
Oc = function() {}
;
op = function(s, e, t, n) {
    var r = s.memoizedProps;
    if (r !== n) {
        s = e.stateNode,
        In(ds.current);
        var i = null;
        switch (t) {
        case "input":
            r = nc(s, r),
            n = nc(s, n),
            i = [];
            break;
        case "select":
            r = Ce({}, r, {
                value: void 0
            }),
            n = Ce({}, n, {
                value: void 0
            }),
            i = [];
            break;
        case "textarea":
            r = ac(s, r),
            n = ac(s, n),
            i = [];
            break;
        default:
            typeof r.onClick != "function" && typeof n.onClick == "function" && (s.onclick = Qa)
        }
        lc(t, n);
        var a;
        t = null;
        for (c in r)
            if (!n.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null)
                if (c === "style") {
                    var o = r[c];
                    for (a in o)
                        o.hasOwnProperty(a) && (t || (t = {}),
                        t[a] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (ai.hasOwnProperty(c) ? i || (i = []) : (i = i || []).push(c, null));
        for (c in n) {
            var l = n[c];
            if (o = r != null ? r[c] : void 0,
            n.hasOwnProperty(c) && l !== o && (l != null || o != null))
                if (c === "style")
                    if (o) {
                        for (a in o)
                            !o.hasOwnProperty(a) || l && l.hasOwnProperty(a) || (t || (t = {}),
                            t[a] = "");
                        for (a in l)
                            l.hasOwnProperty(a) && o[a] !== l[a] && (t || (t = {}),
                            t[a] = l[a])
                    } else
                        t || (i || (i = []),
                        i.push(c, t)),
                        t = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    o = o ? o.__html : void 0,
                    l != null && o !== l && (i = i || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (ai.hasOwnProperty(c) ? (l != null && c === "onScroll" && Ee("scroll", s),
                    i || o === l || (i = [])) : (i = i || []).push(c, l))
        }
        t && (i = i || []).push("style", t);
        var c = i;
        (e.updateQueue = c) && (e.flags |= 4)
    }
}
;
lp = function(s, e, t, n) {
    t !== n && (e.flags |= 4)
}
;
function Br(s, e) {
    if (!Ie)
        switch (s.tailMode) {
        case "hidden":
            e = s.tail;
            for (var t = null; e !== null; )
                e.alternate !== null && (t = e),
                e = e.sibling;
            t === null ? s.tail = null : t.sibling = null;
            break;
        case "collapsed":
            t = s.tail;
            for (var n = null; t !== null; )
                t.alternate !== null && (n = t),
                t = t.sibling;
            n === null ? e || s.tail === null ? s.tail = null : s.tail.sibling = null : n.sibling = null
        }
}
function st(s) {
    var e = s.alternate !== null && s.alternate.child === s.child
      , t = 0
      , n = 0;
    if (e)
        for (var r = s.child; r !== null; )
            t |= r.lanes | r.childLanes,
            n |= r.subtreeFlags & 14680064,
            n |= r.flags & 14680064,
            r.return = s,
            r = r.sibling;
    else
        for (r = s.child; r !== null; )
            t |= r.lanes | r.childLanes,
            n |= r.subtreeFlags,
            n |= r.flags,
            r.return = s,
            r = r.sibling;
    return s.subtreeFlags |= n,
    s.childLanes = t,
    e
}
function Iv(s, e, t) {
    var n = e.pendingProps;
    switch (Pu(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return st(e),
        null;
    case 1:
        return vt(e.type) && Ja(),
        st(e),
        null;
    case 3:
        return n = e.stateNode,
        Er(),
        Se(xt),
        Se(it),
        Gu(),
        n.pendingContext && (n.context = n.pendingContext,
        n.pendingContext = null),
        (s === null || s.child === null) && (Ji(e) ? e.flags |= 4 : s === null || s.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        qt !== null && (Vc(qt),
        qt = null))),
        Oc(s, e),
        st(e),
        null;
    case 5:
        ju(e);
        var r = In(xi.current);
        if (t = e.type,
        s !== null && e.stateNode != null)
            op(s, e, t, n, r),
            s.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!n) {
                if (e.stateNode === null)
                    throw Error(H(166));
                return st(e),
                null
            }
            if (s = In(ds.current),
            Ji(e)) {
                n = e.stateNode,
                t = e.type;
                var i = e.memoizedProps;
                switch (n[os] = e,
                n[pi] = i,
                s = (e.mode & 1) !== 0,
                t) {
                case "dialog":
                    Ee("cancel", n),
                    Ee("close", n);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Ee("load", n);
                    break;
                case "video":
                case "audio":
                    for (r = 0; r < Wr.length; r++)
                        Ee(Wr[r], n);
                    break;
                case "source":
                    Ee("error", n);
                    break;
                case "img":
                case "image":
                case "link":
                    Ee("error", n),
                    Ee("load", n);
                    break;
                case "details":
                    Ee("toggle", n);
                    break;
                case "input":
                    Vd(n, i),
                    Ee("invalid", n);
                    break;
                case "select":
                    n._wrapperState = {
                        wasMultiple: !!i.multiple
                    },
                    Ee("invalid", n);
                    break;
                case "textarea":
                    Kd(n, i),
                    Ee("invalid", n)
                }
                lc(t, i),
                r = null;
                for (var a in i)
                    if (i.hasOwnProperty(a)) {
                        var o = i[a];
                        a === "children" ? typeof o == "string" ? n.textContent !== o && (i.suppressHydrationWarning !== !0 && Qi(n.textContent, o, s),
                        r = ["children", o]) : typeof o == "number" && n.textContent !== "" + o && (i.suppressHydrationWarning !== !0 && Qi(n.textContent, o, s),
                        r = ["children", "" + o]) : ai.hasOwnProperty(a) && o != null && a === "onScroll" && Ee("scroll", n)
                    }
                switch (t) {
                case "input":
                    Hi(n),
                    Hd(n, i, !0);
                    break;
                case "textarea":
                    Hi(n),
                    Wd(n);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof i.onClick == "function" && (n.onclick = Qa)
                }
                n = r,
                e.updateQueue = n,
                n !== null && (e.flags |= 4)
            } else {
                a = r.nodeType === 9 ? r : r.ownerDocument,
                s === "http://www.w3.org/1999/xhtml" && (s = Mm(t)),
                s === "http://www.w3.org/1999/xhtml" ? t === "script" ? (s = a.createElement("div"),
                s.innerHTML = "<script><\/script>",
                s = s.removeChild(s.firstChild)) : typeof n.is == "string" ? s = a.createElement(t, {
                    is: n.is
                }) : (s = a.createElement(t),
                t === "select" && (a = s,
                n.multiple ? a.multiple = !0 : n.size && (a.size = n.size))) : s = a.createElementNS(s, t),
                s[os] = e,
                s[pi] = n,
                ap(s, e, !1, !1),
                e.stateNode = s;
                e: {
                    switch (a = cc(t, n),
                    t) {
                    case "dialog":
                        Ee("cancel", s),
                        Ee("close", s),
                        r = n;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Ee("load", s),
                        r = n;
                        break;
                    case "video":
                    case "audio":
                        for (r = 0; r < Wr.length; r++)
                            Ee(Wr[r], s);
                        r = n;
                        break;
                    case "source":
                        Ee("error", s),
                        r = n;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Ee("error", s),
                        Ee("load", s),
                        r = n;
                        break;
                    case "details":
                        Ee("toggle", s),
                        r = n;
                        break;
                    case "input":
                        Vd(s, n),
                        r = nc(s, n),
                        Ee("invalid", s);
                        break;
                    case "option":
                        r = n;
                        break;
                    case "select":
                        s._wrapperState = {
                            wasMultiple: !!n.multiple
                        },
                        r = Ce({}, n, {
                            value: void 0
                        }),
                        Ee("invalid", s);
                        break;
                    case "textarea":
                        Kd(s, n),
                        r = ac(s, n),
                        Ee("invalid", s);
                        break;
                    default:
                        r = n
                    }
                    lc(t, r),
                    o = r;
                    for (i in o)
                        if (o.hasOwnProperty(i)) {
                            var l = o[i];
                            i === "style" ? Bm(s, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && Fm(s, l)) : i === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && oi(s, l) : typeof l == "number" && oi(s, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (ai.hasOwnProperty(i) ? l != null && i === "onScroll" && Ee("scroll", s) : l != null && xu(s, i, l, a))
                        }
                    switch (t) {
                    case "input":
                        Hi(s),
                        Hd(s, n, !1);
                        break;
                    case "textarea":
                        Hi(s),
                        Wd(s);
                        break;
                    case "option":
                        n.value != null && s.setAttribute("value", "" + rn(n.value));
                        break;
                    case "select":
                        s.multiple = !!n.multiple,
                        i = n.value,
                        i != null ? rr(s, !!n.multiple, i, !1) : n.defaultValue != null && rr(s, !!n.multiple, n.defaultValue, !0);
                        break;
                    default:
                        typeof r.onClick == "function" && (s.onclick = Qa)
                    }
                    switch (t) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        n = !!n.autoFocus;
                        break e;
                    case "img":
                        n = !0;
                        break e;
                    default:
                        n = !1
                    }
                }
                n && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return st(e),
        null;
    case 6:
        if (s && e.stateNode != null)
            lp(s, e, s.memoizedProps, n);
        else {
            if (typeof n != "string" && e.stateNode === null)
                throw Error(H(166));
            if (t = In(xi.current),
            In(ds.current),
            Ji(e)) {
                if (n = e.stateNode,
                t = e.memoizedProps,
                n[os] = e,
                (i = n.nodeValue !== t) && (s = Rt,
                s !== null))
                    switch (s.tag) {
                    case 3:
                        Qi(n.nodeValue, t, (s.mode & 1) !== 0);
                        break;
                    case 5:
                        s.memoizedProps.suppressHydrationWarning !== !0 && Qi(n.nodeValue, t, (s.mode & 1) !== 0)
                    }
                i && (e.flags |= 4)
            } else
                n = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(n),
                n[os] = e,
                e.stateNode = n
        }
        return st(e),
        null;
    case 13:
        if (Se(be),
        n = e.memoizedState,
        s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
            if (Ie && bt !== null && e.mode & 1 && !(e.flags & 128))
                bg(),
                xr(),
                e.flags |= 98560,
                i = !1;
            else if (i = Ji(e),
            n !== null && n.dehydrated !== null) {
                if (s === null) {
                    if (!i)
                        throw Error(H(318));
                    if (i = e.memoizedState,
                    i = i !== null ? i.dehydrated : null,
                    !i)
                        throw Error(H(317));
                    i[os] = e
                } else
                    xr(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                st(e),
                i = !1
            } else
                qt !== null && (Vc(qt),
                qt = null),
                i = !0;
            if (!i)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = t,
        e) : (n = n !== null,
        n !== (s !== null && s.memoizedState !== null) && n && (e.child.flags |= 8192,
        e.mode & 1 && (s === null || be.current & 1 ? He === 0 && (He = 3) : ed())),
        e.updateQueue !== null && (e.flags |= 4),
        st(e),
        null);
    case 4:
        return Er(),
        Oc(s, e),
        s === null && mi(e.stateNode.containerInfo),
        st(e),
        null;
    case 10:
        return Fu(e.type._context),
        st(e),
        null;
    case 17:
        return vt(e.type) && Ja(),
        st(e),
        null;
    case 19:
        if (Se(be),
        i = e.memoizedState,
        i === null)
            return st(e),
            null;
        if (n = (e.flags & 128) !== 0,
        a = i.rendering,
        a === null)
            if (n)
                Br(i, !1);
            else {
                if (He !== 0 || s !== null && s.flags & 128)
                    for (s = e.child; s !== null; ) {
                        if (a = ao(s),
                        a !== null) {
                            for (e.flags |= 128,
                            Br(i, !1),
                            n = a.updateQueue,
                            n !== null && (e.updateQueue = n,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            n = t,
                            t = e.child; t !== null; )
                                i = t,
                                s = n,
                                i.flags &= 14680066,
                                a = i.alternate,
                                a === null ? (i.childLanes = 0,
                                i.lanes = s,
                                i.child = null,
                                i.subtreeFlags = 0,
                                i.memoizedProps = null,
                                i.memoizedState = null,
                                i.updateQueue = null,
                                i.dependencies = null,
                                i.stateNode = null) : (i.childLanes = a.childLanes,
                                i.lanes = a.lanes,
                                i.child = a.child,
                                i.subtreeFlags = 0,
                                i.deletions = null,
                                i.memoizedProps = a.memoizedProps,
                                i.memoizedState = a.memoizedState,
                                i.updateQueue = a.updateQueue,
                                i.type = a.type,
                                s = a.dependencies,
                                i.dependencies = s === null ? null : {
                                    lanes: s.lanes,
                                    firstContext: s.firstContext
                                }),
                                t = t.sibling;
                            return ve(be, be.current & 1 | 2),
                            e.child
                        }
                        s = s.sibling
                    }
                i.tail !== null && Me() > Tr && (e.flags |= 128,
                n = !0,
                Br(i, !1),
                e.lanes = 4194304)
            }
        else {
            if (!n)
                if (s = ao(a),
                s !== null) {
                    if (e.flags |= 128,
                    n = !0,
                    t = s.updateQueue,
                    t !== null && (e.updateQueue = t,
                    e.flags |= 4),
                    Br(i, !0),
                    i.tail === null && i.tailMode === "hidden" && !a.alternate && !Ie)
                        return st(e),
                        null
                } else
                    2 * Me() - i.renderingStartTime > Tr && t !== 1073741824 && (e.flags |= 128,
                    n = !0,
                    Br(i, !1),
                    e.lanes = 4194304);
            i.isBackwards ? (a.sibling = e.child,
            e.child = a) : (t = i.last,
            t !== null ? t.sibling = a : e.child = a,
            i.last = a)
        }
        return i.tail !== null ? (e = i.tail,
        i.rendering = e,
        i.tail = e.sibling,
        i.renderingStartTime = Me(),
        e.sibling = null,
        t = be.current,
        ve(be, n ? t & 1 | 2 : t & 1),
        e) : (st(e),
        null);
    case 22:
    case 23:
        return Ju(),
        n = e.memoizedState !== null,
        s !== null && s.memoizedState !== null !== n && (e.flags |= 8192),
        n && e.mode & 1 ? Lt & 1073741824 && (st(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : st(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(H(156, e.tag))
}
function Av(s, e) {
    switch (Pu(e),
    e.tag) {
    case 1:
        return vt(e.type) && Ja(),
        s = e.flags,
        s & 65536 ? (e.flags = s & -65537 | 128,
        e) : null;
    case 3:
        return Er(),
        Se(xt),
        Se(it),
        Gu(),
        s = e.flags,
        s & 65536 && !(s & 128) ? (e.flags = s & -65537 | 128,
        e) : null;
    case 5:
        return ju(e),
        null;
    case 13:
        if (Se(be),
        s = e.memoizedState,
        s !== null && s.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(H(340));
            xr()
        }
        return s = e.flags,
        s & 65536 ? (e.flags = s & -65537 | 128,
        e) : null;
    case 19:
        return Se(be),
        null;
    case 4:
        return Er(),
        null;
    case 10:
        return Fu(e.type._context),
        null;
    case 22:
    case 23:
        return Ju(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var sa = !1
  , nt = !1
  , bv = typeof WeakSet == "function" ? WeakSet : Set
  , Y = null;
function tr(s, e) {
    var t = s.ref;
    if (t !== null)
        if (typeof t == "function")
            try {
                t(null)
            } catch (n) {
                De(s, e, n)
            }
        else
            t.current = null
}
function Mc(s, e, t) {
    try {
        t()
    } catch (n) {
        De(s, e, n)
    }
}
var Oh = !1;
function Rv(s, e) {
    if (vc = Xa,
    s = fg(),
    _u(s)) {
        if ("selectionStart"in s)
            var t = {
                start: s.selectionStart,
                end: s.selectionEnd
            };
        else
            e: {
                t = (t = s.ownerDocument) && t.defaultView || window;
                var n = t.getSelection && t.getSelection();
                if (n && n.rangeCount !== 0) {
                    t = n.anchorNode;
                    var r = n.anchorOffset
                      , i = n.focusNode;
                    n = n.focusOffset;
                    try {
                        t.nodeType,
                        i.nodeType
                    } catch {
                        t = null;
                        break e
                    }
                    var a = 0
                      , o = -1
                      , l = -1
                      , c = 0
                      , u = 0
                      , d = s
                      , h = null;
                    t: for (; ; ) {
                        for (var f; d !== t || r !== 0 && d.nodeType !== 3 || (o = a + r),
                        d !== i || n !== 0 && d.nodeType !== 3 || (l = a + n),
                        d.nodeType === 3 && (a += d.nodeValue.length),
                        (f = d.firstChild) !== null; )
                            h = d,
                            d = f;
                        for (; ; ) {
                            if (d === s)
                                break t;
                            if (h === t && ++c === r && (o = a),
                            h === i && ++u === n && (l = a),
                            (f = d.nextSibling) !== null)
                                break;
                            d = h,
                            h = d.parentNode
                        }
                        d = f
                    }
                    t = o === -1 || l === -1 ? null : {
                        start: o,
                        end: l
                    }
                } else
                    t = null
            }
        t = t || {
            start: 0,
            end: 0
        }
    } else
        t = null;
    for (Ec = {
        focusedElem: s,
        selectionRange: t
    },
    Xa = !1,
    Y = e; Y !== null; )
        if (e = Y,
        s = e.child,
        (e.subtreeFlags & 1028) !== 0 && s !== null)
            s.return = e,
            Y = s;
        else
            for (; Y !== null; ) {
                e = Y;
                try {
                    var m = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (m !== null) {
                                var p = m.memoizedProps
                                  , x = m.memoizedState
                                  , y = e.stateNode
                                  , v = y.getSnapshotBeforeUpdate(e.elementType === e.type ? p : Xt(e.type, p), x);
                                y.__reactInternalSnapshotBeforeUpdate = v
                            }
                            break;
                        case 3:
                            var E = e.stateNode.containerInfo;
                            E.nodeType === 1 ? E.textContent = "" : E.nodeType === 9 && E.documentElement && E.removeChild(E.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(H(163))
                        }
                } catch (T) {
                    De(e, e.return, T)
                }
                if (s = e.sibling,
                s !== null) {
                    s.return = e.return,
                    Y = s;
                    break
                }
                Y = e.return
            }
    return m = Oh,
    Oh = !1,
    m
}
function ei(s, e, t) {
    var n = e.updateQueue;
    if (n = n !== null ? n.lastEffect : null,
    n !== null) {
        var r = n = n.next;
        do {
            if ((r.tag & s) === s) {
                var i = r.destroy;
                r.destroy = void 0,
                i !== void 0 && Mc(e, t, i)
            }
            r = r.next
        } while (r !== n)
    }
}
function Uo(s, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var t = e = e.next;
        do {
            if ((t.tag & s) === s) {
                var n = t.create;
                t.destroy = n()
            }
            t = t.next
        } while (t !== e)
    }
}
function Fc(s) {
    var e = s.ref;
    if (e !== null) {
        var t = s.stateNode;
        switch (s.tag) {
        case 5:
            s = t;
            break;
        default:
            s = t
        }
        typeof e == "function" ? e(s) : e.current = s
    }
}
function cp(s) {
    var e = s.alternate;
    e !== null && (s.alternate = null,
    cp(e)),
    s.child = null,
    s.deletions = null,
    s.sibling = null,
    s.tag === 5 && (e = s.stateNode,
    e !== null && (delete e[os],
    delete e[pi],
    delete e[Lc],
    delete e[cv],
    delete e[uv])),
    s.stateNode = null,
    s.return = null,
    s.dependencies = null,
    s.memoizedProps = null,
    s.memoizedState = null,
    s.pendingProps = null,
    s.stateNode = null,
    s.updateQueue = null
}
function up(s) {
    return s.tag === 5 || s.tag === 3 || s.tag === 4
}
function Mh(s) {
    e: for (; ; ) {
        for (; s.sibling === null; ) {
            if (s.return === null || up(s.return))
                return null;
            s = s.return
        }
        for (s.sibling.return = s.return,
        s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18; ) {
            if (s.flags & 2 || s.child === null || s.tag === 4)
                continue e;
            s.child.return = s,
            s = s.child
        }
        if (!(s.flags & 2))
            return s.stateNode
    }
}
function Uc(s, e, t) {
    var n = s.tag;
    if (n === 5 || n === 6)
        s = s.stateNode,
        e ? t.nodeType === 8 ? t.parentNode.insertBefore(s, e) : t.insertBefore(s, e) : (t.nodeType === 8 ? (e = t.parentNode,
        e.insertBefore(s, t)) : (e = t,
        e.appendChild(s)),
        t = t._reactRootContainer,
        t != null || e.onclick !== null || (e.onclick = Qa));
    else if (n !== 4 && (s = s.child,
    s !== null))
        for (Uc(s, e, t),
        s = s.sibling; s !== null; )
            Uc(s, e, t),
            s = s.sibling
}
function Bc(s, e, t) {
    var n = s.tag;
    if (n === 5 || n === 6)
        s = s.stateNode,
        e ? t.insertBefore(s, e) : t.appendChild(s);
    else if (n !== 4 && (s = s.child,
    s !== null))
        for (Bc(s, e, t),
        s = s.sibling; s !== null; )
            Bc(s, e, t),
            s = s.sibling
}
var Ze = null
  , Zt = !1;
function Us(s, e, t) {
    for (t = t.child; t !== null; )
        dp(s, e, t),
        t = t.sibling
}
function dp(s, e, t) {
    if (us && typeof us.onCommitFiberUnmount == "function")
        try {
            us.onCommitFiberUnmount(ko, t)
        } catch {}
    switch (t.tag) {
    case 5:
        nt || tr(t, e);
    case 6:
        var n = Ze
          , r = Zt;
        Ze = null,
        Us(s, e, t),
        Ze = n,
        Zt = r,
        Ze !== null && (Zt ? (s = Ze,
        t = t.stateNode,
        s.nodeType === 8 ? s.parentNode.removeChild(t) : s.removeChild(t)) : Ze.removeChild(t.stateNode));
        break;
    case 18:
        Ze !== null && (Zt ? (s = Ze,
        t = t.stateNode,
        s.nodeType === 8 ? pl(s.parentNode, t) : s.nodeType === 1 && pl(s, t),
        di(s)) : pl(Ze, t.stateNode));
        break;
    case 4:
        n = Ze,
        r = Zt,
        Ze = t.stateNode.containerInfo,
        Zt = !0,
        Us(s, e, t),
        Ze = n,
        Zt = r;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!nt && (n = t.updateQueue,
        n !== null && (n = n.lastEffect,
        n !== null))) {
            r = n = n.next;
            do {
                var i = r
                  , a = i.destroy;
                i = i.tag,
                a !== void 0 && (i & 2 || i & 4) && Mc(t, e, a),
                r = r.next
            } while (r !== n)
        }
        Us(s, e, t);
        break;
    case 1:
        if (!nt && (tr(t, e),
        n = t.stateNode,
        typeof n.componentWillUnmount == "function"))
            try {
                n.props = t.memoizedProps,
                n.state = t.memoizedState,
                n.componentWillUnmount()
            } catch (o) {
                De(t, e, o)
            }
        Us(s, e, t);
        break;
    case 21:
        Us(s, e, t);
        break;
    case 22:
        t.mode & 1 ? (nt = (n = nt) || t.memoizedState !== null,
        Us(s, e, t),
        nt = n) : Us(s, e, t);
        break;
    default:
        Us(s, e, t)
    }
}
function Fh(s) {
    var e = s.updateQueue;
    if (e !== null) {
        s.updateQueue = null;
        var t = s.stateNode;
        t === null && (t = s.stateNode = new bv),
        e.forEach(function(n) {
            var r = Mv.bind(null, s, n);
            t.has(n) || (t.add(n),
            n.then(r, r))
        })
    }
}
function Ht(s, e) {
    var t = e.deletions;
    if (t !== null)
        for (var n = 0; n < t.length; n++) {
            var r = t[n];
            try {
                var i = s
                  , a = e
                  , o = a;
                e: for (; o !== null; ) {
                    switch (o.tag) {
                    case 5:
                        Ze = o.stateNode,
                        Zt = !1;
                        break e;
                    case 3:
                        Ze = o.stateNode.containerInfo,
                        Zt = !0;
                        break e;
                    case 4:
                        Ze = o.stateNode.containerInfo,
                        Zt = !0;
                        break e
                    }
                    o = o.return
                }
                if (Ze === null)
                    throw Error(H(160));
                dp(i, a, r),
                Ze = null,
                Zt = !1;
                var l = r.alternate;
                l !== null && (l.return = null),
                r.return = null
            } catch (c) {
                De(r, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            hp(e, s),
            e = e.sibling
}
function hp(s, e) {
    var t = s.alternate
      , n = s.flags;
    switch (s.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (Ht(e, s),
        ts(s),
        n & 4) {
            try {
                ei(3, s, s.return),
                Uo(3, s)
            } catch (p) {
                De(s, s.return, p)
            }
            try {
                ei(5, s, s.return)
            } catch (p) {
                De(s, s.return, p)
            }
        }
        break;
    case 1:
        Ht(e, s),
        ts(s),
        n & 512 && t !== null && tr(t, t.return);
        break;
    case 5:
        if (Ht(e, s),
        ts(s),
        n & 512 && t !== null && tr(t, t.return),
        s.flags & 32) {
            var r = s.stateNode;
            try {
                oi(r, "")
            } catch (p) {
                De(s, s.return, p)
            }
        }
        if (n & 4 && (r = s.stateNode,
        r != null)) {
            var i = s.memoizedProps
              , a = t !== null ? t.memoizedProps : i
              , o = s.type
              , l = s.updateQueue;
            if (s.updateQueue = null,
            l !== null)
                try {
                    o === "input" && i.type === "radio" && i.name != null && Nm(r, i),
                    cc(o, a);
                    var c = cc(o, i);
                    for (a = 0; a < l.length; a += 2) {
                        var u = l[a]
                          , d = l[a + 1];
                        u === "style" ? Bm(r, d) : u === "dangerouslySetInnerHTML" ? Fm(r, d) : u === "children" ? oi(r, d) : xu(r, u, d, c)
                    }
                    switch (o) {
                    case "input":
                        rc(r, i);
                        break;
                    case "textarea":
                        Om(r, i);
                        break;
                    case "select":
                        var h = r._wrapperState.wasMultiple;
                        r._wrapperState.wasMultiple = !!i.multiple;
                        var f = i.value;
                        f != null ? rr(r, !!i.multiple, f, !1) : h !== !!i.multiple && (i.defaultValue != null ? rr(r, !!i.multiple, i.defaultValue, !0) : rr(r, !!i.multiple, i.multiple ? [] : "", !1))
                    }
                    r[pi] = i
                } catch (p) {
                    De(s, s.return, p)
                }
        }
        break;
    case 6:
        if (Ht(e, s),
        ts(s),
        n & 4) {
            if (s.stateNode === null)
                throw Error(H(162));
            r = s.stateNode,
            i = s.memoizedProps;
            try {
                r.nodeValue = i
            } catch (p) {
                De(s, s.return, p)
            }
        }
        break;
    case 3:
        if (Ht(e, s),
        ts(s),
        n & 4 && t !== null && t.memoizedState.isDehydrated)
            try {
                di(e.containerInfo)
            } catch (p) {
                De(s, s.return, p)
            }
        break;
    case 4:
        Ht(e, s),
        ts(s);
        break;
    case 13:
        Ht(e, s),
        ts(s),
        r = s.child,
        r.flags & 8192 && (i = r.memoizedState !== null,
        r.stateNode.isHidden = i,
        !i || r.alternate !== null && r.alternate.memoizedState !== null || (qu = Me())),
        n & 4 && Fh(s);
        break;
    case 22:
        if (u = t !== null && t.memoizedState !== null,
        s.mode & 1 ? (nt = (c = nt) || u,
        Ht(e, s),
        nt = c) : Ht(e, s),
        ts(s),
        n & 8192) {
            if (c = s.memoizedState !== null,
            (s.stateNode.isHidden = c) && !u && s.mode & 1)
                for (Y = s,
                u = s.child; u !== null; ) {
                    for (d = Y = u; Y !== null; ) {
                        switch (h = Y,
                        f = h.child,
                        h.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            ei(4, h, h.return);
                            break;
                        case 1:
                            tr(h, h.return);
                            var m = h.stateNode;
                            if (typeof m.componentWillUnmount == "function") {
                                n = h,
                                t = h.return;
                                try {
                                    e = n,
                                    m.props = e.memoizedProps,
                                    m.state = e.memoizedState,
                                    m.componentWillUnmount()
                                } catch (p) {
                                    De(n, t, p)
                                }
                            }
                            break;
                        case 5:
                            tr(h, h.return);
                            break;
                        case 22:
                            if (h.memoizedState !== null) {
                                Bh(d);
                                continue
                            }
                        }
                        f !== null ? (f.return = h,
                        Y = f) : Bh(d)
                    }
                    u = u.sibling
                }
            e: for (u = null,
            d = s; ; ) {
                if (d.tag === 5) {
                    if (u === null) {
                        u = d;
                        try {
                            r = d.stateNode,
                            c ? (i = r.style,
                            typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (o = d.stateNode,
                            l = d.memoizedProps.style,
                            a = l != null && l.hasOwnProperty("display") ? l.display : null,
                            o.style.display = Um("display", a))
                        } catch (p) {
                            De(s, s.return, p)
                        }
                    }
                } else if (d.tag === 6) {
                    if (u === null)
                        try {
                            d.stateNode.nodeValue = c ? "" : d.memoizedProps
                        } catch (p) {
                            De(s, s.return, p)
                        }
                } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === s) && d.child !== null) {
                    d.child.return = d,
                    d = d.child;
                    continue
                }
                if (d === s)
                    break e;
                for (; d.sibling === null; ) {
                    if (d.return === null || d.return === s)
                        break e;
                    u === d && (u = null),
                    d = d.return
                }
                u === d && (u = null),
                d.sibling.return = d.return,
                d = d.sibling
            }
        }
        break;
    case 19:
        Ht(e, s),
        ts(s),
        n & 4 && Fh(s);
        break;
    case 21:
        break;
    default:
        Ht(e, s),
        ts(s)
    }
}
function ts(s) {
    var e = s.flags;
    if (e & 2) {
        try {
            e: {
                for (var t = s.return; t !== null; ) {
                    if (up(t)) {
                        var n = t;
                        break e
                    }
                    t = t.return
                }
                throw Error(H(160))
            }
            switch (n.tag) {
            case 5:
                var r = n.stateNode;
                n.flags & 32 && (oi(r, ""),
                n.flags &= -33);
                var i = Mh(s);
                Bc(s, i, r);
                break;
            case 3:
            case 4:
                var a = n.stateNode.containerInfo
                  , o = Mh(s);
                Uc(s, o, a);
                break;
            default:
                throw Error(H(161))
            }
        } catch (l) {
            De(s, s.return, l)
        }
        s.flags &= -3
    }
    e & 4096 && (s.flags &= -4097)
}
function wv(s, e, t) {
    Y = s,
    fp(s)
}
function fp(s, e, t) {
    for (var n = (s.mode & 1) !== 0; Y !== null; ) {
        var r = Y
          , i = r.child;
        if (r.tag === 22 && n) {
            var a = r.memoizedState !== null || sa;
            if (!a) {
                var o = r.alternate
                  , l = o !== null && o.memoizedState !== null || nt;
                o = sa;
                var c = nt;
                if (sa = a,
                (nt = l) && !c)
                    for (Y = r; Y !== null; )
                        a = Y,
                        l = a.child,
                        a.tag === 22 && a.memoizedState !== null ? $h(r) : l !== null ? (l.return = a,
                        Y = l) : $h(r);
                for (; i !== null; )
                    Y = i,
                    fp(i),
                    i = i.sibling;
                Y = r,
                sa = o,
                nt = c
            }
            Uh(s)
        } else
            r.subtreeFlags & 8772 && i !== null ? (i.return = r,
            Y = i) : Uh(s)
    }
}
function Uh(s) {
    for (; Y !== null; ) {
        var e = Y;
        if (e.flags & 8772) {
            var t = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        nt || Uo(5, e);
                        break;
                    case 1:
                        var n = e.stateNode;
                        if (e.flags & 4 && !nt)
                            if (t === null)
                                n.componentDidMount();
                            else {
                                var r = e.elementType === e.type ? t.memoizedProps : Xt(e.type, t.memoizedProps);
                                n.componentDidUpdate(r, t.memoizedState, n.__reactInternalSnapshotBeforeUpdate)
                            }
                        var i = e.updateQueue;
                        i !== null && Th(e, i, n);
                        break;
                    case 3:
                        var a = e.updateQueue;
                        if (a !== null) {
                            if (t = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    t = e.child.stateNode;
                                    break;
                                case 1:
                                    t = e.child.stateNode
                                }
                            Th(e, a, t)
                        }
                        break;
                    case 5:
                        var o = e.stateNode;
                        if (t === null && e.flags & 4) {
                            t = o;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && t.focus();
                                break;
                            case "img":
                                l.src && (t.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var u = c.memoizedState;
                                if (u !== null) {
                                    var d = u.dehydrated;
                                    d !== null && di(d)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(H(163))
                    }
                nt || e.flags & 512 && Fc(e)
            } catch (h) {
                De(e, e.return, h)
            }
        }
        if (e === s) {
            Y = null;
            break
        }
        if (t = e.sibling,
        t !== null) {
            t.return = e.return,
            Y = t;
            break
        }
        Y = e.return
    }
}
function Bh(s) {
    for (; Y !== null; ) {
        var e = Y;
        if (e === s) {
            Y = null;
            break
        }
        var t = e.sibling;
        if (t !== null) {
            t.return = e.return,
            Y = t;
            break
        }
        Y = e.return
    }
}
function $h(s) {
    for (; Y !== null; ) {
        var e = Y;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var t = e.return;
                try {
                    Uo(4, e)
                } catch (l) {
                    De(e, t, l)
                }
                break;
            case 1:
                var n = e.stateNode;
                if (typeof n.componentDidMount == "function") {
                    var r = e.return;
                    try {
                        n.componentDidMount()
                    } catch (l) {
                        De(e, r, l)
                    }
                }
                var i = e.return;
                try {
                    Fc(e)
                } catch (l) {
                    De(e, i, l)
                }
                break;
            case 5:
                var a = e.return;
                try {
                    Fc(e)
                } catch (l) {
                    De(e, a, l)
                }
            }
        } catch (l) {
            De(e, e.return, l)
        }
        if (e === s) {
            Y = null;
            break
        }
        var o = e.sibling;
        if (o !== null) {
            o.return = e.return,
            Y = o;
            break
        }
        Y = e.return
    }
}
var Cv = Math.ceil
  , co = Ms.ReactCurrentDispatcher
  , Xu = Ms.ReactCurrentOwner
  , Ut = Ms.ReactCurrentBatchConfig
  , de = 0
  , Ye = null
  , Ue = null
  , Je = 0
  , Lt = 0
  , sr = un(0)
  , He = 0
  , Ti = null
  , _n = 0
  , Bo = 0
  , Zu = 0
  , ti = null
  , mt = null
  , qu = 0
  , Tr = 1 / 0
  , Ts = null
  , uo = !1
  , $c = null
  , en = null
  , na = !1
  , Ys = null
  , ho = 0
  , si = 0
  , jc = null
  , _a = -1
  , Da = 0;
function ct() {
    return de & 6 ? Me() : _a !== -1 ? _a : _a = Me()
}
function tn(s) {
    return s.mode & 1 ? de & 2 && Je !== 0 ? Je & -Je : hv.transition !== null ? (Da === 0 && (Da = qm()),
    Da) : (s = me,
    s !== 0 || (s = window.event,
    s = s === void 0 ? 16 : rg(s.type)),
    s) : 1
}
function Jt(s, e, t, n) {
    if (50 < si)
        throw si = 0,
        jc = null,
        Error(H(185));
    Di(s, t, n),
    (!(de & 2) || s !== Ye) && (s === Ye && (!(de & 2) && (Bo |= t),
    He === 4 && Ws(s, Je)),
    Et(s, n),
    t === 1 && de === 0 && !(e.mode & 1) && (Tr = Me() + 500,
    Oo && dn()))
}
function Et(s, e) {
    var t = s.callbackNode;
    hx(s, e);
    var n = Ya(s, s === Ye ? Je : 0);
    if (n === 0)
        t !== null && Xd(t),
        s.callbackNode = null,
        s.callbackPriority = 0;
    else if (e = n & -n,
    s.callbackPriority !== e) {
        if (t != null && Xd(t),
        e === 1)
            s.tag === 0 ? dv(jh.bind(null, s)) : Lg(jh.bind(null, s)),
            ov(function() {
                !(de & 6) && dn()
            }),
            t = null;
        else {
            switch (Qm(n)) {
            case 1:
                t = Lu;
                break;
            case 4:
                t = Xm;
                break;
            case 16:
                t = za;
                break;
            case 536870912:
                t = Zm;
                break;
            default:
                t = za
            }
            t = Sp(t, mp.bind(null, s))
        }
        s.callbackPriority = e,
        s.callbackNode = t
    }
}
function mp(s, e) {
    if (_a = -1,
    Da = 0,
    de & 6)
        throw Error(H(327));
    var t = s.callbackNode;
    if (cr() && s.callbackNode !== t)
        return null;
    var n = Ya(s, s === Ye ? Je : 0);
    if (n === 0)
        return null;
    if (n & 30 || n & s.expiredLanes || e)
        e = fo(s, n);
    else {
        e = n;
        var r = de;
        de |= 2;
        var i = pp();
        (Ye !== s || Je !== e) && (Ts = null,
        Tr = Me() + 500,
        An(s, e));
        do
            try {
                Dv();
                break
            } catch (o) {
                gp(s, o)
            }
        while (!0);
        Mu(),
        co.current = i,
        de = r,
        Ue !== null ? e = 0 : (Ye = null,
        Je = 0,
        e = He)
    }
    if (e !== 0) {
        if (e === 2 && (r = mc(s),
        r !== 0 && (n = r,
        e = Gc(s, r))),
        e === 1)
            throw t = Ti,
            An(s, 0),
            Ws(s, n),
            Et(s, Me()),
            t;
        if (e === 6)
            Ws(s, n);
        else {
            if (r = s.current.alternate,
            !(n & 30) && !kv(r) && (e = fo(s, n),
            e === 2 && (i = mc(s),
            i !== 0 && (n = i,
            e = Gc(s, i))),
            e === 1))
                throw t = Ti,
                An(s, 0),
                Ws(s, n),
                Et(s, Me()),
                t;
            switch (s.finishedWork = r,
            s.finishedLanes = n,
            e) {
            case 0:
            case 1:
                throw Error(H(345));
            case 2:
                En(s, mt, Ts);
                break;
            case 3:
                if (Ws(s, n),
                (n & 130023424) === n && (e = qu + 500 - Me(),
                10 < e)) {
                    if (Ya(s, 0) !== 0)
                        break;
                    if (r = s.suspendedLanes,
                    (r & n) !== n) {
                        ct(),
                        s.pingedLanes |= s.suspendedLanes & r;
                        break
                    }
                    s.timeoutHandle = Tc(En.bind(null, s, mt, Ts), e);
                    break
                }
                En(s, mt, Ts);
                break;
            case 4:
                if (Ws(s, n),
                (n & 4194240) === n)
                    break;
                for (e = s.eventTimes,
                r = -1; 0 < n; ) {
                    var a = 31 - Qt(n);
                    i = 1 << a,
                    a = e[a],
                    a > r && (r = a),
                    n &= ~i
                }
                if (n = r,
                n = Me() - n,
                n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * Cv(n / 1960)) - n,
                10 < n) {
                    s.timeoutHandle = Tc(En.bind(null, s, mt, Ts), n);
                    break
                }
                En(s, mt, Ts);
                break;
            case 5:
                En(s, mt, Ts);
                break;
            default:
                throw Error(H(329))
            }
        }
    }
    return Et(s, Me()),
    s.callbackNode === t ? mp.bind(null, s) : null
}
function Gc(s, e) {
    var t = ti;
    return s.current.memoizedState.isDehydrated && (An(s, e).flags |= 256),
    s = fo(s, e),
    s !== 2 && (e = mt,
    mt = t,
    e !== null && Vc(e)),
    s
}
function Vc(s) {
    mt === null ? mt = s : mt.push.apply(mt, s)
}
function kv(s) {
    for (var e = s; ; ) {
        if (e.flags & 16384) {
            var t = e.updateQueue;
            if (t !== null && (t = t.stores,
            t !== null))
                for (var n = 0; n < t.length; n++) {
                    var r = t[n]
                      , i = r.getSnapshot;
                    r = r.value;
                    try {
                        if (!es(i(), r))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (t = e.child,
        e.subtreeFlags & 16384 && t !== null)
            t.return = e,
            e = t;
        else {
            if (e === s)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === s)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function Ws(s, e) {
    for (e &= ~Zu,
    e &= ~Bo,
    s.suspendedLanes |= e,
    s.pingedLanes &= ~e,
    s = s.expirationTimes; 0 < e; ) {
        var t = 31 - Qt(e)
          , n = 1 << t;
        s[t] = -1,
        e &= ~n
    }
}
function jh(s) {
    if (de & 6)
        throw Error(H(327));
    cr();
    var e = Ya(s, 0);
    if (!(e & 1))
        return Et(s, Me()),
        null;
    var t = fo(s, e);
    if (s.tag !== 0 && t === 2) {
        var n = mc(s);
        n !== 0 && (e = n,
        t = Gc(s, n))
    }
    if (t === 1)
        throw t = Ti,
        An(s, 0),
        Ws(s, e),
        Et(s, Me()),
        t;
    if (t === 6)
        throw Error(H(345));
    return s.finishedWork = s.current.alternate,
    s.finishedLanes = e,
    En(s, mt, Ts),
    Et(s, Me()),
    null
}
function Qu(s, e) {
    var t = de;
    de |= 1;
    try {
        return s(e)
    } finally {
        de = t,
        de === 0 && (Tr = Me() + 500,
        Oo && dn())
    }
}
function Dn(s) {
    Ys !== null && Ys.tag === 0 && !(de & 6) && cr();
    var e = de;
    de |= 1;
    var t = Ut.transition
      , n = me;
    try {
        if (Ut.transition = null,
        me = 1,
        s)
            return s()
    } finally {
        me = n,
        Ut.transition = t,
        de = e,
        !(de & 6) && dn()
    }
}
function Ju() {
    Lt = sr.current,
    Se(sr)
}
function An(s, e) {
    s.finishedWork = null,
    s.finishedLanes = 0;
    var t = s.timeoutHandle;
    if (t !== -1 && (s.timeoutHandle = -1,
    av(t)),
    Ue !== null)
        for (t = Ue.return; t !== null; ) {
            var n = t;
            switch (Pu(n),
            n.tag) {
            case 1:
                n = n.type.childContextTypes,
                n != null && Ja();
                break;
            case 3:
                Er(),
                Se(xt),
                Se(it),
                Gu();
                break;
            case 5:
                ju(n);
                break;
            case 4:
                Er();
                break;
            case 13:
                Se(be);
                break;
            case 19:
                Se(be);
                break;
            case 10:
                Fu(n.type._context);
                break;
            case 22:
            case 23:
                Ju()
            }
            t = t.return
        }
    if (Ye = s,
    Ue = s = sn(s.current, null),
    Je = Lt = e,
    He = 0,
    Ti = null,
    Zu = Bo = _n = 0,
    mt = ti = null,
    Ln !== null) {
        for (e = 0; e < Ln.length; e++)
            if (t = Ln[e],
            n = t.interleaved,
            n !== null) {
                t.interleaved = null;
                var r = n.next
                  , i = t.pending;
                if (i !== null) {
                    var a = i.next;
                    i.next = r,
                    n.next = a
                }
                t.pending = n
            }
        Ln = null
    }
    return s
}
function gp(s, e) {
    do {
        var t = Ue;
        try {
            if (Mu(),
            wa.current = lo,
            oo) {
                for (var n = Re.memoizedState; n !== null; ) {
                    var r = n.queue;
                    r !== null && (r.pending = null),
                    n = n.next
                }
                oo = !1
            }
            if (kn = 0,
            ze = Ge = Re = null,
            Jr = !1,
            vi = 0,
            Xu.current = null,
            t === null || t.return === null) {
                He = 1,
                Ti = e,
                Ue = null;
                break
            }
            e: {
                var i = s
                  , a = t.return
                  , o = t
                  , l = e;
                if (e = Je,
                o.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , u = o
                      , d = u.tag;
                    if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) {
                        var h = u.alternate;
                        h ? (u.updateQueue = h.updateQueue,
                        u.memoizedState = h.memoizedState,
                        u.lanes = h.lanes) : (u.updateQueue = null,
                        u.memoizedState = null)
                    }
                    var f = wh(a);
                    if (f !== null) {
                        f.flags &= -257,
                        Ch(f, a, o, i, e),
                        f.mode & 1 && Rh(i, c, e),
                        e = f,
                        l = c;
                        var m = e.updateQueue;
                        if (m === null) {
                            var p = new Set;
                            p.add(l),
                            e.updateQueue = p
                        } else
                            m.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            Rh(i, c, e),
                            ed();
                            break e
                        }
                        l = Error(H(426))
                    }
                } else if (Ie && o.mode & 1) {
                    var x = wh(a);
                    if (x !== null) {
                        !(x.flags & 65536) && (x.flags |= 256),
                        Ch(x, a, o, i, e),
                        Nu(Sr(l, o));
                        break e
                    }
                }
                i = l = Sr(l, o),
                He !== 4 && (He = 2),
                ti === null ? ti = [i] : ti.push(i),
                i = a;
                do {
                    switch (i.tag) {
                    case 3:
                        i.flags |= 65536,
                        e &= -e,
                        i.lanes |= e;
                        var y = Qg(i, l, e);
                        Sh(i, y);
                        break e;
                    case 1:
                        o = l;
                        var v = i.type
                          , E = i.stateNode;
                        if (!(i.flags & 128) && (typeof v.getDerivedStateFromError == "function" || E !== null && typeof E.componentDidCatch == "function" && (en === null || !en.has(E)))) {
                            i.flags |= 65536,
                            e &= -e,
                            i.lanes |= e;
                            var T = Jg(i, o, e);
                            Sh(i, T);
                            break e
                        }
                    }
                    i = i.return
                } while (i !== null)
            }
            xp(t)
        } catch (L) {
            e = L,
            Ue === t && t !== null && (Ue = t = t.return);
            continue
        }
        break
    } while (!0)
}
function pp() {
    var s = co.current;
    return co.current = lo,
    s === null ? lo : s
}
function ed() {
    (He === 0 || He === 3 || He === 2) && (He = 4),
    Ye === null || !(_n & 268435455) && !(Bo & 268435455) || Ws(Ye, Je)
}
function fo(s, e) {
    var t = de;
    de |= 2;
    var n = pp();
    (Ye !== s || Je !== e) && (Ts = null,
    An(s, e));
    do
        try {
            _v();
            break
        } catch (r) {
            gp(s, r)
        }
    while (!0);
    if (Mu(),
    de = t,
    co.current = n,
    Ue !== null)
        throw Error(H(261));
    return Ye = null,
    Je = 0,
    He
}
function _v() {
    for (; Ue !== null; )
        yp(Ue)
}
function Dv() {
    for (; Ue !== null && !nx(); )
        yp(Ue)
}
function yp(s) {
    var e = Ep(s.alternate, s, Lt);
    s.memoizedProps = s.pendingProps,
    e === null ? xp(s) : Ue = e,
    Xu.current = null
}
function xp(s) {
    var e = s;
    do {
        var t = e.alternate;
        if (s = e.return,
        e.flags & 32768) {
            if (t = Av(t, e),
            t !== null) {
                t.flags &= 32767,
                Ue = t;
                return
            }
            if (s !== null)
                s.flags |= 32768,
                s.subtreeFlags = 0,
                s.deletions = null;
            else {
                He = 6,
                Ue = null;
                return
            }
        } else if (t = Iv(t, e, Lt),
        t !== null) {
            Ue = t;
            return
        }
        if (e = e.sibling,
        e !== null) {
            Ue = e;
            return
        }
        Ue = e = s
    } while (e !== null);
    He === 0 && (He = 5)
}
function En(s, e, t) {
    var n = me
      , r = Ut.transition;
    try {
        Ut.transition = null,
        me = 1,
        Pv(s, e, t, n)
    } finally {
        Ut.transition = r,
        me = n
    }
    return null
}
function Pv(s, e, t, n) {
    do
        cr();
    while (Ys !== null);
    if (de & 6)
        throw Error(H(327));
    t = s.finishedWork;
    var r = s.finishedLanes;
    if (t === null)
        return null;
    if (s.finishedWork = null,
    s.finishedLanes = 0,
    t === s.current)
        throw Error(H(177));
    s.callbackNode = null,
    s.callbackPriority = 0;
    var i = t.lanes | t.childLanes;
    if (fx(s, i),
    s === Ye && (Ue = Ye = null,
    Je = 0),
    !(t.subtreeFlags & 2064) && !(t.flags & 2064) || na || (na = !0,
    Sp(za, function() {
        return cr(),
        null
    })),
    i = (t.flags & 15990) !== 0,
    t.subtreeFlags & 15990 || i) {
        i = Ut.transition,
        Ut.transition = null;
        var a = me;
        me = 1;
        var o = de;
        de |= 4,
        Xu.current = null,
        Rv(s, t),
        hp(t, s),
        Jx(Ec),
        Xa = !!vc,
        Ec = vc = null,
        s.current = t,
        wv(t),
        rx(),
        de = o,
        me = a,
        Ut.transition = i
    } else
        s.current = t;
    if (na && (na = !1,
    Ys = s,
    ho = r),
    i = s.pendingLanes,
    i === 0 && (en = null),
    ox(t.stateNode),
    Et(s, Me()),
    e !== null)
        for (n = s.onRecoverableError,
        t = 0; t < e.length; t++)
            r = e[t],
            n(r.value, {
                componentStack: r.stack,
                digest: r.digest
            });
    if (uo)
        throw uo = !1,
        s = $c,
        $c = null,
        s;
    return ho & 1 && s.tag !== 0 && cr(),
    i = s.pendingLanes,
    i & 1 ? s === jc ? si++ : (si = 0,
    jc = s) : si = 0,
    dn(),
    null
}
function cr() {
    if (Ys !== null) {
        var s = Qm(ho)
          , e = Ut.transition
          , t = me;
        try {
            if (Ut.transition = null,
            me = 16 > s ? 16 : s,
            Ys === null)
                var n = !1;
            else {
                if (s = Ys,
                Ys = null,
                ho = 0,
                de & 6)
                    throw Error(H(331));
                var r = de;
                for (de |= 4,
                Y = s.current; Y !== null; ) {
                    var i = Y
                      , a = i.child;
                    if (Y.flags & 16) {
                        var o = i.deletions;
                        if (o !== null) {
                            for (var l = 0; l < o.length; l++) {
                                var c = o[l];
                                for (Y = c; Y !== null; ) {
                                    var u = Y;
                                    switch (u.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        ei(8, u, i)
                                    }
                                    var d = u.child;
                                    if (d !== null)
                                        d.return = u,
                                        Y = d;
                                    else
                                        for (; Y !== null; ) {
                                            u = Y;
                                            var h = u.sibling
                                              , f = u.return;
                                            if (cp(u),
                                            u === c) {
                                                Y = null;
                                                break
                                            }
                                            if (h !== null) {
                                                h.return = f,
                                                Y = h;
                                                break
                                            }
                                            Y = f
                                        }
                                }
                            }
                            var m = i.alternate;
                            if (m !== null) {
                                var p = m.child;
                                if (p !== null) {
                                    m.child = null;
                                    do {
                                        var x = p.sibling;
                                        p.sibling = null,
                                        p = x
                                    } while (p !== null)
                                }
                            }
                            Y = i
                        }
                    }
                    if (i.subtreeFlags & 2064 && a !== null)
                        a.return = i,
                        Y = a;
                    else
                        e: for (; Y !== null; ) {
                            if (i = Y,
                            i.flags & 2048)
                                switch (i.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    ei(9, i, i.return)
                                }
                            var y = i.sibling;
                            if (y !== null) {
                                y.return = i.return,
                                Y = y;
                                break e
                            }
                            Y = i.return
                        }
                }
                var v = s.current;
                for (Y = v; Y !== null; ) {
                    a = Y;
                    var E = a.child;
                    if (a.subtreeFlags & 2064 && E !== null)
                        E.return = a,
                        Y = E;
                    else
                        e: for (a = v; Y !== null; ) {
                            if (o = Y,
                            o.flags & 2048)
                                try {
                                    switch (o.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Uo(9, o)
                                    }
                                } catch (L) {
                                    De(o, o.return, L)
                                }
                            if (o === a) {
                                Y = null;
                                break e
                            }
                            var T = o.sibling;
                            if (T !== null) {
                                T.return = o.return,
                                Y = T;
                                break e
                            }
                            Y = o.return
                        }
                }
                if (de = r,
                dn(),
                us && typeof us.onPostCommitFiberRoot == "function")
                    try {
                        us.onPostCommitFiberRoot(ko, s)
                    } catch {}
                n = !0
            }
            return n
        } finally {
            me = t,
            Ut.transition = e
        }
    }
    return !1
}
function Gh(s, e, t) {
    e = Sr(t, e),
    e = Qg(s, e, 1),
    s = Js(s, e, 1),
    e = ct(),
    s !== null && (Di(s, 1, e),
    Et(s, e))
}
function De(s, e, t) {
    if (s.tag === 3)
        Gh(s, s, t);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                Gh(e, s, t);
                break
            } else if (e.tag === 1) {
                var n = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (en === null || !en.has(n))) {
                    s = Sr(t, s),
                    s = Jg(e, s, 1),
                    e = Js(e, s, 1),
                    s = ct(),
                    e !== null && (Di(e, 1, s),
                    Et(e, s));
                    break
                }
            }
            e = e.return
        }
}
function Nv(s, e, t) {
    var n = s.pingCache;
    n !== null && n.delete(e),
    e = ct(),
    s.pingedLanes |= s.suspendedLanes & t,
    Ye === s && (Je & t) === t && (He === 4 || He === 3 && (Je & 130023424) === Je && 500 > Me() - qu ? An(s, 0) : Zu |= t),
    Et(s, e)
}
function vp(s, e) {
    e === 0 && (s.mode & 1 ? (e = zi,
    zi <<= 1,
    !(zi & 130023424) && (zi = 4194304)) : e = 1);
    var t = ct();
    s = Ps(s, e),
    s !== null && (Di(s, e, t),
    Et(s, t))
}
function Ov(s) {
    var e = s.memoizedState
      , t = 0;
    e !== null && (t = e.retryLane),
    vp(s, t)
}
function Mv(s, e) {
    var t = 0;
    switch (s.tag) {
    case 13:
        var n = s.stateNode
          , r = s.memoizedState;
        r !== null && (t = r.retryLane);
        break;
    case 19:
        n = s.stateNode;
        break;
    default:
        throw Error(H(314))
    }
    n !== null && n.delete(e),
    vp(s, t)
}
var Ep;
Ep = function(s, e, t) {
    if (s !== null)
        if (s.memoizedProps !== e.pendingProps || xt.current)
            pt = !0;
        else {
            if (!(s.lanes & t) && !(e.flags & 128))
                return pt = !1,
                Lv(s, e, t);
            pt = !!(s.flags & 131072)
        }
    else
        pt = !1,
        Ie && e.flags & 1048576 && Ig(e, so, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var n = e.type;
        ka(s, e),
        s = e.pendingProps;
        var r = yr(e, it.current);
        lr(e, t),
        r = Hu(null, e, n, s, r, t);
        var i = Ku();
        return e.flags |= 1,
        typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        vt(n) ? (i = !0,
        eo(e)) : i = !1,
        e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null,
        Bu(e),
        r.updater = Fo,
        e.stateNode = r,
        r._reactInternals = e,
        Cc(e, n, s, t),
        e = Dc(null, e, n, !0, i, t)) : (e.tag = 0,
        Ie && i && Du(e),
        at(null, e, r, t),
        e = e.child),
        e;
    case 16:
        n = e.elementType;
        e: {
            switch (ka(s, e),
            s = e.pendingProps,
            r = n._init,
            n = r(n._payload),
            e.type = n,
            r = e.tag = Uv(n),
            s = Xt(n, s),
            r) {
            case 0:
                e = _c(null, e, n, s, t);
                break e;
            case 1:
                e = Dh(null, e, n, s, t);
                break e;
            case 11:
                e = kh(null, e, n, s, t);
                break e;
            case 14:
                e = _h(null, e, n, Xt(n.type, s), t);
                break e
            }
            throw Error(H(306, n, ""))
        }
        return e;
    case 0:
        return n = e.type,
        r = e.pendingProps,
        r = e.elementType === n ? r : Xt(n, r),
        _c(s, e, n, r, t);
    case 1:
        return n = e.type,
        r = e.pendingProps,
        r = e.elementType === n ? r : Xt(n, r),
        Dh(s, e, n, r, t);
    case 3:
        e: {
            if (np(e),
            s === null)
                throw Error(H(387));
            n = e.pendingProps,
            i = e.memoizedState,
            r = i.element,
            kg(s, e),
            io(e, n, null, t);
            var a = e.memoizedState;
            if (n = a.element,
            i.isDehydrated)
                if (i = {
                    element: n,
                    isDehydrated: !1,
                    cache: a.cache,
                    pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
                    transitions: a.transitions
                },
                e.updateQueue.baseState = i,
                e.memoizedState = i,
                e.flags & 256) {
                    r = Sr(Error(H(423)), e),
                    e = Ph(s, e, n, t, r);
                    break e
                } else if (n !== r) {
                    r = Sr(Error(H(424)), e),
                    e = Ph(s, e, n, t, r);
                    break e
                } else
                    for (bt = Qs(e.stateNode.containerInfo.firstChild),
                    Rt = e,
                    Ie = !0,
                    qt = null,
                    t = wg(e, null, n, t),
                    e.child = t; t; )
                        t.flags = t.flags & -3 | 4096,
                        t = t.sibling;
            else {
                if (xr(),
                n === r) {
                    e = Ns(s, e, t);
                    break e
                }
                at(s, e, n, t)
            }
            e = e.child
        }
        return e;
    case 5:
        return _g(e),
        s === null && bc(e),
        n = e.type,
        r = e.pendingProps,
        i = s !== null ? s.memoizedProps : null,
        a = r.children,
        Sc(n, r) ? a = null : i !== null && Sc(n, i) && (e.flags |= 32),
        sp(s, e),
        at(s, e, a, t),
        e.child;
    case 6:
        return s === null && bc(e),
        null;
    case 13:
        return rp(s, e, t);
    case 4:
        return $u(e, e.stateNode.containerInfo),
        n = e.pendingProps,
        s === null ? e.child = vr(e, null, n, t) : at(s, e, n, t),
        e.child;
    case 11:
        return n = e.type,
        r = e.pendingProps,
        r = e.elementType === n ? r : Xt(n, r),
        kh(s, e, n, r, t);
    case 7:
        return at(s, e, e.pendingProps, t),
        e.child;
    case 8:
        return at(s, e, e.pendingProps.children, t),
        e.child;
    case 12:
        return at(s, e, e.pendingProps.children, t),
        e.child;
    case 10:
        e: {
            if (n = e.type._context,
            r = e.pendingProps,
            i = e.memoizedProps,
            a = r.value,
            ve(no, n._currentValue),
            n._currentValue = a,
            i !== null)
                if (es(i.value, a)) {
                    if (i.children === r.children && !xt.current) {
                        e = Ns(s, e, t);
                        break e
                    }
                } else
                    for (i = e.child,
                    i !== null && (i.return = e); i !== null; ) {
                        var o = i.dependencies;
                        if (o !== null) {
                            a = i.child;
                            for (var l = o.firstContext; l !== null; ) {
                                if (l.context === n) {
                                    if (i.tag === 1) {
                                        l = Cs(-1, t & -t),
                                        l.tag = 2;
                                        var c = i.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var u = c.pending;
                                            u === null ? l.next = l : (l.next = u.next,
                                            u.next = l),
                                            c.pending = l
                                        }
                                    }
                                    i.lanes |= t,
                                    l = i.alternate,
                                    l !== null && (l.lanes |= t),
                                    Rc(i.return, t, e),
                                    o.lanes |= t;
                                    break
                                }
                                l = l.next
                            }
                        } else if (i.tag === 10)
                            a = i.type === e.type ? null : i.child;
                        else if (i.tag === 18) {
                            if (a = i.return,
                            a === null)
                                throw Error(H(341));
                            a.lanes |= t,
                            o = a.alternate,
                            o !== null && (o.lanes |= t),
                            Rc(a, t, e),
                            a = i.sibling
                        } else
                            a = i.child;
                        if (a !== null)
                            a.return = i;
                        else
                            for (a = i; a !== null; ) {
                                if (a === e) {
                                    a = null;
                                    break
                                }
                                if (i = a.sibling,
                                i !== null) {
                                    i.return = a.return,
                                    a = i;
                                    break
                                }
                                a = a.return
                            }
                        i = a
                    }
            at(s, e, r.children, t),
            e = e.child
        }
        return e;
    case 9:
        return r = e.type,
        n = e.pendingProps.children,
        lr(e, t),
        r = Bt(r),
        n = n(r),
        e.flags |= 1,
        at(s, e, n, t),
        e.child;
    case 14:
        return n = e.type,
        r = Xt(n, e.pendingProps),
        r = Xt(n.type, r),
        _h(s, e, n, r, t);
    case 15:
        return ep(s, e, e.type, e.pendingProps, t);
    case 17:
        return n = e.type,
        r = e.pendingProps,
        r = e.elementType === n ? r : Xt(n, r),
        ka(s, e),
        e.tag = 1,
        vt(n) ? (s = !0,
        eo(e)) : s = !1,
        lr(e, t),
        qg(e, n, r),
        Cc(e, n, r, t),
        Dc(null, e, n, !0, s, t);
    case 19:
        return ip(s, e, t);
    case 22:
        return tp(s, e, t)
    }
    throw Error(H(156, e.tag))
}
;
function Sp(s, e) {
    return Ym(s, e)
}
function Fv(s, e, t, n) {
    this.tag = s,
    this.key = t,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = n,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Mt(s, e, t, n) {
    return new Fv(s,e,t,n)
}
function td(s) {
    return s = s.prototype,
    !(!s || !s.isReactComponent)
}
function Uv(s) {
    if (typeof s == "function")
        return td(s) ? 1 : 0;
    if (s != null) {
        if (s = s.$$typeof,
        s === Eu)
            return 11;
        if (s === Su)
            return 14
    }
    return 2
}
function sn(s, e) {
    var t = s.alternate;
    return t === null ? (t = Mt(s.tag, e, s.key, s.mode),
    t.elementType = s.elementType,
    t.type = s.type,
    t.stateNode = s.stateNode,
    t.alternate = s,
    s.alternate = t) : (t.pendingProps = e,
    t.type = s.type,
    t.flags = 0,
    t.subtreeFlags = 0,
    t.deletions = null),
    t.flags = s.flags & 14680064,
    t.childLanes = s.childLanes,
    t.lanes = s.lanes,
    t.child = s.child,
    t.memoizedProps = s.memoizedProps,
    t.memoizedState = s.memoizedState,
    t.updateQueue = s.updateQueue,
    e = s.dependencies,
    t.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    t.sibling = s.sibling,
    t.index = s.index,
    t.ref = s.ref,
    t
}
function Pa(s, e, t, n, r, i) {
    var a = 2;
    if (n = s,
    typeof s == "function")
        td(s) && (a = 1);
    else if (typeof s == "string")
        a = 5;
    else
        e: switch (s) {
        case Wn:
            return bn(t.children, r, i, e);
        case vu:
            a = 8,
            r |= 8;
            break;
        case Jl:
            return s = Mt(12, t, e, r | 2),
            s.elementType = Jl,
            s.lanes = i,
            s;
        case ec:
            return s = Mt(13, t, e, r),
            s.elementType = ec,
            s.lanes = i,
            s;
        case tc:
            return s = Mt(19, t, e, r),
            s.elementType = tc,
            s.lanes = i,
            s;
        case _m:
            return $o(t, r, i, e);
        default:
            if (typeof s == "object" && s !== null)
                switch (s.$$typeof) {
                case Cm:
                    a = 10;
                    break e;
                case km:
                    a = 9;
                    break e;
                case Eu:
                    a = 11;
                    break e;
                case Su:
                    a = 14;
                    break e;
                case js:
                    a = 16,
                    n = null;
                    break e
                }
            throw Error(H(130, s == null ? s : typeof s, ""))
        }
    return e = Mt(a, t, e, r),
    e.elementType = s,
    e.type = n,
    e.lanes = i,
    e
}
function bn(s, e, t, n) {
    return s = Mt(7, s, n, e),
    s.lanes = t,
    s
}
function $o(s, e, t, n) {
    return s = Mt(22, s, n, e),
    s.elementType = _m,
    s.lanes = t,
    s.stateNode = {
        isHidden: !1
    },
    s
}
function Il(s, e, t) {
    return s = Mt(6, s, null, e),
    s.lanes = t,
    s
}
function Al(s, e, t) {
    return e = Mt(4, s.children !== null ? s.children : [], s.key, e),
    e.lanes = t,
    e.stateNode = {
        containerInfo: s.containerInfo,
        pendingChildren: null,
        implementation: s.implementation
    },
    e
}
function Bv(s, e, t, n, r) {
    this.tag = e,
    this.containerInfo = s,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = il(0),
    this.expirationTimes = il(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = il(0),
    this.identifierPrefix = n,
    this.onRecoverableError = r,
    this.mutableSourceEagerHydrationData = null
}
function sd(s, e, t, n, r, i, a, o, l) {
    return s = new Bv(s,e,t,o,l),
    e === 1 ? (e = 1,
    i === !0 && (e |= 8)) : e = 0,
    i = Mt(3, null, null, e),
    s.current = i,
    i.stateNode = s,
    i.memoizedState = {
        element: n,
        isDehydrated: t,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    Bu(i),
    s
}
function $v(s, e, t) {
    var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: Kn,
        key: n == null ? null : "" + n,
        children: s,
        containerInfo: e,
        implementation: t
    }
}
function Tp(s) {
    if (!s)
        return an;
    s = s._reactInternals;
    e: {
        if (On(s) !== s || s.tag !== 1)
            throw Error(H(170));
        var e = s;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (vt(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(H(171))
    }
    if (s.tag === 1) {
        var t = s.type;
        if (vt(t))
            return Tg(s, t, e)
    }
    return e
}
function Lp(s, e, t, n, r, i, a, o, l) {
    return s = sd(t, n, !0, s, r, i, a, o, l),
    s.context = Tp(null),
    t = s.current,
    n = ct(),
    r = tn(t),
    i = Cs(n, r),
    i.callback = e ?? null,
    Js(t, i, r),
    s.current.lanes = r,
    Di(s, r, n),
    Et(s, n),
    s
}
function jo(s, e, t, n) {
    var r = e.current
      , i = ct()
      , a = tn(r);
    return t = Tp(t),
    e.context === null ? e.context = t : e.pendingContext = t,
    e = Cs(i, a),
    e.payload = {
        element: s
    },
    n = n === void 0 ? null : n,
    n !== null && (e.callback = n),
    s = Js(r, e, a),
    s !== null && (Jt(s, r, a, i),
    Ra(s, r, a)),
    a
}
function mo(s) {
    if (s = s.current,
    !s.child)
        return null;
    switch (s.child.tag) {
    case 5:
        return s.child.stateNode;
    default:
        return s.child.stateNode
    }
}
function Vh(s, e) {
    if (s = s.memoizedState,
    s !== null && s.dehydrated !== null) {
        var t = s.retryLane;
        s.retryLane = t !== 0 && t < e ? t : e
    }
}
function nd(s, e) {
    Vh(s, e),
    (s = s.alternate) && Vh(s, e)
}
function jv() {
    return null
}
var Ip = typeof reportError == "function" ? reportError : function(s) {
    console.error(s)
}
;
function rd(s) {
    this._internalRoot = s
}
Go.prototype.render = rd.prototype.render = function(s) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(H(409));
    jo(s, e, null, null)
}
;
Go.prototype.unmount = rd.prototype.unmount = function() {
    var s = this._internalRoot;
    if (s !== null) {
        this._internalRoot = null;
        var e = s.containerInfo;
        Dn(function() {
            jo(null, s, null, null)
        }),
        e[Ds] = null
    }
}
;
function Go(s) {
    this._internalRoot = s
}
Go.prototype.unstable_scheduleHydration = function(s) {
    if (s) {
        var e = tg();
        s = {
            blockedOn: null,
            target: s,
            priority: e
        };
        for (var t = 0; t < Ks.length && e !== 0 && e < Ks[t].priority; t++)
            ;
        Ks.splice(t, 0, s),
        t === 0 && ng(s)
    }
}
;
function id(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11)
}
function Vo(s) {
    return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11 && (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "))
}
function Hh() {}
function Gv(s, e, t, n, r) {
    if (r) {
        if (typeof n == "function") {
            var i = n;
            n = function() {
                var c = mo(a);
                i.call(c)
            }
        }
        var a = Lp(e, n, s, 0, null, !1, !1, "", Hh);
        return s._reactRootContainer = a,
        s[Ds] = a.current,
        mi(s.nodeType === 8 ? s.parentNode : s),
        Dn(),
        a
    }
    for (; r = s.lastChild; )
        s.removeChild(r);
    if (typeof n == "function") {
        var o = n;
        n = function() {
            var c = mo(l);
            o.call(c)
        }
    }
    var l = sd(s, 0, !1, null, null, !1, !1, "", Hh);
    return s._reactRootContainer = l,
    s[Ds] = l.current,
    mi(s.nodeType === 8 ? s.parentNode : s),
    Dn(function() {
        jo(e, l, t, n)
    }),
    l
}
function Ho(s, e, t, n, r) {
    var i = t._reactRootContainer;
    if (i) {
        var a = i;
        if (typeof r == "function") {
            var o = r;
            r = function() {
                var l = mo(a);
                o.call(l)
            }
        }
        jo(e, a, s, r)
    } else
        a = Gv(t, e, s, r, n);
    return mo(a)
}
Jm = function(s) {
    switch (s.tag) {
    case 3:
        var e = s.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var t = Kr(e.pendingLanes);
            t !== 0 && (Iu(e, t | 1),
            Et(e, Me()),
            !(de & 6) && (Tr = Me() + 500,
            dn()))
        }
        break;
    case 13:
        Dn(function() {
            var n = Ps(s, 1);
            if (n !== null) {
                var r = ct();
                Jt(n, s, 1, r)
            }
        }),
        nd(s, 1)
    }
}
;
Au = function(s) {
    if (s.tag === 13) {
        var e = Ps(s, 134217728);
        if (e !== null) {
            var t = ct();
            Jt(e, s, 134217728, t)
        }
        nd(s, 134217728)
    }
}
;
eg = function(s) {
    if (s.tag === 13) {
        var e = tn(s)
          , t = Ps(s, e);
        if (t !== null) {
            var n = ct();
            Jt(t, s, e, n)
        }
        nd(s, e)
    }
}
;
tg = function() {
    return me
}
;
sg = function(s, e) {
    var t = me;
    try {
        return me = s,
        e()
    } finally {
        me = t
    }
}
;
dc = function(s, e, t) {
    switch (e) {
    case "input":
        if (rc(s, t),
        e = t.name,
        t.type === "radio" && e != null) {
            for (t = s; t.parentNode; )
                t = t.parentNode;
            for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < t.length; e++) {
                var n = t[e];
                if (n !== s && n.form === s.form) {
                    var r = No(n);
                    if (!r)
                        throw Error(H(90));
                    Pm(n),
                    rc(n, r)
                }
            }
        }
        break;
    case "textarea":
        Om(s, t);
        break;
    case "select":
        e = t.value,
        e != null && rr(s, !!t.multiple, e, !1)
    }
}
;
Gm = Qu;
Vm = Dn;
var Vv = {
    usingClientEntryPoint: !1,
    Events: [Ni, Zn, No, $m, jm, Qu]
}
  , $r = {
    findFiberByHostInstance: Tn,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , Hv = {
    bundleType: $r.bundleType,
    version: $r.version,
    rendererPackageName: $r.rendererPackageName,
    rendererConfig: $r.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Ms.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(s) {
        return s = Wm(s),
        s === null ? null : s.stateNode
    },
    findFiberByHostInstance: $r.findFiberByHostInstance || jv,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var ra = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!ra.isDisabled && ra.supportsFiber)
        try {
            ko = ra.inject(Hv),
            us = ra
        } catch {}
}
kt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Vv;
kt.createPortal = function(s, e) {
    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!id(e))
        throw Error(H(200));
    return $v(s, e, null, t)
}
;
kt.createRoot = function(s, e) {
    if (!id(s))
        throw Error(H(299));
    var t = !1
      , n = ""
      , r = Ip;
    return e != null && (e.unstable_strictMode === !0 && (t = !0),
    e.identifierPrefix !== void 0 && (n = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    e = sd(s, 1, !1, null, null, t, !1, n, r),
    s[Ds] = e.current,
    mi(s.nodeType === 8 ? s.parentNode : s),
    new rd(e)
}
;
kt.findDOMNode = function(s) {
    if (s == null)
        return null;
    if (s.nodeType === 1)
        return s;
    var e = s._reactInternals;
    if (e === void 0)
        throw typeof s.render == "function" ? Error(H(188)) : (s = Object.keys(s).join(","),
        Error(H(268, s)));
    return s = Wm(e),
    s = s === null ? null : s.stateNode,
    s
}
;
kt.flushSync = function(s) {
    return Dn(s)
}
;
kt.hydrate = function(s, e, t) {
    if (!Vo(e))
        throw Error(H(200));
    return Ho(null, s, e, !0, t)
}
;
kt.hydrateRoot = function(s, e, t) {
    if (!id(s))
        throw Error(H(405));
    var n = t != null && t.hydratedSources || null
      , r = !1
      , i = ""
      , a = Ip;
    if (t != null && (t.unstable_strictMode === !0 && (r = !0),
    t.identifierPrefix !== void 0 && (i = t.identifierPrefix),
    t.onRecoverableError !== void 0 && (a = t.onRecoverableError)),
    e = Lp(e, null, s, 1, t ?? null, r, !1, i, a),
    s[Ds] = e.current,
    mi(s),
    n)
        for (s = 0; s < n.length; s++)
            t = n[s],
            r = t._getVersion,
            r = r(t._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r);
    return new Go(e)
}
;
kt.render = function(s, e, t) {
    if (!Vo(e))
        throw Error(H(200));
    return Ho(null, s, e, !1, t)
}
;
kt.unmountComponentAtNode = function(s) {
    if (!Vo(s))
        throw Error(H(40));
    return s._reactRootContainer ? (Dn(function() {
        Ho(null, null, s, !1, function() {
            s._reactRootContainer = null,
            s[Ds] = null
        })
    }),
    !0) : !1
}
;
kt.unstable_batchedUpdates = Qu;
kt.unstable_renderSubtreeIntoContainer = function(s, e, t, n) {
    if (!Vo(t))
        throw Error(H(200));
    if (s == null || s._reactInternals === void 0)
        throw Error(H(38));
    return Ho(s, e, t, !1, n)
}
;
kt.version = "18.3.1-next-f1338f8080-20240426";
function Ap() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Ap)
        } catch (s) {
            console.error(s)
        }
}
Ap(),
Am.exports = kt;
var Kv = Am.exports, bp, Kh = Kv;
bp = Kh.createRoot,
Kh.hydrateRoot;
/**
 * react-router v7.8.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var Wh = "popstate";
function Wv(s={}) {
    function e(n, r) {
        let {pathname: i, search: a, hash: o} = n.location;
        return Hc("", {
            pathname: i,
            search: a,
            hash: o
        }, r.state && r.state.usr || null, r.state && r.state.key || "default")
    }
    function t(n, r) {
        return typeof r == "string" ? r : Li(r)
    }
    return Yv(e, t, null, s)
}
function we(s, e) {
    if (s === !1 || s === null || typeof s > "u")
        throw new Error(e)
}
function hs(s, e) {
    if (!s) {
        typeof console < "u" && console.warn(e);
        try {
            throw new Error(e)
        } catch {}
    }
}
function zv() {
    return Math.random().toString(36).substring(2, 10)
}
function zh(s, e) {
    return {
        usr: s.state,
        key: s.key,
        idx: e
    }
}
function Hc(s, e, t=null, n) {
    return {
        pathname: typeof s == "string" ? s : s.pathname,
        search: "",
        hash: "",
        ...typeof e == "string" ? wr(e) : e,
        state: t,
        key: e && e.key || n || zv()
    }
}
function Li({pathname: s="/", search: e="", hash: t=""}) {
    return e && e !== "?" && (s += e.charAt(0) === "?" ? e : "?" + e),
    t && t !== "#" && (s += t.charAt(0) === "#" ? t : "#" + t),
    s
}
function wr(s) {
    let e = {};
    if (s) {
        let t = s.indexOf("#");
        t >= 0 && (e.hash = s.substring(t),
        s = s.substring(0, t));
        let n = s.indexOf("?");
        n >= 0 && (e.search = s.substring(n),
        s = s.substring(0, n)),
        s && (e.pathname = s)
    }
    return e
}
function Yv(s, e, t, n={}) {
    let {window: r=document.defaultView, v5Compat: i=!1} = n
      , a = r.history
      , o = "POP"
      , l = null
      , c = u();
    c == null && (c = 0,
    a.replaceState({
        ...a.state,
        idx: c
    }, ""));
    function u() {
        return (a.state || {
            idx: null
        }).idx
    }
    function d() {
        o = "POP";
        let x = u()
          , y = x == null ? null : x - c;
        c = x,
        l && l({
            action: o,
            location: p.location,
            delta: y
        })
    }
    function h(x, y) {
        o = "PUSH";
        let v = Hc(p.location, x, y);
        c = u() + 1;
        let E = zh(v, c)
          , T = p.createHref(v);
        try {
            a.pushState(E, "", T)
        } catch (L) {
            if (L instanceof DOMException && L.name === "DataCloneError")
                throw L;
            r.location.assign(T)
        }
        i && l && l({
            action: o,
            location: p.location,
            delta: 1
        })
    }
    function f(x, y) {
        o = "REPLACE";
        let v = Hc(p.location, x, y);
        c = u();
        let E = zh(v, c)
          , T = p.createHref(v);
        a.replaceState(E, "", T),
        i && l && l({
            action: o,
            location: p.location,
            delta: 0
        })
    }
    function m(x) {
        return Xv(x)
    }
    let p = {
        get action() {
            return o
        },
        get location() {
            return s(r, a)
        },
        listen(x) {
            if (l)
                throw new Error("A history only accepts one active listener");
            return r.addEventListener(Wh, d),
            l = x,
            () => {
                r.removeEventListener(Wh, d),
                l = null
            }
        },
        createHref(x) {
            return e(r, x)
        },
        createURL: m,
        encodeLocation(x) {
            let y = m(x);
            return {
                pathname: y.pathname,
                search: y.search,
                hash: y.hash
            }
        },
        push: h,
        replace: f,
        go(x) {
            return a.go(x)
        }
    };
    return p
}
function Xv(s, e=!1) {
    let t = "http://localhost";
    typeof window < "u" && (t = window.location.origin !== "null" ? window.location.origin : window.location.href),
    we(t, "No window.location.(origin|href) available to create URL");
    let n = typeof s == "string" ? s : Li(s);
    return n = n.replace(/ $/, "%20"),
    !e && n.startsWith("//") && (n = t + n),
    new URL(n,t)
}
function Rp(s, e, t="/") {
    return Zv(s, e, t, !1)
}
function Zv(s, e, t, n) {
    let r = typeof e == "string" ? wr(e) : e
      , i = Os(r.pathname || "/", t);
    if (i == null)
        return null;
    let a = wp(s);
    qv(a);
    let o = null;
    for (let l = 0; o == null && l < a.length; ++l) {
        let c = lE(i);
        o = aE(a[l], c, n)
    }
    return o
}
function wp(s, e=[], t=[], n="", r=!1) {
    let i = (a, o, l=r, c) => {
        let u = {
            relativePath: c === void 0 ? a.path || "" : c,
            caseSensitive: a.caseSensitive === !0,
            childrenIndex: o,
            route: a
        };
        if (u.relativePath.startsWith("/")) {
            if (!u.relativePath.startsWith(n) && l)
                return;
            we(u.relativePath.startsWith(n), `Absolute route path "${u.relativePath}" nested under path "${n}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),
            u.relativePath = u.relativePath.slice(n.length)
        }
        let d = ks([n, u.relativePath])
          , h = t.concat(u);
        a.children && a.children.length > 0 && (we(a.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${d}".`),
        wp(a.children, e, h, d, l)),
        !(a.path == null && !a.index) && e.push({
            path: d,
            score: rE(d, a.index),
            routesMeta: h
        })
    }
    ;
    return s.forEach( (a, o) => {
        var l;
        if (a.path === "" || !((l = a.path) != null && l.includes("?")))
            i(a, o);
        else
            for (let c of Cp(a.path))
                i(a, o, !0, c)
    }
    ),
    e
}
function Cp(s) {
    let e = s.split("/");
    if (e.length === 0)
        return [];
    let[t,...n] = e
      , r = t.endsWith("?")
      , i = t.replace(/\?$/, "");
    if (n.length === 0)
        return r ? [i, ""] : [i];
    let a = Cp(n.join("/"))
      , o = [];
    return o.push(...a.map(l => l === "" ? i : [i, l].join("/"))),
    r && o.push(...a),
    o.map(l => s.startsWith("/") && l === "" ? "/" : l)
}
function qv(s) {
    s.sort( (e, t) => e.score !== t.score ? t.score - e.score : iE(e.routesMeta.map(n => n.childrenIndex), t.routesMeta.map(n => n.childrenIndex)))
}
var Qv = /^:[\w-]+$/
  , Jv = 3
  , eE = 2
  , tE = 1
  , sE = 10
  , nE = -2
  , Yh = s => s === "*";
function rE(s, e) {
    let t = s.split("/")
      , n = t.length;
    return t.some(Yh) && (n += nE),
    e && (n += eE),
    t.filter(r => !Yh(r)).reduce( (r, i) => r + (Qv.test(i) ? Jv : i === "" ? tE : sE), n)
}
function iE(s, e) {
    return s.length === e.length && s.slice(0, -1).every( (n, r) => n === e[r]) ? s[s.length - 1] - e[e.length - 1] : 0
}
function aE(s, e, t=!1) {
    let {routesMeta: n} = s
      , r = {}
      , i = "/"
      , a = [];
    for (let o = 0; o < n.length; ++o) {
        let l = n[o]
          , c = o === n.length - 1
          , u = i === "/" ? e : e.slice(i.length) || "/"
          , d = go({
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: c
        }, u)
          , h = l.route;
        if (!d && c && t && !n[n.length - 1].route.index && (d = go({
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: !1
        }, u)),
        !d)
            return null;
        Object.assign(r, d.params),
        a.push({
            params: r,
            pathname: ks([i, d.pathname]),
            pathnameBase: hE(ks([i, d.pathnameBase])),
            route: h
        }),
        d.pathnameBase !== "/" && (i = ks([i, d.pathnameBase]))
    }
    return a
}
function go(s, e) {
    typeof s == "string" && (s = {
        path: s,
        caseSensitive: !1,
        end: !0
    });
    let[t,n] = oE(s.path, s.caseSensitive, s.end)
      , r = e.match(t);
    if (!r)
        return null;
    let i = r[0]
      , a = i.replace(/(.)\/+$/, "$1")
      , o = r.slice(1);
    return {
        params: n.reduce( (c, {paramName: u, isOptional: d}, h) => {
            if (u === "*") {
                let m = o[h] || "";
                a = i.slice(0, i.length - m.length).replace(/(.)\/+$/, "$1")
            }
            const f = o[h];
            return d && !f ? c[u] = void 0 : c[u] = (f || "").replace(/%2F/g, "/"),
            c
        }
        , {}),
        pathname: i,
        pathnameBase: a,
        pattern: s
    }
}
function oE(s, e=!1, t=!0) {
    hs(s === "*" || !s.endsWith("*") || s.endsWith("/*"), `Route path "${s}" will be treated as if it were "${s.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${s.replace(/\*$/, "/*")}".`);
    let n = []
      , r = "^" + s.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (a, o, l) => (n.push({
        paramName: o,
        isOptional: l != null
    }),
    l ? "/?([^\\/]+)?" : "/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
    return s.endsWith("*") ? (n.push({
        paramName: "*"
    }),
    r += s === "*" || s === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? r += "\\/*$" : s !== "" && s !== "/" && (r += "(?:(?=\\/|$))"),
    [new RegExp(r,e ? void 0 : "i"), n]
}
function lE(s) {
    try {
        return s.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/")
    } catch (e) {
        return hs(!1, `The URL path "${s}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),
        s
    }
}
function Os(s, e) {
    if (e === "/")
        return s;
    if (!s.toLowerCase().startsWith(e.toLowerCase()))
        return null;
    let t = e.endsWith("/") ? e.length - 1 : e.length
      , n = s.charAt(t);
    return n && n !== "/" ? null : s.slice(t) || "/"
}
function cE(s, e="/") {
    let {pathname: t, search: n="", hash: r=""} = typeof s == "string" ? wr(s) : s;
    return {
        pathname: t ? t.startsWith("/") ? t : uE(t, e) : e,
        search: fE(n),
        hash: mE(r)
    }
}
function uE(s, e) {
    let t = e.replace(/\/+$/, "").split("/");
    return s.split("/").forEach(r => {
        r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r)
    }
    ),
    t.length > 1 ? t.join("/") : "/"
}
function bl(s, e, t, n) {
    return `Cannot include a '${s}' character in a manually specified \`to.${e}\` field [${JSON.stringify(n)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function dE(s) {
    return s.filter( (e, t) => t === 0 || e.route.path && e.route.path.length > 0)
}
function kp(s) {
    let e = dE(s);
    return e.map( (t, n) => n === e.length - 1 ? t.pathname : t.pathnameBase)
}
function _p(s, e, t, n=!1) {
    let r;
    typeof s == "string" ? r = wr(s) : (r = {
        ...s
    },
    we(!r.pathname || !r.pathname.includes("?"), bl("?", "pathname", "search", r)),
    we(!r.pathname || !r.pathname.includes("#"), bl("#", "pathname", "hash", r)),
    we(!r.search || !r.search.includes("#"), bl("#", "search", "hash", r)));
    let i = s === "" || r.pathname === "", a = i ? "/" : r.pathname, o;
    if (a == null)
        o = t;
    else {
        let d = e.length - 1;
        if (!n && a.startsWith("..")) {
            let h = a.split("/");
            for (; h[0] === ".."; )
                h.shift(),
                d -= 1;
            r.pathname = h.join("/")
        }
        o = d >= 0 ? e[d] : "/"
    }
    let l = cE(r, o)
      , c = a && a !== "/" && a.endsWith("/")
      , u = (i || a === ".") && t.endsWith("/");
    return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"),
    l
}
var ks = s => s.join("/").replace(/\/\/+/g, "/")
  , hE = s => s.replace(/\/+$/, "").replace(/^\/*/, "/")
  , fE = s => !s || s === "?" ? "" : s.startsWith("?") ? s : "?" + s
  , mE = s => !s || s === "#" ? "" : s.startsWith("#") ? s : "#" + s;
function gE(s) {
    return s != null && typeof s.status == "number" && typeof s.statusText == "string" && typeof s.internal == "boolean" && "data"in s
}
var Dp = ["POST", "PUT", "PATCH", "DELETE"];
new Set(Dp);
var pE = ["GET", ...Dp];
new Set(pE);
var Cr = w.createContext(null);
Cr.displayName = "DataRouter";
var Ko = w.createContext(null);
Ko.displayName = "DataRouterState";
w.createContext(!1);
var Pp = w.createContext({
    isTransitioning: !1
});
Pp.displayName = "ViewTransition";
var yE = w.createContext(new Map);
yE.displayName = "Fetchers";
var xE = w.createContext(null);
xE.displayName = "Await";
var gs = w.createContext(null);
gs.displayName = "Navigation";
var Mi = w.createContext(null);
Mi.displayName = "Location";
var ps = w.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
});
ps.displayName = "Route";
var ad = w.createContext(null);
ad.displayName = "RouteError";
function vE(s, {relative: e}={}) {
    we(Fi(), "useHref() may be used only in the context of a <Router> component.");
    let {basename: t, navigator: n} = w.useContext(gs)
      , {hash: r, pathname: i, search: a} = Ui(s, {
        relative: e
    })
      , o = i;
    return t !== "/" && (o = i === "/" ? t : ks([t, i])),
    n.createHref({
        pathname: o,
        search: a,
        hash: r
    })
}
function Fi() {
    return w.useContext(Mi) != null
}
function hn() {
    return we(Fi(), "useLocation() may be used only in the context of a <Router> component."),
    w.useContext(Mi).location
}
var Np = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function Op(s) {
    w.useContext(gs).static || w.useLayoutEffect(s)
}
function Mp() {
    let {isDataRoute: s} = w.useContext(ps);
    return s ? DE() : EE()
}
function EE() {
    we(Fi(), "useNavigate() may be used only in the context of a <Router> component.");
    let s = w.useContext(Cr)
      , {basename: e, navigator: t} = w.useContext(gs)
      , {matches: n} = w.useContext(ps)
      , {pathname: r} = hn()
      , i = JSON.stringify(kp(n))
      , a = w.useRef(!1);
    return Op( () => {
        a.current = !0
    }
    ),
    w.useCallback( (l, c={}) => {
        if (hs(a.current, Np),
        !a.current)
            return;
        if (typeof l == "number") {
            t.go(l);
            return
        }
        let u = _p(l, JSON.parse(i), r, c.relative === "path");
        s == null && e !== "/" && (u.pathname = u.pathname === "/" ? e : ks([e, u.pathname])),
        (c.replace ? t.replace : t.push)(u, c.state, c)
    }
    , [e, t, i, r, s])
}
w.createContext(null);
function Fp() {
    let {matches: s} = w.useContext(ps)
      , e = s[s.length - 1];
    return e ? e.params : {}
}
function Ui(s, {relative: e}={}) {
    let {matches: t} = w.useContext(ps)
      , {pathname: n} = hn()
      , r = JSON.stringify(kp(t));
    return w.useMemo( () => _p(s, JSON.parse(r), n, e === "path"), [s, r, n, e])
}
function SE(s, e) {
    return Up(s, e)
}
function Up(s, e, t, n, r) {
    var v;
    we(Fi(), "useRoutes() may be used only in the context of a <Router> component.");
    let {navigator: i} = w.useContext(gs)
      , {matches: a} = w.useContext(ps)
      , o = a[a.length - 1]
      , l = o ? o.params : {}
      , c = o ? o.pathname : "/"
      , u = o ? o.pathnameBase : "/"
      , d = o && o.route;
    {
        let E = d && d.path || "";
        Bp(c, !d || E.endsWith("*") || E.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${c}" (under <Route path="${E}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${E}"> to <Route path="${E === "/" ? "*" : `${E}/*`}">.`)
    }
    let h = hn(), f;
    if (e) {
        let E = typeof e == "string" ? wr(e) : e;
        we(u === "/" || ((v = E.pathname) == null ? void 0 : v.startsWith(u)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${u}" but pathname "${E.pathname}" was given in the \`location\` prop.`),
        f = E
    } else
        f = h;
    let m = f.pathname || "/"
      , p = m;
    if (u !== "/") {
        let E = u.replace(/^\//, "").split("/");
        p = "/" + m.replace(/^\//, "").split("/").slice(E.length).join("/")
    }
    let x = Rp(s, {
        pathname: p
    });
    hs(d || x != null, `No routes matched location "${f.pathname}${f.search}${f.hash}" `),
    hs(x == null || x[x.length - 1].route.element !== void 0 || x[x.length - 1].route.Component !== void 0 || x[x.length - 1].route.lazy !== void 0, `Matched leaf route at location "${f.pathname}${f.search}${f.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
    let y = bE(x && x.map(E => Object.assign({}, E, {
        params: Object.assign({}, l, E.params),
        pathname: ks([u, i.encodeLocation ? i.encodeLocation(E.pathname).pathname : E.pathname]),
        pathnameBase: E.pathnameBase === "/" ? u : ks([u, i.encodeLocation ? i.encodeLocation(E.pathnameBase).pathname : E.pathnameBase])
    })), a, t, n, r);
    return e && y ? w.createElement(Mi.Provider, {
        value: {
            location: {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
                ...f
            },
            navigationType: "POP"
        }
    }, y) : y
}
function TE() {
    let s = _E()
      , e = gE(s) ? `${s.status} ${s.statusText}` : s instanceof Error ? s.message : JSON.stringify(s)
      , t = s instanceof Error ? s.stack : null
      , n = "rgba(200,200,200, 0.5)"
      , r = {
        padding: "0.5rem",
        backgroundColor: n
    }
      , i = {
        padding: "2px 4px",
        backgroundColor: n
    }
      , a = null;
    return console.error("Error handled by React Router default ErrorBoundary:", s),
    a = w.createElement(w.Fragment, null, w.createElement("p", null, " Hey developer "), w.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", w.createElement("code", {
        style: i
    }, "ErrorBoundary"), " or", " ", w.createElement("code", {
        style: i
    }, "errorElement"), " prop on your route.")),
    w.createElement(w.Fragment, null, w.createElement("h2", null, "Unexpected Application Error!"), w.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, e), t ? w.createElement("pre", {
        style: r
    }, t) : null, a)
}
var LE = w.createElement(TE, null)
  , IE = class extends w.Component {
    constructor(s) {
        super(s),
        this.state = {
            location: s.location,
            revalidation: s.revalidation,
            error: s.error
        }
    }
    static getDerivedStateFromError(s) {
        return {
            error: s
        }
    }
    static getDerivedStateFromProps(s, e) {
        return e.location !== s.location || e.revalidation !== "idle" && s.revalidation === "idle" ? {
            error: s.error,
            location: s.location,
            revalidation: s.revalidation
        } : {
            error: s.error !== void 0 ? s.error : e.error,
            location: e.location,
            revalidation: s.revalidation || e.revalidation
        }
    }
    componentDidCatch(s, e) {
        this.props.unstable_onError ? this.props.unstable_onError(s, e) : console.error("React Router caught the following error during render", s)
    }
    render() {
        return this.state.error !== void 0 ? w.createElement(ps.Provider, {
            value: this.props.routeContext
        }, w.createElement(ad.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
;
function AE({routeContext: s, match: e, children: t}) {
    let n = w.useContext(Cr);
    return n && n.static && n.staticContext && (e.route.errorElement || e.route.ErrorBoundary) && (n.staticContext._deepestRenderedBoundaryId = e.route.id),
    w.createElement(ps.Provider, {
        value: s
    }, t)
}
function bE(s, e=[], t=null, n=null, r=null) {
    if (s == null) {
        if (!t)
            return null;
        if (t.errors)
            s = t.matches;
        else if (e.length === 0 && !t.initialized && t.matches.length > 0)
            s = t.matches;
        else
            return null
    }
    let i = s
      , a = t == null ? void 0 : t.errors;
    if (a != null) {
        let c = i.findIndex(u => u.route.id && (a == null ? void 0 : a[u.route.id]) !== void 0);
        we(c >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(a).join(",")}`),
        i = i.slice(0, Math.min(i.length, c + 1))
    }
    let o = !1
      , l = -1;
    if (t)
        for (let c = 0; c < i.length; c++) {
            let u = i[c];
            if ((u.route.HydrateFallback || u.route.hydrateFallbackElement) && (l = c),
            u.route.id) {
                let {loaderData: d, errors: h} = t
                  , f = u.route.loader && !d.hasOwnProperty(u.route.id) && (!h || h[u.route.id] === void 0);
                if (u.route.lazy || f) {
                    o = !0,
                    l >= 0 ? i = i.slice(0, l + 1) : i = [i[0]];
                    break
                }
            }
        }
    return i.reduceRight( (c, u, d) => {
        let h, f = !1, m = null, p = null;
        t && (h = a && u.route.id ? a[u.route.id] : void 0,
        m = u.route.errorElement || LE,
        o && (l < 0 && d === 0 ? (Bp("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"),
        f = !0,
        p = null) : l === d && (f = !0,
        p = u.route.hydrateFallbackElement || null)));
        let x = e.concat(i.slice(0, d + 1))
          , y = () => {
            let v;
            return h ? v = m : f ? v = p : u.route.Component ? v = w.createElement(u.route.Component, null) : u.route.element ? v = u.route.element : v = c,
            w.createElement(AE, {
                match: u,
                routeContext: {
                    outlet: c,
                    matches: x,
                    isDataRoute: t != null
                },
                children: v
            })
        }
        ;
        return t && (u.route.ErrorBoundary || u.route.errorElement || d === 0) ? w.createElement(IE, {
            location: t.location,
            revalidation: t.revalidation,
            component: m,
            error: h,
            children: y(),
            routeContext: {
                outlet: null,
                matches: x,
                isDataRoute: !0
            },
            unstable_onError: n
        }) : y()
    }
    , null)
}
function od(s) {
    return `${s} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function RE(s) {
    let e = w.useContext(Cr);
    return we(e, od(s)),
    e
}
function wE(s) {
    let e = w.useContext(Ko);
    return we(e, od(s)),
    e
}
function CE(s) {
    let e = w.useContext(ps);
    return we(e, od(s)),
    e
}
function ld(s) {
    let e = CE(s)
      , t = e.matches[e.matches.length - 1];
    return we(t.route.id, `${s} can only be used on routes that contain a unique "id"`),
    t.route.id
}
function kE() {
    return ld("useRouteId")
}
function _E() {
    var n;
    let s = w.useContext(ad)
      , e = wE("useRouteError")
      , t = ld("useRouteError");
    return s !== void 0 ? s : (n = e.errors) == null ? void 0 : n[t]
}
function DE() {
    let {router: s} = RE("useNavigate")
      , e = ld("useNavigate")
      , t = w.useRef(!1);
    return Op( () => {
        t.current = !0
    }
    ),
    w.useCallback(async (r, i={}) => {
        hs(t.current, Np),
        t.current && (typeof r == "number" ? s.navigate(r) : await s.navigate(r, {
            fromRouteId: e,
            ...i
        }))
    }
    , [s, e])
}
var Xh = {};
function Bp(s, e, t) {
    !e && !Xh[s] && (Xh[s] = !0,
    hs(!1, t))
}
w.memo(PE);
function PE({routes: s, future: e, state: t, unstable_onError: n}) {
    return Up(s, void 0, t, n, e)
}
function Wt(s) {
    we(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
}
function NE({basename: s="/", children: e=null, location: t, navigationType: n="POP", navigator: r, static: i=!1}) {
    we(!Fi(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let a = s.replace(/^\/*/, "/")
      , o = w.useMemo( () => ({
        basename: a,
        navigator: r,
        static: i,
        future: {}
    }), [a, r, i]);
    typeof t == "string" && (t = wr(t));
    let {pathname: l="/", search: c="", hash: u="", state: d=null, key: h="default"} = t
      , f = w.useMemo( () => {
        let m = Os(l, a);
        return m == null ? null : {
            location: {
                pathname: m,
                search: c,
                hash: u,
                state: d,
                key: h
            },
            navigationType: n
        }
    }
    , [a, l, c, u, d, h, n]);
    return hs(f != null, `<Router basename="${a}"> is not able to match the URL "${l}${c}${u}" because it does not start with the basename, so the <Router> won't render anything.`),
    f == null ? null : w.createElement(gs.Provider, {
        value: o
    }, w.createElement(Mi.Provider, {
        children: e,
        value: f
    }))
}
function OE({children: s, location: e}) {
    return SE(Kc(s), e)
}
function Kc(s, e=[]) {
    let t = [];
    return w.Children.forEach(s, (n, r) => {
        if (!w.isValidElement(n))
            return;
        let i = [...e, r];
        if (n.type === w.Fragment) {
            t.push.apply(t, Kc(n.props.children, i));
            return
        }
        we(n.type === Wt, `[${typeof n.type == "string" ? n.type : n.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),
        we(!n.props.index || !n.props.children, "An index route cannot have child routes.");
        let a = {
            id: n.props.id || i.join("-"),
            caseSensitive: n.props.caseSensitive,
            element: n.props.element,
            Component: n.props.Component,
            index: n.props.index,
            path: n.props.path,
            loader: n.props.loader,
            action: n.props.action,
            hydrateFallbackElement: n.props.hydrateFallbackElement,
            HydrateFallback: n.props.HydrateFallback,
            errorElement: n.props.errorElement,
            ErrorBoundary: n.props.ErrorBoundary,
            hasErrorBoundary: n.props.hasErrorBoundary === !0 || n.props.ErrorBoundary != null || n.props.errorElement != null,
            shouldRevalidate: n.props.shouldRevalidate,
            handle: n.props.handle,
            lazy: n.props.lazy
        };
        n.props.children && (a.children = Kc(n.props.children, i)),
        t.push(a)
    }
    ),
    t
}
var Na = "get"
  , Oa = "application/x-www-form-urlencoded";
function Wo(s) {
    return s != null && typeof s.tagName == "string"
}
function ME(s) {
    return Wo(s) && s.tagName.toLowerCase() === "button"
}
function FE(s) {
    return Wo(s) && s.tagName.toLowerCase() === "form"
}
function UE(s) {
    return Wo(s) && s.tagName.toLowerCase() === "input"
}
function BE(s) {
    return !!(s.metaKey || s.altKey || s.ctrlKey || s.shiftKey)
}
function $E(s, e) {
    return s.button === 0 && (!e || e === "_self") && !BE(s)
}
var ia = null;
function jE() {
    if (ia === null)
        try {
            new FormData(document.createElement("form"),0),
            ia = !1
        } catch {
            ia = !0
        }
    return ia
}
var GE = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function Rl(s) {
    return s != null && !GE.has(s) ? (hs(!1, `"${s}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Oa}"`),
    null) : s
}
function VE(s, e) {
    let t, n, r, i, a;
    if (FE(s)) {
        let o = s.getAttribute("action");
        n = o ? Os(o, e) : null,
        t = s.getAttribute("method") || Na,
        r = Rl(s.getAttribute("enctype")) || Oa,
        i = new FormData(s)
    } else if (ME(s) || UE(s) && (s.type === "submit" || s.type === "image")) {
        let o = s.form;
        if (o == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let l = s.getAttribute("formaction") || o.getAttribute("action");
        if (n = l ? Os(l, e) : null,
        t = s.getAttribute("formmethod") || o.getAttribute("method") || Na,
        r = Rl(s.getAttribute("formenctype")) || Rl(o.getAttribute("enctype")) || Oa,
        i = new FormData(o,s),
        !jE()) {
            let {name: c, type: u, value: d} = s;
            if (u === "image") {
                let h = c ? `${c}.` : "";
                i.append(`${h}x`, "0"),
                i.append(`${h}y`, "0")
            } else
                c && i.append(c, d)
        }
    } else {
        if (Wo(s))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        t = Na,
        n = null,
        r = Oa,
        a = s
    }
    return i && r === "text/plain" && (a = i,
    i = void 0),
    {
        action: n,
        method: t.toLowerCase(),
        encType: r,
        formData: i,
        body: a
    }
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function cd(s, e) {
    if (s === !1 || s === null || typeof s > "u")
        throw new Error(e)
}
function HE(s, e, t) {
    let n = typeof s == "string" ? new URL(s,typeof window > "u" ? "server://singlefetch/" : window.location.origin) : s;
    return n.pathname === "/" ? n.pathname = `_root.${t}` : e && Os(n.pathname, e) === "/" ? n.pathname = `${e.replace(/\/$/, "")}/_root.${t}` : n.pathname = `${n.pathname.replace(/\/$/, "")}.${t}`,
    n
}
async function KE(s, e) {
    if (s.id in e)
        return e[s.id];
    try {
        let t = await import(s.module);
        return e[s.id] = t,
        t
    } catch (t) {
        return console.error(`Error loading route module \`${s.module}\`, reloading page...`),
        console.error(t),
        window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
        window.location.reload(),
        new Promise( () => {}
        )
    }
}
function WE(s) {
    return s == null ? !1 : s.href == null ? s.rel === "preload" && typeof s.imageSrcSet == "string" && typeof s.imageSizes == "string" : typeof s.rel == "string" && typeof s.href == "string"
}
async function zE(s, e, t) {
    let n = await Promise.all(s.map(async r => {
        let i = e.routes[r.route.id];
        if (i) {
            let a = await KE(i, t);
            return a.links ? a.links() : []
        }
        return []
    }
    ));
    return qE(n.flat(1).filter(WE).filter(r => r.rel === "stylesheet" || r.rel === "preload").map(r => r.rel === "stylesheet" ? {
        ...r,
        rel: "prefetch",
        as: "style"
    } : {
        ...r,
        rel: "prefetch"
    }))
}
function Zh(s, e, t, n, r, i) {
    let a = (l, c) => t[c] ? l.route.id !== t[c].route.id : !0
      , o = (l, c) => {
        var u;
        return t[c].pathname !== l.pathname || ((u = t[c].route.path) == null ? void 0 : u.endsWith("*")) && t[c].params["*"] !== l.params["*"]
    }
    ;
    return i === "assets" ? e.filter( (l, c) => a(l, c) || o(l, c)) : i === "data" ? e.filter( (l, c) => {
        var d;
        let u = n.routes[l.route.id];
        if (!u || !u.hasLoader)
            return !1;
        if (a(l, c) || o(l, c))
            return !0;
        if (l.route.shouldRevalidate) {
            let h = l.route.shouldRevalidate({
                currentUrl: new URL(r.pathname + r.search + r.hash,window.origin),
                currentParams: ((d = t[0]) == null ? void 0 : d.params) || {},
                nextUrl: new URL(s,window.origin),
                nextParams: l.params,
                defaultShouldRevalidate: !0
            });
            if (typeof h == "boolean")
                return h
        }
        return !0
    }
    ) : []
}
function YE(s, e, {includeHydrateFallback: t}={}) {
    return XE(s.map(n => {
        let r = e.routes[n.route.id];
        if (!r)
            return [];
        let i = [r.module];
        return r.clientActionModule && (i = i.concat(r.clientActionModule)),
        r.clientLoaderModule && (i = i.concat(r.clientLoaderModule)),
        t && r.hydrateFallbackModule && (i = i.concat(r.hydrateFallbackModule)),
        r.imports && (i = i.concat(r.imports)),
        i
    }
    ).flat(1))
}
function XE(s) {
    return [...new Set(s)]
}
function ZE(s) {
    let e = {}
      , t = Object.keys(s).sort();
    for (let n of t)
        e[n] = s[n];
    return e
}
function qE(s, e) {
    let t = new Set;
    return new Set(e),
    s.reduce( (n, r) => {
        let i = JSON.stringify(ZE(r));
        return t.has(i) || (t.add(i),
        n.push({
            key: i,
            link: r
        })),
        n
    }
    , [])
}
function $p() {
    let s = w.useContext(Cr);
    return cd(s, "You must render this element inside a <DataRouterContext.Provider> element"),
    s
}
function QE() {
    let s = w.useContext(Ko);
    return cd(s, "You must render this element inside a <DataRouterStateContext.Provider> element"),
    s
}
var ud = w.createContext(void 0);
ud.displayName = "FrameworkContext";
function jp() {
    let s = w.useContext(ud);
    return cd(s, "You must render this element inside a <HydratedRouter> element"),
    s
}
function JE(s, e) {
    let t = w.useContext(ud)
      , [n,r] = w.useState(!1)
      , [i,a] = w.useState(!1)
      , {onFocus: o, onBlur: l, onMouseEnter: c, onMouseLeave: u, onTouchStart: d} = e
      , h = w.useRef(null);
    w.useEffect( () => {
        if (s === "render" && a(!0),
        s === "viewport") {
            let p = y => {
                y.forEach(v => {
                    a(v.isIntersecting)
                }
                )
            }
              , x = new IntersectionObserver(p,{
                threshold: .5
            });
            return h.current && x.observe(h.current),
            () => {
                x.disconnect()
            }
        }
    }
    , [s]),
    w.useEffect( () => {
        if (n) {
            let p = setTimeout( () => {
                a(!0)
            }
            , 100);
            return () => {
                clearTimeout(p)
            }
        }
    }
    , [n]);
    let f = () => {
        r(!0)
    }
      , m = () => {
        r(!1),
        a(!1)
    }
    ;
    return t ? s !== "intent" ? [i, h, {}] : [i, h, {
        onFocus: jr(o, f),
        onBlur: jr(l, m),
        onMouseEnter: jr(c, f),
        onMouseLeave: jr(u, m),
        onTouchStart: jr(d, f)
    }] : [!1, h, {}]
}
function jr(s, e) {
    return t => {
        s && s(t),
        t.defaultPrevented || e(t)
    }
}
function eS({page: s, ...e}) {
    let {router: t} = $p()
      , n = w.useMemo( () => Rp(t.routes, s, t.basename), [t.routes, s, t.basename]);
    return n ? w.createElement(sS, {
        page: s,
        matches: n,
        ...e
    }) : null
}
function tS(s) {
    let {manifest: e, routeModules: t} = jp()
      , [n,r] = w.useState([]);
    return w.useEffect( () => {
        let i = !1;
        return zE(s, e, t).then(a => {
            i || r(a)
        }
        ),
        () => {
            i = !0
        }
    }
    , [s, e, t]),
    n
}
function sS({page: s, matches: e, ...t}) {
    let n = hn()
      , {manifest: r, routeModules: i} = jp()
      , {basename: a} = $p()
      , {loaderData: o, matches: l} = QE()
      , c = w.useMemo( () => Zh(s, e, l, r, n, "data"), [s, e, l, r, n])
      , u = w.useMemo( () => Zh(s, e, l, r, n, "assets"), [s, e, l, r, n])
      , d = w.useMemo( () => {
        if (s === n.pathname + n.search + n.hash)
            return [];
        let m = new Set
          , p = !1;
        if (e.forEach(y => {
            var E;
            let v = r.routes[y.route.id];
            !v || !v.hasLoader || (!c.some(T => T.route.id === y.route.id) && y.route.id in o && ((E = i[y.route.id]) != null && E.shouldRevalidate) || v.hasClientLoader ? p = !0 : m.add(y.route.id))
        }
        ),
        m.size === 0)
            return [];
        let x = HE(s, a, "data");
        return p && m.size > 0 && x.searchParams.set("_routes", e.filter(y => m.has(y.route.id)).map(y => y.route.id).join(",")),
        [x.pathname + x.search]
    }
    , [a, o, n, r, c, e, s, i])
      , h = w.useMemo( () => YE(u, r), [u, r])
      , f = tS(u);
    return w.createElement(w.Fragment, null, d.map(m => w.createElement("link", {
        key: m,
        rel: "prefetch",
        as: "fetch",
        href: m,
        ...t
    })), h.map(m => w.createElement("link", {
        key: m,
        rel: "modulepreload",
        href: m,
        ...t
    })), f.map( ({key: m, link: p}) => w.createElement("link", {
        key: m,
        nonce: t.nonce,
        ...p
    })))
}
function nS(...s) {
    return e => {
        s.forEach(t => {
            typeof t == "function" ? t(e) : t != null && (t.current = e)
        }
        )
    }
}
var Gp = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    Gp && (window.__reactRouterVersion = "7.8.2")
} catch {}
function rS({basename: s, children: e, window: t}) {
    let n = w.useRef();
    n.current == null && (n.current = Wv({
        window: t,
        v5Compat: !0
    }));
    let r = n.current
      , [i,a] = w.useState({
        action: r.action,
        location: r.location
    })
      , o = w.useCallback(l => {
        w.startTransition( () => a(l))
    }
    , [a]);
    return w.useLayoutEffect( () => r.listen(o), [r, o]),
    w.createElement(NE, {
        basename: s,
        children: e,
        location: i.location,
        navigationType: i.action,
        navigator: r
    })
}
var Vp = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Ft = w.forwardRef(function({onClick: e, discover: t="render", prefetch: n="none", relative: r, reloadDocument: i, replace: a, state: o, target: l, to: c, preventScrollReset: u, viewTransition: d, ...h}, f) {
    let {basename: m} = w.useContext(gs), p = typeof c == "string" && Vp.test(c), x, y = !1;
    if (typeof c == "string" && p && (x = c,
    Gp))
        try {
            let C = new URL(window.location.href)
              , b = c.startsWith("//") ? new URL(C.protocol + c) : new URL(c)
              , O = Os(b.pathname, m);
            b.origin === C.origin && O != null ? c = O + b.search + b.hash : y = !0
        } catch {
            hs(!1, `<Link to="${c}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
        }
    let v = vE(c, {
        relative: r
    })
      , [E,T,L] = JE(n, h)
      , R = lS(c, {
        replace: a,
        state: o,
        target: l,
        preventScrollReset: u,
        relative: r,
        viewTransition: d
    });
    function I(C) {
        e && e(C),
        C.defaultPrevented || R(C)
    }
    let A = w.createElement("a", {
        ...h,
        ...L,
        href: x || v,
        onClick: y || i ? e : I,
        ref: nS(f, T),
        target: l,
        "data-discover": !p && t === "render" ? "true" : void 0
    });
    return E && !p ? w.createElement(w.Fragment, null, A, w.createElement(eS, {
        page: v
    })) : A
});
Ft.displayName = "Link";
var iS = w.forwardRef(function({"aria-current": e="page", caseSensitive: t=!1, className: n="", end: r=!1, style: i, to: a, viewTransition: o, children: l, ...c}, u) {
    let d = Ui(a, {
        relative: c.relative
    })
      , h = hn()
      , f = w.useContext(Ko)
      , {navigator: m, basename: p} = w.useContext(gs)
      , x = f != null && fS(d) && o === !0
      , y = m.encodeLocation ? m.encodeLocation(d).pathname : d.pathname
      , v = h.pathname
      , E = f && f.navigation && f.navigation.location ? f.navigation.location.pathname : null;
    t || (v = v.toLowerCase(),
    E = E ? E.toLowerCase() : null,
    y = y.toLowerCase()),
    E && p && (E = Os(E, p) || E);
    const T = y !== "/" && y.endsWith("/") ? y.length - 1 : y.length;
    let L = v === y || !r && v.startsWith(y) && v.charAt(T) === "/", R = E != null && (E === y || !r && E.startsWith(y) && E.charAt(y.length) === "/"), I = {
        isActive: L,
        isPending: R,
        isTransitioning: x
    }, A = L ? e : void 0, C;
    typeof n == "function" ? C = n(I) : C = [n, L ? "active" : null, R ? "pending" : null, x ? "transitioning" : null].filter(Boolean).join(" ");
    let b = typeof i == "function" ? i(I) : i;
    return w.createElement(Ft, {
        ...c,
        "aria-current": A,
        className: C,
        ref: u,
        style: b,
        to: a,
        viewTransition: o
    }, typeof l == "function" ? l(I) : l)
});
iS.displayName = "NavLink";
var aS = w.forwardRef( ({discover: s="render", fetcherKey: e, navigate: t, reloadDocument: n, replace: r, state: i, method: a=Na, action: o, onSubmit: l, relative: c, preventScrollReset: u, viewTransition: d, ...h}, f) => {
    let m = dS()
      , p = hS(o, {
        relative: c
    })
      , x = a.toLowerCase() === "get" ? "get" : "post"
      , y = typeof o == "string" && Vp.test(o)
      , v = E => {
        if (l && l(E),
        E.defaultPrevented)
            return;
        E.preventDefault();
        let T = E.nativeEvent.submitter
          , L = (T == null ? void 0 : T.getAttribute("formmethod")) || a;
        m(T || E.currentTarget, {
            fetcherKey: e,
            method: L,
            navigate: t,
            replace: r,
            state: i,
            relative: c,
            preventScrollReset: u,
            viewTransition: d
        })
    }
    ;
    return w.createElement("form", {
        ref: f,
        method: x,
        action: p,
        onSubmit: n ? l : v,
        ...h,
        "data-discover": !y && s === "render" ? "true" : void 0
    })
}
);
aS.displayName = "Form";
function oS(s) {
    return `${s} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function Hp(s) {
    let e = w.useContext(Cr);
    return we(e, oS(s)),
    e
}
function lS(s, {target: e, replace: t, state: n, preventScrollReset: r, relative: i, viewTransition: a}={}) {
    let o = Mp()
      , l = hn()
      , c = Ui(s, {
        relative: i
    });
    return w.useCallback(u => {
        if ($E(u, e)) {
            u.preventDefault();
            let d = t !== void 0 ? t : Li(l) === Li(c);
            o(s, {
                replace: d,
                state: n,
                preventScrollReset: r,
                relative: i,
                viewTransition: a
            })
        }
    }
    , [l, o, c, t, n, e, s, r, i, a])
}
var cS = 0
  , uS = () => `__${String(++cS)}__`;
function dS() {
    let {router: s} = Hp("useSubmit")
      , {basename: e} = w.useContext(gs)
      , t = kE();
    return w.useCallback(async (n, r={}) => {
        let {action: i, method: a, encType: o, formData: l, body: c} = VE(n, e);
        if (r.navigate === !1) {
            let u = r.fetcherKey || uS();
            await s.fetch(u, t, r.action || i, {
                preventScrollReset: r.preventScrollReset,
                formData: l,
                body: c,
                formMethod: r.method || a,
                formEncType: r.encType || o,
                flushSync: r.flushSync
            })
        } else
            await s.navigate(r.action || i, {
                preventScrollReset: r.preventScrollReset,
                formData: l,
                body: c,
                formMethod: r.method || a,
                formEncType: r.encType || o,
                replace: r.replace,
                state: r.state,
                fromRouteId: t,
                flushSync: r.flushSync,
                viewTransition: r.viewTransition
            })
    }
    , [s, e, t])
}
function hS(s, {relative: e}={}) {
    let {basename: t} = w.useContext(gs)
      , n = w.useContext(ps);
    we(n, "useFormAction must be used inside a RouteContext");
    let[r] = n.matches.slice(-1)
      , i = {
        ...Ui(s || ".", {
            relative: e
        })
    }
      , a = hn();
    if (s == null) {
        i.search = a.search;
        let o = new URLSearchParams(i.search)
          , l = o.getAll("index");
        if (l.some(u => u === "")) {
            o.delete("index"),
            l.filter(d => d).forEach(d => o.append("index", d));
            let u = o.toString();
            i.search = u ? `?${u}` : ""
        }
    }
    return (!s || s === ".") && r.route.index && (i.search = i.search ? i.search.replace(/^\?/, "?index&") : "?index"),
    t !== "/" && (i.pathname = i.pathname === "/" ? t : ks([t, i.pathname])),
    Li(i)
}
function fS(s, {relative: e}={}) {
    let t = w.useContext(Pp);
    we(t != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {basename: n} = Hp("useViewTransitionState")
      , r = Ui(s, {
        relative: e
    });
    if (!t.isTransitioning)
        return !1;
    let i = Os(t.currentLocation.pathname, n) || t.currentLocation.pathname
      , a = Os(t.nextLocation.pathname, n) || t.nextLocation.pathname;
    return go(r.pathname, a) != null || go(r.pathname, i) != null
}
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var mS = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const gS = s => s.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase().trim()
  , he = (s, e) => {
    const t = w.forwardRef( ({color: n="currentColor", size: r=24, strokeWidth: i=2, absoluteStrokeWidth: a, className: o="", children: l, ...c}, u) => w.createElement("svg", {
        ref: u,
        ...mS,
        width: r,
        height: r,
        stroke: n,
        strokeWidth: a ? Number(i) * 24 / Number(r) : i,
        className: ["lucide", `lucide-${gS(s)}`, o].join(" "),
        ...c
    }, [...e.map( ([d,h]) => w.createElement(d, h)), ...Array.isArray(l) ? l : [l]]));
    return t.displayName = `${s}`,
    t
}
;
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ur = he("AlertCircle", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["line", {
    x1: "12",
    x2: "12",
    y1: "8",
    y2: "12",
    key: "1pkeuh"
}], ["line", {
    x1: "12",
    x2: "12.01",
    y1: "16",
    y2: "16",
    key: "4dfq90"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pS = he("ArrowLeft", [["path", {
    d: "m12 19-7-7 7-7",
    key: "1l729n"
}], ["path", {
    d: "M19 12H5",
    key: "x3x0zl"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yS = he("Award", [["circle", {
    cx: "12",
    cy: "8",
    r: "6",
    key: "1vp47v"
}], ["path", {
    d: "M15.477 12.89 17 22l-5-3-5 3 1.523-9.11",
    key: "em7aur"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const po = he("Bell", [["path", {
    d: "M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9",
    key: "1qo2s2"
}], ["path", {
    d: "M10.3 21a1.94 1.94 0 0 0 3.4 0",
    key: "qgo35s"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const dr = he("BookOpen", [["path", {
    d: "M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z",
    key: "vv98re"
}], ["path", {
    d: "M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z",
    key: "1cyq3y"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xS = he("Calendar", [["path", {
    d: "M8 2v4",
    key: "1cmpym"
}], ["path", {
    d: "M16 2v4",
    key: "4m81vk"
}], ["rect", {
    width: "18",
    height: "18",
    x: "3",
    y: "4",
    rx: "2",
    key: "1hopcy"
}], ["path", {
    d: "M3 10h18",
    key: "8toen8"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yo = he("CheckCircle", [["path", {
    d: "M22 11.08V12a10 10 0 1 1-5.93-9.14",
    key: "g774vq"
}], ["path", {
    d: "m9 11 3 3L22 4",
    key: "1pflzl"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vS = he("Check", [["path", {
    d: "M20 6 9 17l-5-5",
    key: "1gmf2c"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ES = he("ChevronDown", [["path", {
    d: "m6 9 6 6 6-6",
    key: "qrunsl"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nn = he("Clock", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["polyline", {
    points: "12 6 12 12 16 14",
    key: "68esgv"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SS = he("Copy", [["rect", {
    width: "14",
    height: "14",
    x: "8",
    y: "8",
    rx: "2",
    ry: "2",
    key: "17jyea"
}], ["path", {
    d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",
    key: "zix9uf"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Qe = he("Download", [["path", {
    d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
    key: "ih7n3h"
}], ["polyline", {
    points: "7 10 12 15 17 10",
    key: "2ggqvy"
}], ["line", {
    x1: "12",
    x2: "12",
    y1: "15",
    y2: "3",
    key: "1vk2je"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ws = he("FileText", [["path", {
    d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
    key: "1rqfz7"
}], ["path", {
    d: "M14 2v4a2 2 0 0 0 2 2h4",
    key: "tnqrlb"
}], ["path", {
    d: "M10 9H8",
    key: "b1mrlr"
}], ["path", {
    d: "M16 13H8",
    key: "t4e002"
}], ["path", {
    d: "M16 17H8",
    key: "z1uh3a"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Kp = he("Filter", [["polygon", {
    points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3",
    key: "1yg77f"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const TS = he("Info", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["path", {
    d: "M12 16v-4",
    key: "1dtifu"
}], ["path", {
    d: "M12 8h.01",
    key: "e9boi3"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LS = he("Maximize", [["path", {
    d: "M8 3H5a2 2 0 0 0-2 2v3",
    key: "1dcmit"
}], ["path", {
    d: "M21 8V5a2 2 0 0 0-2-2h-3",
    key: "1e4gt3"
}], ["path", {
    d: "M3 16v3a2 2 0 0 0 2 2h3",
    key: "wsl5sc"
}], ["path", {
    d: "M16 21h3a2 2 0 0 0 2-2v-3",
    key: "18trek"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const IS = he("Menu", [["line", {
    x1: "4",
    x2: "20",
    y1: "12",
    y2: "12",
    key: "1e0a9i"
}], ["line", {
    x1: "4",
    x2: "20",
    y1: "6",
    y2: "6",
    key: "1owob3"
}], ["line", {
    x1: "4",
    x2: "20",
    y1: "18",
    y2: "18",
    key: "yk5zj1"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AS = he("Minimize", [["path", {
    d: "M8 3v3a2 2 0 0 1-2 2H3",
    key: "hohbtr"
}], ["path", {
    d: "M21 8h-3a2 2 0 0 1-2-2V3",
    key: "5jw1f3"
}], ["path", {
    d: "M3 16h3a2 2 0 0 1 2 2v3",
    key: "198tvr"
}], ["path", {
    d: "M16 21v-3a2 2 0 0 1 2-2h3",
    key: "ph8mxp"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const bS = he("Pause", [["rect", {
    width: "4",
    height: "16",
    x: "6",
    y: "4",
    key: "iffhe4"
}], ["rect", {
    width: "4",
    height: "16",
    x: "14",
    y: "4",
    key: "sjin7j"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const aa = he("PenTool", [["path", {
    d: "m12 19 7-7 3 3-7 7-3-3z",
    key: "rklqx2"
}], ["path", {
    d: "m18 13-1.5-7.5L2 2l3.5 14.5L13 18l5-5z",
    key: "1et58u"
}], ["path", {
    d: "m2 2 7.586 7.586",
    key: "etlp93"
}], ["circle", {
    cx: "11",
    cy: "11",
    r: "2",
    key: "xmgehs"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rt = he("Play", [["polygon", {
    points: "5 3 19 12 5 21 5 3",
    key: "191637"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const RS = he("RotateCcw", [["path", {
    d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",
    key: "1357e3"
}], ["path", {
    d: "M3 3v5h5",
    key: "1xhq8a"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zo = he("Search", [["circle", {
    cx: "11",
    cy: "11",
    r: "8",
    key: "4ej97u"
}], ["path", {
    d: "m21 21-4.3-4.3",
    key: "1qie3q"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wS = he("Settings", [["path", {
    d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
    key: "1qme2f"
}], ["circle", {
    cx: "12",
    cy: "12",
    r: "3",
    key: "1v7zrd"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wp = he("Star", [["polygon", {
    points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2",
    key: "8f66p6"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CS = he("Tag", [["path", {
    d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
    key: "vktsd0"
}], ["circle", {
    cx: "7.5",
    cy: "7.5",
    r: ".5",
    fill: "currentColor",
    key: "kqv944"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ii = he("Users", [["path", {
    d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
    key: "1yyitq"
}], ["circle", {
    cx: "9",
    cy: "7",
    r: "4",
    key: "nufk8"
}], ["path", {
    d: "M22 21v-2a4 4 0 0 0-3-3.87",
    key: "kshegd"
}], ["path", {
    d: "M16 3.13a4 4 0 0 1 0 7.75",
    key: "1da9ce"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kS = he("Volume2", [["polygon", {
    points: "11 5 6 9 2 9 2 15 6 15 11 19 11 5",
    key: "16drj5"
}], ["path", {
    d: "M15.54 8.46a5 5 0 0 1 0 7.07",
    key: "ltjumu"
}], ["path", {
    d: "M19.07 4.93a10 10 0 0 1 0 14.14",
    key: "1kegas"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _S = he("VolumeX", [["polygon", {
    points: "11 5 6 9 2 9 2 15 6 15 11 19 11 5",
    key: "16drj5"
}], ["line", {
    x1: "22",
    x2: "16",
    y1: "9",
    y2: "15",
    key: "1ewh16"
}], ["line", {
    x1: "16",
    x2: "22",
    y1: "9",
    y2: "15",
    key: "5ykzw1"
}]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xo = he("X", [["path", {
    d: "M18 6 6 18",
    key: "1bl5f8"
}], ["path", {
    d: "m6 6 12 12",
    key: "d8bk6v"
}]]);
class DS {
    constructor() {
        this.config = null,
        this.baseUrl = "https://ntx.apixwalla.workers.dev",
        this.liveApiUrl = "https://api.rolexcoderz.live",
        this.loadConfig()
    }
    loadConfig() {
        try {
            const e = "eyJiYXRjaGVzIjp7IkRhaWx5IExpdmUgQ2xhc3NlcyAyMDI1Ijp7ImxpdmUtY2xhc3NlcyI6eyJsZWN0dXJlcyI6Ii8/Z2V0PWxpdmUifSwic2NoZWR1bGVkLWNsYXNzZXMiOnsibGVjdHVyZXMiOiIvP2dldD11cCJ9LCJyZWNvcmRlZC1jbGFzc2VzIjp7ImxlY3R1cmVzIjoiLz9nZXQ9Y29tcGxldGVkIn19LCJBYXJhbWJoIEJhdGNoIENsYXNzIDl0aCAyMDI1LTI2Ijp7InNjaWVuY2UiOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9OVNjaSZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9OVNjaSZ0eXBlPW5vdGVzIiwiZHBwIjoiLz9nZXRkYXRhPTlTY2kmdHlwZT1kcHAifSwibWF0aGVtYXRpY3MiOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9OU1hdGhzJnR5cGU9bGVjdHVyZXMiLCJub3RlcyI6Ii8/Z2V0ZGF0YT05TWF0aHMmdHlwZT1ub3RlcyIsImRwcCI6Ii8/Z2V0ZGF0YT05TWF0aHMmdHlwZT1kcHAifSwic29jaWFsLXNjaWVuY2UiOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9OVNzdCZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9OVNzdCZ0eXBlPW5vdGVzIiwiZHBwIjoiLz9nZXRkYXRhPTlTc3QmdHlwZT1kcHAifSwiaGluZGkiOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9OUhpbiZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9OUhpbiZ0eXBlPW5vdGVzIn0sImVuZ2xpc2giOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9OUVuZyZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9OUVuZyZ0eXBlPW5vdGVzIn0sImluZm9ybWF0aW9uLXRlY2hub2xvZ3kiOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9OUl0JnR5cGU9bGVjdHVyZXMiLCJub3RlcyI6Ii8/Z2V0ZGF0YT05SXQmdHlwZT1ub3RlcyJ9fSwiQUFSQU1CSCAyLk8gMTB0aCBCQVRDSCAyNS0yNiI6eyJzY2llbmNlIjp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTEwU2NpJnR5cGU9bGVjdHVyZXMiLCJub3RlcyI6Ii8/Z2V0ZGF0YT0xMFNjaSZ0eXBlPW5vdGVzIiwiZHBwIjoiLz9nZXRkYXRhPTEwU2NpJnR5cGU9ZHBwIn0sIm1hdGhlbWF0aWNzIjp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTEwTWF0aHMmdHlwZT1sZWN0dXJlcyIsIm5vdGVzIjoiLz9nZXRkYXRhPTEwTWF0aHMmdHlwZT1ub3RlcyIsImRwcCI6Ii8/Z2V0ZGF0YT0xME1hdGhzJnR5cGU9ZHBwIn0sInNvY2lhbC1zY2llbmNlIjp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTEwU3N0JnR5cGU9bGVjdHVyZXMiLCJub3RlcyI6Ii8/Z2V0ZGF0YT0xMFNzdCZ0eXBlPW5vdGVzIiwiZHBwIjoiLz9nZXRkYXRhPTEwU3N0JnR5cGU9ZHBwIn0sImhpbmRpIjp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTEwSGluJnR5cGU9bGVjdHVyZXMiLCJub3RlcyI6Ii8/Z2V0ZGF0YT0xMEhpbiZ0eXBlPW5vdGVzIn0sImVuZ2xpc2giOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9MTBFbmcmdHlwZT1sZWN0dXJlcyIsIm5vdGVzIjoiLz9nZXRkYXRhPTEwRW5nJnR5cGU9bm90ZXMifSwiaW5mb3JtYXRpb24tdGVjaG5vbG9neSI6eyJsZWN0dXJlcyI6Ii8/Z2V0ZGF0YT0xMEl0JnR5cGU9bGVjdHVyZXMiLCJub3RlcyI6Ii8/Z2V0ZGF0YT0xMEl0JnR5cGU9bm90ZXMifSwic2Fuc2tyaXQiOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9MTBTYW5zJnR5cGU9bGVjdHVyZXMifX0sIkh1bWFuaXRpZXMgMTF0aCI6eyJoaXN0b3J5Ijp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTExSGlzdG9yeSZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9MTFIaXN0b3J5JnR5cGU9bm90ZXMiLCJkcHAiOiIvP2dldGRhdGE9MTFIaXN0b3J5JnR5cGU9ZHBwIn0sImdlb2dyYXBoeSI6eyJsZWN0dXJlcyI6Ii8/Z2V0ZGF0YT0xMUdlbyZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9MTFHZW8mdHlwZT1ub3RlcyIsImRwcCI6Ii8/Z2V0ZGF0YT0xMUdlbyZ0eXBlPWRwcCJ9LCJwb2xpdGljYWwtc2NpZW5jZSI6eyJsZWN0dXJlcyI6Ii8/Z2V0ZGF0YT0xMVBvbFNjaSZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9MTFQb2xTY2kmdHlwZT1ub3RlcyIsImRwcCI6Ii8/Z2V0ZGF0YT0xMVBvbFNjaSZ0eXBlPWRwcCJ9fSwiU2NpZW5jZSAxMXRoIChQQ01CKSI6eyJiaW9sb2d5Ijp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTExQmlvJnR5cGU9bGVjdHVyZXMiLCJub3RlcyI6Ii8/Z2V0ZGF0YT0xMUJpbyZ0eXBlPW5vdGVzIiwiZHBwIjoiLz9nZXRkYXRhPTExQmlvJnR5cGU9ZHBwIn0sImNoZW1pc3RyeSI6eyJsZWN0dXJlcyI6Ii8/Z2V0ZGF0YT0xMUNoZW0mdHlwZT1sZWN0dXJlcyIsIm5vdGVzIjoiLz9nZXRkYXRhPTExQ2hlbSZ0eXBlPW5vdGVzIiwiZHBwIjoiLz9nZXRkYXRhPTExQ2hlbSZ0eXBlPWRwcCJ9LCJwaHlzaWNzIjp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTExUGh5JnR5cGU9bGVjdHVyZXMiLCJub3RlcyI6Ii8/Z2V0ZGF0YT0xMVBoeSZ0eXBlPW5vdGVzIiwiZHBwIjoiLz9nZXRkYXRhPTExUGh5JnR5cGU9ZHBwIn0sIm1hdGhlbWF0aWNzIjp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTExTWF0aHMmdHlwZT1sZWN0dXJlcyIsIm5vdGVzIjoiLz9nZXRkYXRhPTExTWF0aHMmdHlwZT1ub3RlcyIsImRwcCI6Ii8/Z2V0ZGF0YT0xMU1hdGhzJnR5cGU9ZHBwIn19LCJDb21tZXJjZSAxMXRoIjp7ImFjY291bnRzIjp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTExQWNjb3VudCZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9MTFBY2NvdW50JnR5cGU9bm90ZXMiLCJkcHAiOiIvP2dldGRhdGE9MTFBY2NvdW50JnR5cGU9ZHBwIn0sImVjb25vbWljcyI6eyJsZWN0dXJlcyI6Ii8/Z2V0ZGF0YT0xMUVjbyZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9MTFFY28mdHlwZT1ub3RlcyIsImRwcCI6Ii8/Z2V0ZGF0YT0xMUVjbyZ0eXBlPWRwcCJ9LCJidXNpbmVzcy1zdHVkaWVzIjp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTExQnVzaW5lc3MmdHlwZT1sZWN0dXJlcyIsIm5vdGVzIjoiLz9nZXRkYXRhPTExQnVzaW5lc3MmdHlwZT1ub3RlcyIsImRwcCI6Ii8/Z2V0ZGF0YT0xMUJ1c2luZXNzJnR5cGU9ZHBwIn0sIm1hdGhlbWF0aWNzIjp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTExTWF0aHMmdHlwZT1sZWN0dXJlcyIsIm5vdGVzIjoiLz9nZXRkYXRhPTExTWF0aHMmdHlwZT1ub3RlcyIsImRwcCI6Ii8/Z2V0ZGF0YT0xMU1hdGhzJnR5cGU9ZHBwIn19LCJTY2llbmNlIDEydGggKFBDTUIpIjp7InBoeXNpY3MiOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9MTJQaHkmdHlwZT1sZWN0dXJlcyIsIm5vdGVzIjoiLz9nZXRkYXRhPTEyUGh5JnR5cGU9bm90ZXMiLCJkcHAiOiIvP2dldGRhdGE9MTJQaHkmdHlwZT1kcHAifSwiY2hlbWlzdHJ5Ijp7ImxlY3R1cmVzIjoiLz9nZXRkYXRhPTEyQ2hlbSZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9MTJDaGVtJnR5cGU9bm90ZXMiLCJkcHAiOiIvP2dldGRhdGE9MTJDaGVtJnR5cGU9ZHBwIn0sImJpb2xvZ3kiOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9MTJCaW8mdHlwZT1sZWN0dXJlcyIsIm5vdGVzIjoiLz9nZXRkYXRhPTEyQmlvJnR5cGU9bm90ZXMiLCJkcHAiOiIvP2dldGRhdGE9MTJCaW8mdHlwZT1kcHAifSwibWF0aGVtYXRpY3MiOnsibGVjdHVyZXMiOiIvP2dldGRhdGE9MTJNYXRocyZ0eXBlPWxlY3R1cmVzIiwibm90ZXMiOiIvP2dldGRhdGE9MTJNYXRocyZ0eXBlPW5vdGVzIiwiZHBwIjoiLz9nZXRkYXRhPTEyTWF0aHMmdHlwZT1kcHAifX19fQ==";
            if (e) {
                const t = atob(e);
                this.config = JSON.parse(t)
            }
        } catch (e) {
            console.error("Failed to load API configuration:", e),
            this.config = null
        }
    }
    getApiUrl(e, t, n) {
        if (!this.config)
            return console.error("API configuration not loaded"),
            null;
        const r = this.config.batches[e];
        if (!r)
            return console.error(`Batch not found: ${e}`),
            null;
        const i = r[t];
        if (!i)
            return console.error(`Subject not found: ${t} in batch: ${e}`),
            null;
        const a = i[n];
        return a ? `${e === "Daily Live Classes 2025" ? this.liveApiUrl : this.baseUrl}${a}` : (console.warn(`No ${n} endpoint found for ${t} in ${e}`),
        null)
    }
    getNotificationsUrl() {
        return `${this.liveApiUrl}/?get=notifications`
    }
    getAvailableBatches() {
        return this.config ? Object.keys(this.config.batches) : []
    }
    getAvailableSubjects(e) {
        if (!this.config)
            return [];
        const t = this.config.batches[e];
        return t ? Object.keys(t) : []
    }
}
const Mn = new DS
  , qh = ({onClose: s}) => {
    const [e,t] = w.useState([])
      , [n,r] = w.useState(!0)
      , [i,a] = w.useState(null)
      , o = w.useRef(null);
    w.useEffect( () => {
        l();
        const p = x => {
            o.current && !o.current.contains(x.target) && s()
        }
        ;
        return document.addEventListener("mousedown", p),
        () => document.removeEventListener("mousedown", p)
    }
    , [s]);
    const l = async () => {
        try {
            r(!0);
            const p = Mn.getNotificationsUrl()
              , x = await fetch(p);
            if (!x.ok)
                throw new Error("Failed to fetch notifications");
            const y = await x.json();
            console.log(" Notifications API Response:", y);
            let v = [];
            Array.isArray(y) ? v = y : y.data && Array.isArray(y.data) ? v = y.data : y.notifications && Array.isArray(y.notifications) ? v = y.notifications : y.result && Array.isArray(y.result) && (v = y.result);
            const E = v.map( (T, L) => ({
                id: T.id || T._id || `notification-${L}`,
                title: T.title || T.subject || T.heading || "Notification",
                message: T.message || T.content || T.description || T.body || "No message available",
                type: c(T.type || T.category || T.priority || "info"),
                date: T.date || T.created_at || T.timestamp || new Date().toISOString(),
                read: T.read || T.is_read || !1,
                priority: T.priority || T.importance || "medium"
            }));
            E.sort( (T, L) => new Date(L.date).getTime() - new Date(T.date).getTime()),
            t(E)
        } catch (p) {
            console.error(" Error fetching notifications:", p),
            a("Failed to load notifications")
        } finally {
            r(!1)
        }
    }
      , c = p => {
        const x = p.toLowerCase();
        return x.includes("success") || x.includes("complete") ? "success" : x.includes("warning") || x.includes("alert") ? "warning" : x.includes("error") || x.includes("fail") ? "error" : "info"
    }
      , u = p => {
        switch (p) {
        case "success":
            return g.jsx(yo, {
                className: "h-5 w-5 text-green-400"
            });
        case "warning":
            return g.jsx(ur, {
                className: "h-5 w-5 text-yellow-400"
            });
        case "error":
            return g.jsx(ur, {
                className: "h-5 w-5 text-red-400"
            });
        default:
            return g.jsx(TS, {
                className: "h-5 w-5 text-blue-400"
            })
        }
    }
      , d = p => {
        switch (p) {
        case "success":
            return "border-green-500/30";
        case "warning":
            return "border-yellow-500/30";
        case "error":
            return "border-red-500/30";
        default:
            return "border-blue-500/30"
        }
    }
      , h = p => {
        t(x => x.map(y => y.id === p ? {
            ...y,
            read: !0
        } : y))
    }
      , f = p => {
        const x = new Date(p)
          , v = (new Date().getTime() - x.getTime()) / (1e3 * 60 * 60);
        return v < 1 ? "Just now" : v < 24 ? `${Math.floor(v)}h ago` : v < 168 ? `${Math.floor(v / 24)}d ago` : x.toLocaleDateString()
    }
      , m = e.filter(p => !p.read).length;
    return g.jsxs("div", {
        ref: o,
        className: "absolute right-0 top-full mt-2 w-80 sm:w-96 bg-gradient-to-br from-gray-900 to-black border border-red-500/30 rounded-xl shadow-2xl z-50 max-h-96 overflow-hidden",
        children: [g.jsxs("div", {
            className: "flex items-center justify-between p-4 border-b border-red-500/20",
            children: [g.jsxs("div", {
                className: "flex items-center gap-2",
                children: [g.jsx(po, {
                    className: "h-5 w-5 text-red-400"
                }), g.jsx("h3", {
                    className: "text-lg font-semibold text-white",
                    children: "Notifications"
                }), m > 0 && g.jsx("span", {
                    className: "bg-red-600 text-white text-xs px-2 py-1 rounded-full",
                    children: m
                })]
            }), g.jsx("button", {
                onClick: s,
                className: "p-1 hover:bg-gray-800 rounded-lg transition-colors",
                children: g.jsx(xo, {
                    className: "h-4 w-4 text-gray-400"
                })
            })]
        }), g.jsx("div", {
            className: "max-h-80 overflow-y-auto",
            children: n ? g.jsxs("div", {
                className: "p-4 text-center",
                children: [g.jsx("div", {
                    className: "animate-spin rounded-full h-8 w-8 border-b-2 border-red-400 mx-auto mb-2"
                }), g.jsx("p", {
                    className: "text-gray-400 text-sm",
                    children: "Loading notifications..."
                })]
            }) : i ? g.jsxs("div", {
                className: "p-4 text-center",
                children: [g.jsx(ur, {
                    className: "h-8 w-8 text-red-400 mx-auto mb-2"
                }), g.jsx("p", {
                    className: "text-red-400 text-sm",
                    children: i
                }), g.jsx("button", {
                    onClick: l,
                    className: "mt-2 text-xs text-blue-400 hover:text-blue-300 underline",
                    children: "Try Again"
                })]
            }) : e.length === 0 ? g.jsxs("div", {
                className: "p-6 text-center",
                children: [g.jsx(po, {
                    className: "h-12 w-12 text-gray-600 mx-auto mb-3"
                }), g.jsx("p", {
                    className: "text-gray-400",
                    children: "No notifications yet"
                }), g.jsx("p", {
                    className: "text-gray-500 text-sm mt-1",
                    children: "We'll notify you when something important happens"
                })]
            }) : g.jsx("div", {
                className: "divide-y divide-gray-800",
                children: e.map(p => g.jsx("div", {
                    className: `p-4 hover:bg-gray-800/50 transition-colors cursor-pointer border-l-2 ${d(p.type)} ${p.read ? "" : "bg-gray-800/30"}`,
                    onClick: () => h(p.id),
                    children: g.jsxs("div", {
                        className: "flex items-start gap-3",
                        children: [g.jsx("div", {
                            className: "flex-shrink-0 mt-1",
                            children: u(p.type)
                        }), g.jsxs("div", {
                            className: "flex-1 min-w-0",
                            children: [g.jsxs("div", {
                                className: "flex items-start justify-between gap-2",
                                children: [g.jsx("h4", {
                                    className: `text-sm font-medium ${p.read ? "text-gray-300" : "text-white"} line-clamp-1`,
                                    children: p.title
                                }), !p.read && g.jsx("div", {
                                    className: "w-2 h-2 bg-red-500 rounded-full flex-shrink-0 mt-1"
                                })]
                            }), g.jsx("p", {
                                className: "text-xs text-gray-400 mt-1 line-clamp-2",
                                children: p.message
                            }), g.jsxs("div", {
                                className: "flex items-center gap-2 mt-2",
                                children: [g.jsx(nn, {
                                    className: "h-3 w-3 text-gray-500"
                                }), g.jsx("span", {
                                    className: "text-xs text-gray-500",
                                    children: f(p.date)
                                }), p.priority === "high" && g.jsx("span", {
                                    className: "text-xs bg-red-600 text-white px-1.5 py-0.5 rounded",
                                    children: "High"
                                })]
                            })]
                        })]
                    })
                }, p.id))
            })
        }), e.length > 0 && g.jsx("div", {
            className: "p-3 border-t border-red-500/20 bg-gray-900/50",
            children: g.jsx("button", {
                onClick: () => {
                    t(p => p.map(x => ({
                        ...x,
                        read: !0
                    })))
                }
                ,
                className: "w-full text-center text-xs text-red-400 hover:text-red-300 transition-colors",
                children: "Mark all as read"
            })
        })]
    })
}
  , PS = () => {
    const [s,e] = w.useState(!1)
      , [t,n] = w.useState(!1)
      , r = hn()
      , i = [{
        name: "Home",
        path: "/"
    }, {
        name: "Batches",
        path: "/batches"
    }, {
        name: "Downloader",
        path: "/downloader"
    }]
      , a = o => r.pathname === o;
    return g.jsxs("nav", {
        className: "bg-gradient-to-r from-black via-gray-900 to-black border-b border-red-900/50 shadow-2xl sticky top-0 z-50 backdrop-blur-sm neon-border",
        children: [g.jsx("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: g.jsxs("div", {
                className: "flex justify-between h-16",
                children: [g.jsx("div", {
                    className: "flex items-center",
                    children: g.jsxs(Ft, {
                        to: "/",
                        className: "flex items-center space-x-2",
                        children: [g.jsx("img", {
                            src: "https://i.ibb.co/23bwFnVF/6179079224833460665-1.jpg",
                            alt: "EduSpark Logo",
                            className: "h-8 w-8 rounded-full object-cover glow-red"
                        }), g.jsx("span", {
                            className: "text-2xl font-bold text-gradient neon-text",
                            children: "EduSpark"
                        })]
                    })
                }), g.jsxs("div", {
                    className: "hidden lg:flex items-center space-x-8",
                    children: [i.map(o => g.jsx(Ft, {
                        to: o.path,
                        className: `px-3 py-2 rounded-md text-sm font-medium transition-all duration-200 ${a(o.path) ? "text-red-400 bg-red-900/30 glow-red border border-red-500/30" : "text-gray-300 hover:text-red-400 hover:bg-gray-800/50"}`,
                        children: o.name
                    }, o.path)), g.jsxs("div", {
                        className: "relative",
                        children: [g.jsx("button", {
                            onClick: () => n(!t),
                            className: "p-2 text-gray-300 hover:text-red-400 transition-colors duration-300 rounded-lg hover:bg-red-900/20 relative",
                            children: g.jsx(po, {
                                className: "h-6 w-6"
                            })
                        }), t && g.jsx(qh, {
                            onClose: () => n(!1)
                        })]
                    })]
                }), g.jsxs("div", {
                    className: "lg:hidden flex items-center space-x-2",
                    children: [g.jsxs("div", {
                        className: "relative",
                        children: [g.jsx("button", {
                            onClick: () => n(!t),
                            className: "p-2 text-gray-300 hover:text-red-400 transition-colors duration-300 rounded-lg hover:bg-red-900/20",
                            children: g.jsx(po, {
                                className: "h-5 w-5"
                            })
                        }), t && g.jsx(qh, {
                            onClose: () => n(!1)
                        })]
                    }), g.jsx("button", {
                        onClick: () => e(!s),
                        className: "text-gray-300 hover:text-red-400 transition-colors duration-300 p-2 rounded-lg hover:bg-red-900/20",
                        children: s ? g.jsx(xo, {
                            className: "h-6 w-6"
                        }) : g.jsx(IS, {
                            className: "h-6 w-6"
                        })
                    })]
                })]
            })
        }), s && g.jsx("div", {
            className: "lg:hidden bg-gradient-to-b from-black to-gray-900 border-t border-red-900/50 backdrop-blur-sm",
            children: g.jsx("div", {
                className: "px-2 pt-2 pb-3 space-y-1",
                children: i.map(o => g.jsx(Ft, {
                    to: o.path,
                    onClick: () => e(!1),
                    className: `block px-3 py-2 rounded-md text-base font-medium transition-all duration-200 ${a(o.path) ? "text-red-400 bg-red-900/30 glow-red border border-red-500/30" : "text-gray-300 hover:text-red-400 hover:bg-gray-800/50"}`,
                    children: o.name
                }, o.path))
            })
        })]
    })
}
  , NS = () => {
    const s = [{
        icon: g.jsx(rt, {
            className: "h-8 w-8"
        }),
        title: "Video Lectures",
        description: "High-quality video lectures by expert teachers",
        color: "text-red-400",
        bgColor: "bg-red-900/20"
    }, {
        icon: g.jsx(ws, {
            className: "h-8 w-8"
        }),
        title: "Daily Practice Papers",
        description: "Structured practice papers for daily improvement",
        color: "text-red-400",
        bgColor: "bg-red-900/20"
    }, {
        icon: g.jsx(Qe, {
            className: "h-8 w-8"
        }),
        title: "Study Notes",
        description: "Comprehensive notes covering all topics",
        color: "text-red-400",
        bgColor: "bg-red-900/20"
    }]
      , e = [{
        icon: g.jsx(Ii, {
            className: "h-6 w-6"
        }),
        value: "10,000+",
        label: "Students"
    }, {
        icon: g.jsx(dr, {
            className: "h-6 w-6"
        }),
        value: "500+",
        label: "Lectures"
    }, {
        icon: g.jsx(yS, {
            className: "h-6 w-6"
        }),
        value: "95%",
        label: "Success Rate"
    }, {
        icon: g.jsx(nn, {
            className: "h-6 w-6"
        }),
        value: "24/7",
        label: "Support"
    }];
    return g.jsxs("div", {
        className: "min-h-screen bg-dark-primary",
        children: [g.jsx("div", {
            className: "bg-gradient-to-br from-black via-gray-900 to-red-900/30 py-12 md:py-20",
            children: g.jsx("div", {
                className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
                children: g.jsxs("div", {
                    className: "text-center",
                    children: [g.jsx("div", {
                        className: "flex justify-center mb-6",
                        children: g.jsx("div", {
                            className: "p-0 bg-red-600 rounded-full glow-red pulse-red",
                            children: g.jsx("img", {
                                src: "https://i.ibb.co/23bwFnVF/6179079224833460665-1.jpg",
                                alt: "EduSpark Logo",
                                className: "h-12 w-12 md:h-16 md:w-16 rounded-full object-cover"
                            })
                        })
                    }), g.jsxs("h1", {
                        className: "text-3xl md:text-4xl lg:text-6xl font-bold text-white mb-6",
                        children: ["Welcome to ", g.jsx("span", {
                            className: "text-gradient neon-text",
                            children: "EduSparK"
                        })]
                    }), g.jsx("p", {
                        className: "text-base md:text-xl lg:text-2xl text-gray-300 mb-8 max-w-3xl mx-auto",
                        children: "Your complete study companion . Access quality lectures, practice papers, and comprehensive notes all in one place."
                    }), g.jsx("div", {
                        className: "flex flex-col sm:flex-row gap-4 justify-center",
                        children: g.jsx(Ft, {
                            to: "/batches",
                            className: "btn-primary",
                            children: "Start Learning"
                        })
                    })]
                })
            })
        }), g.jsx("div", {
            className: "py-12 md:py-20 bg-dark-secondary",
            children: g.jsxs("div", {
                className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
                children: [g.jsxs("div", {
                    className: "text-center mb-12 md:mb-16",
                    children: [g.jsx("h2", {
                        className: "text-2xl md:text-3xl lg:text-4xl font-bold text-gradient mb-4",
                        children: "Everything You Need to Excel"
                    }), g.jsx("p", {
                        className: "text-base md:text-lg text-gray-300 max-w-2xl mx-auto",
                        children: "Comprehensive study resources designed specifically for students"
                    })]
                }), g.jsx("div", {
                    className: "grid grid-cols-1 md:grid-cols-3 gap-6 md:gap-8",
                    children: s.map( (t, n) => g.jsxs("div", {
                        className: "card p-6 md:p-8 text-center slide-in",
                        children: [g.jsx("div", {
                            className: `inline-flex p-4 rounded-full ${t.bgColor} mb-6`,
                            children: g.jsx("div", {
                                className: t.color,
                                children: t.icon
                            })
                        }), g.jsx("h3", {
                            className: "text-lg md:text-xl font-semibold text-white mb-4",
                            children: t.title
                        }), g.jsx("p", {
                            className: "text-sm md:text-base text-gray-300 mb-6",
                            children: t.description
                        }), g.jsxs(Ft, {
                            to: `/${t.title.toLowerCase().replace(" ", "").replace("papers", "ps")}`,
                            className: "inline-flex items-center text-red-400 hover:text-red-300 font-medium transition-colors duration-200 text-sm md:text-base",
                            children: ["Explore Now", g.jsx("svg", {
                                className: "ml-2 h-4 w-4",
                                fill: "none",
                                stroke: "currentColor",
                                viewBox: "0 0 24 24",
                                children: g.jsx("path", {
                                    strokeLinecap: "round",
                                    strokeLinejoin: "round",
                                    strokeWidth: 2,
                                    d: "M9 5l7 7-7 7"
                                })
                            })]
                        })]
                    }, n))
                })]
            })
        }), g.jsx("div", {
            className: "py-12 md:py-16 bg-dark-primary border-t border-red-900/50 neon-border",
            children: g.jsx("div", {
                className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
                children: g.jsx("div", {
                    className: "grid grid-cols-2 md:grid-cols-4 gap-8",
                    children: e.map( (t, n) => g.jsxs("div", {
                        className: "text-center",
                        children: [g.jsx("div", {
                            className: "flex justify-center text-red-400 mb-3 glow-red",
                            children: t.icon
                        }), g.jsx("div", {
                            className: "text-xl md:text-2xl lg:text-3xl font-bold text-gradient mb-2",
                            children: t.value
                        }), g.jsx("div", {
                            className: "text-gray-300 text-sm md:text-base",
                            children: t.label
                        })]
                    }, n))
                })
            })
        }), g.jsx("div", {
            className: "py-12 md:py-20 bg-gradient-to-r from-red-900/50 via-black to-red-900/50",
            children: g.jsxs("div", {
                className: "max-w-4xl mx-auto text-center px-4 sm:px-6 lg:px-8",
                children: [g.jsx(Wp, {
                    className: "h-16 w-16 text-red-400 mx-auto mb-6 glow-red pulse-red"
                }), g.jsx("h2", {
                    className: "text-2xl md:text-3xl lg:text-4xl font-bold text-gradient mb-6",
                    children: "Ready to Boost Your Grades?"
                }), g.jsx("p", {
                    className: "text-base md:text-xl text-gray-300 mb-8",
                    children: "Join thousands of students who have improved their performance with EduSpark"
                }), g.jsxs("div", {
                    className: "flex flex-col sm:flex-row gap-4 justify-center",
                    children: [g.jsx(Ft, {
                        to: "/batches",
                        className: "bg-white text-red-600 px-6 md:px-8 py-3 md:py-4 rounded-lg font-semibold hover:bg-gray-100 transition-all duration-300 text-sm md:text-base transform hover:scale-105 shadow-lg hover:shadow-red-500/25",
                        children: "Start Learning Today"
                    }), g.jsx(Ft, {
                        to: "/notes",
                        className: "bg-transparent border-2 border-red-400 text-red-400 px-6 md:px-8 py-3 md:py-4 rounded-lg font-semibold hover:bg-red-400 hover:text-black transition-all duration-300 text-sm md:text-base transform hover:scale-105 neon-border",
                        children: "Download Notes"
                    })]
                })]
            })
        })]
    })
}
  , OS = () => {
    const [s,e] = w.useState([])
      , t = Mp()
      , n = [{
        id: "Daily Live Classes 2025",
        title: "Daily Live Classes 2025",
        description: "Access live classes, upcoming sessions, and recorded content all in one place.",
        banner: "https://i.ytimg.com/vi/8eCqh4kRjSc/maxresdefault.jpg",
        instructor: "Expert Teachers",
        duration: "Live Sessions",
        students: 2500,
        rating: 4.8,
        price: "Free",
        features: ["Live Classes", "Scheduled Sessions", "Recorded Content", "Interactive Learning", "24/7 Access"],
        subjects: ["Live Classes", "Scheduled Classes", "Recorded Classes"],
        isEnrolled: !1
    }, {
        id: "Aarambh Batch Class 9th 2025-26",
        title: "Aarambh Batch Class 9th 2025-26",
        description: "Complete foundation course covering all chapters of Class 9.",
        banner: "https://dxixtlyravvxx.cloudfront.net/540/admin_v1/bundle_management/course/152792333113_9th%20aarambh%202.0%20banner%20app.jpg",
        instructor: "pata nahi",
        duration: "lifetime",
        students: 2500,
        rating: 4.8,
        price: "Free",
        features: ["Live Classes", "Recorded Lectures", "Practice Papers", "Study Notes", "Doubt Solving"],
        subjects: ["Physics", "Chemistry", "Biology"],
        isEnrolled: !1
    }, {
        id: "AARAMBH 2.O 10th BATCH 25-26",
        title: "AARAMBH 2.O 10th BATCH 25-26",
        description: "Advanced preparation for CBSE Board exams with focus on high-scoring techniques and exam strategies.",
        banner: "https://dxixtlyravvxx.cloudfront.net/540/admin_v1/bundle_management/course/285939929246_10th%20aarambh%202.0%20banner%20app.jpg",
        instructor: "na",
        duration: "lifetime",
        students: 1800,
        rating: 4.9,
        price: "free",
        features: ["Board Exam Focus", "Previous Year Papers", "Mock Tests", "Performance Analysis"],
        subjects: ["Physics", "Chemistry", "Biology"],
        isEnrolled: !1
    }, {
        id: "Humanities 11th",
        title: "Humanities 11th",
        description: "Intensive crash course for last-minute preparation with important topics and formulas.",
        banner: "https://dxixtlyravvxx.cloudfront.net/540/admin_v1/bundle_management/course/216113028517_Prarambh%20BATCh%20Humanities%2011.png",
        instructor: "na",
        duration: "lifetime",
        students: 3200,
        rating: 4.7,
        price: "free",
        features: ["Quick Revision", "Important Topics", "Formula Sheets", "Exam Tips"],
        subjects: ["Physics", "Chemistry", "Biology"],
        isEnrolled: !1
    }, {
        id: "Science 11th (PCMB)",
        title: "Science 11th (PCMB)",
        description: "Specialized batch focusing exclusively on Physics with detailed problem-solving techniques.",
        banner: "https://dxixtlyravvxx.cloudfront.net/540/admin_v1/bundle_management/course/183130728609_Prarambh%20BATCh%20Science%20Class%2011.png",
        instructor: "na",
        duration: "lifetime",
        students: 1200,
        rating: 4.8,
        price: "free",
        features: ["Physics Focus", "Problem Solving", "Numerical Practice", "Concept Building"],
        subjects: ["Physics"],
        isEnrolled: !1
    }, {
        id: "Commerce 11th",
        title: "Commerce 11th",
        description: "Master all chemistry concepts with practical examples and reaction mechanisms.",
        banner: "https://dxixtlyravvxx.cloudfront.net/540/admin_v1/bundle_management/course/737975028610_Prarambh%20BATCh%20Commerce%2011.png",
        instructor: "na",
        duration: "lifetime",
        students: 1500,
        rating: 4.9,
        price: "free",
        features: ["Chemistry Focus", "Reaction Mechanisms", "Practical Examples", "Organic Chemistry"],
        subjects: ["Chemistry"],
        isEnrolled: !1
    }, {
        id: "Science 12th (PCMB)",
        title: "Science 12th (PCMB)",
        description: "Comprehensive biology course with diagrams, life processes, and detailed explanations.",
        banner: "https://dxixtlyravvxx.cloudfront.net/540/admin_v1/bundle_management/course/337551428612_Prarambh%20BATCh%20Science%2012.jpg",
        instructor: "na",
        duration: "lifetime",
        students: 1800,
        rating: 4.8,
        price: "free",
        features: ["Biology Focus", "Diagram Practice", "Life Processes", "NCERT Solutions"],
        subjects: ["Biology"],
        isEnrolled: !1
    }]
      , r = o => {
        e(l => [...l, o]),
        setTimeout( () => {
            t(`/batch/${o}/subjects`)
        }
        , 1e3)
    }
      , i = o => s.includes(o)
      , a = o => ({
        Physics: "text-blue-600 bg-blue-100",
        Chemistry: "text-green-600 bg-green-100",
        Biology: "text-pink-600 bg-pink-100"
    })[o] || "text-gray-600 bg-gray-100";
    return g.jsx("div", {
        className: "min-h-screen bg-dark-primary py-6 md:py-12",
        children: g.jsxs("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: [g.jsxs("div", {
                className: "text-center mb-8 md:mb-12",
                children: [g.jsx("h1", {
                    className: "text-2xl md:text-4xl font-bold text-gradient mb-4",
                    children: "Choose Your Learning Batch"
                }), g.jsx("p", {
                    className: "text-sm md:text-lg text-gray-400 max-w-2xl mx-auto",
                    children: "Select the perfect batch that matches your learning goals and start your journey to academic excellence"
                })]
            }), g.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 md:gap-8",
                children: n.map(o => g.jsxs("div", {
                    className: "card overflow-hidden",
                    children: [g.jsxs("div", {
                        className: "relative h-40 md:h-48 overflow-hidden",
                        children: [g.jsx("img", {
                            src: o.banner,
                            alt: o.title,
                            className: "w-full h-full object-cover transition-transform duration-500 hover:scale-110"
                        }), g.jsx("div", {
                            className: "absolute top-4 right-4",
                            children: g.jsx("span", {
                                className: "bg-red-600 text-white px-2 md:px-3 py-1 rounded-full text-xs md:text-sm font-semibold shadow-lg glow-red",
                                children: o.price
                            })
                        })]
                    }), g.jsxs("div", {
                        className: "p-4 md:p-6",
                        children: [g.jsxs("div", {
                            className: "flex items-center justify-between mb-3",
                            children: [g.jsx("div", {
                                className: "flex flex-wrap items-center gap-1 md:gap-2",
                                children: o.subjects.map(l => g.jsx("span", {
                                    className: `text-xs font-medium px-1.5 md:px-2 py-1 rounded border border-red-500/30 ${a(l)}`,
                                    children: l
                                }, l))
                            }), g.jsxs("div", {
                                className: "flex items-center gap-1",
                                children: [g.jsx(Wp, {
                                    className: "h-4 w-4 text-red-400 fill-current glow-red"
                                }), g.jsx("span", {
                                    className: "text-xs md:text-sm font-medium text-red-400",
                                    children: o.rating
                                })]
                            })]
                        }), g.jsx("h3", {
                            className: "text-lg md:text-xl font-semibold text-white mb-3 line-clamp-2",
                            children: o.title
                        }), g.jsx("p", {
                            className: "text-gray-400 text-xs md:text-sm mb-4 line-clamp-3",
                            children: o.description
                        }), g.jsxs("div", {
                            className: "flex flex-col sm:flex-row sm:items-center sm:justify-between text-xs md:text-sm text-gray-400 mb-4 gap-2",
                            children: [g.jsxs("div", {
                                className: "flex items-center gap-1",
                                children: [g.jsx(dr, {
                                    className: "h-4 w-4 text-red-400"
                                }), g.jsx("span", {
                                    children: o.instructor
                                })]
                            }), g.jsxs("div", {
                                className: "flex items-center gap-2 md:gap-3",
                                children: [g.jsxs("div", {
                                    className: "flex items-center gap-1",
                                    children: [g.jsx(nn, {
                                        className: "h-4 w-4 text-red-400"
                                    }), g.jsx("span", {
                                        children: o.duration
                                    })]
                                }), g.jsxs("div", {
                                    className: "flex items-center gap-1",
                                    children: [g.jsx(Ii, {
                                        className: "h-4 w-4 text-red-400"
                                    }), g.jsx("span", {
                                        children: o.students.toLocaleString()
                                    })]
                                })]
                            })]
                        }), g.jsxs("div", {
                            className: "mb-6",
                            children: [g.jsx("h4", {
                                className: "text-xs md:text-sm font-semibold text-white mb-2",
                                children: "What's Included:"
                            }), g.jsxs("div", {
                                className: "space-y-1",
                                children: [o.features.slice(0, 3).map( (l, c) => g.jsxs("div", {
                                    className: "flex items-center gap-2 text-xs md:text-sm text-gray-400",
                                    children: [g.jsx(yo, {
                                        className: "h-3 w-3 text-red-400"
                                    }), g.jsx("span", {
                                        children: l
                                    })]
                                }, c)), o.features.length > 3 && g.jsxs("div", {
                                    className: "text-xs text-gray-500",
                                    children: ["+", o.features.length - 3, " more features"]
                                })]
                            })]
                        }), i(o.id) ? g.jsxs("div", {
                            className: "space-y-3",
                            children: [g.jsxs("div", {
                                className: "flex items-center justify-center gap-2 w-full bg-green-100 text-green-700 py-2 md:py-3 rounded-lg font-medium text-sm",
                                children: [g.jsx(yo, {
                                    className: "h-5 w-5 text-red-400"
                                }), "Enrolled Successfully"]
                            }), g.jsxs(Ft, {
                                to: `/batch/${o.id}/subjects`,
                                className: "w-full btn-primary flex items-center justify-center gap-2 text-sm",
                                children: [g.jsx(dr, {
                                    className: "h-4 w-4"
                                }), "Start Learning"]
                            })]
                        }) : g.jsxs("button", {
                            onClick: () => r(o.id),
                            className: "w-full btn-primary flex items-center justify-center gap-2 text-sm",
                            children: [g.jsx(dr, {
                                className: "h-4 w-4"
                            }), "Enroll Now"]
                        })]
                    })]
                }, o.id))
            }), g.jsxs("div", {
                className: "mt-8 md:mt-16 bg-gradient-to-r from-red-900/50 via-black to-red-900/50 rounded-2xl p-6 md:p-8 text-white text-center border border-red-900/30 neon-border",
                children: [g.jsx("h2", {
                    className: "text-xl md:text-2xl font-bold mb-4 text-gradient",
                    children: "Complete Your Learning Journey"
                }), g.jsx("p", {
                    className: "text-gray-300 mb-6 max-w-2xl mx-auto text-sm md:text-base",
                    children: "Each subject contains comprehensive content with lectures, practice papers, and detailed notes to ensure your success"
                }), g.jsxs("div", {
                    className: "flex flex-wrap items-center justify-center gap-4 md:gap-8 text-xs md:text-sm",
                    children: [g.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [g.jsx(nn, {
                            className: "h-5 w-5 text-red-400"
                        }), g.jsx("span", {
                            children: "Self-paced Learning"
                        })]
                    }), g.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [g.jsx(rt, {
                            className: "h-5 w-5"
                        }), g.jsx("span", {
                            children: "Video Lectures"
                        })]
                    }), g.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [g.jsx(ws, {
                            className: "h-5 w-5"
                        }), g.jsx("span", {
                            children: "Study Materials"
                        })]
                    }), g.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [g.jsx(Qe, {
                            className: "h-5 w-5"
                        }), g.jsx("span", {
                            children: "Expert Content"
                        })]
                    }), g.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [g.jsx(Ii, {
                            className: "h-5 w-5 text-red-400"
                        }), g.jsx("span", {
                            children: "24/7 Support"
                        })]
                    })]
                })]
            })]
        })
    })
}
  , MS = () => {
    const {batchId: s} = Fp()
      , t = (r => ({
        "Daily Live Classes 2025": [{
            id: "live-classes",
            name: "Live Classes",
            description: "Join ongoing live sessions with real-time interaction and Q&A",
            color: "text-red-600",
            bgColor: "bg-red-100",
            icon: "",
            lectures: 0,
            dpps: 0,
            notes: 0
        }, {
            id: "scheduled-classes",
            name: "Scheduled Classes",
            description: "View upcoming scheduled sessions and set reminders",
            color: "text-blue-600",
            bgColor: "bg-blue-100",
            icon: "",
            lectures: 0,
            dpps: 0,
            notes: 0
        }, {
            id: "recorded-classes",
            name: "Recorded Classes",
            description: "Access completed sessions and recorded content anytime",
            color: "text-green-600",
            bgColor: "bg-green-100",
            icon: "",
            lectures: 0,
            dpps: 0,
            notes: 0
        }],
        "Aarambh Batch Class 9th 2025-26": [{
            id: "mathematics",
            name: "Mathematics",
            description: "Number systems, algebra, geometry, and coordinate geometry",
            color: "text-blue-600",
            bgColor: "bg-blue-100",
            icon: "",
            lectures: 45,
            dpps: 25,
            notes: 15
        }, {
            id: "science",
            name: "Science",
            description: "Physics, chemistry, and biology concepts with practical applications",
            color: "text-red-600",
            bgColor: "bg-red-100",
            icon: "",
            lectures: 60,
            dpps: 35,
            notes: 20
        }, {
            id: "social-science",
            name: "Social Science",
            description: "History, geography, political science, and economics",
            color: "text-green-600",
            bgColor: "bg-green-100",
            icon: "",
            lectures: 40,
            dpps: 20,
            notes: 12
        }, {
            id: "hindi",
            name: "hindi",
            description: " , ,    ",
            color: "text-yellow-600",
            bgColor: "bg-yellow-100",
            icon: "",
            lectures: 50,
            dpps: 0,
            notes: 35
        }, {
            id: "English",
            name: "English",
            description: "Introduction to AI concepts and applications",
            color: "text-pink-600",
            bgColor: "bg-pink-100",
            icon: "ENG",
            lectures: 25,
            dpps: 15,
            notes: 8
        }, {
            id: "information-technology",
            name: "Information Technology",
            description: "Computer fundamentals and digital literacy",
            color: "text-orange-600",
            bgColor: "bg-orange-100",
            icon: "",
            lectures: 30,
            dpps: 18,
            notes: 10
        }],
        "AARAMBH 2.O 10th BATCH 25-26": [{
            id: "mathematics",
            name: "Mathematics",
            description: "Real numbers, polynomials, linear equations, and trigonometry",
            color: "text-blue-600",
            bgColor: "bg-blue-100",
            icon: "",
            lectures: 50,
            dpps: 30,
            notes: 18
        }, {
            id: "science",
            name: "Science",
            description: "Physics, chemistry, and biology concepts with practical applications",
            color: "text-red-600",
            bgColor: "bg-red-100",
            icon: "",
            lectures: 60,
            dpps: 35,
            notes: 20
        }, {
            id: "social-science",
            name: "Social Science",
            description: "History, geography, political science, and economics",
            color: "text-green-600",
            bgColor: "bg-green-100",
            icon: "",
            lectures: 45,
            dpps: 25,
            notes: 15
        }, {
            id: "Sanskrit",
            name: "Sanskrit",
            description: "Sanskrit",
            color: "text-orange-600",
            bgColor: "bg-orange-100",
            icon: "",
            lectures: 50,
            dpps: 0,
            notes: 35
        }, {
            id: "English",
            name: "English",
            description: "Introduction to AI concepts and applications",
            color: "text-pink-600",
            bgColor: "bg-pink-100",
            icon: "ENG",
            lectures: 25,
            dpps: 15,
            notes: 8
        }, {
            id: "information-technology",
            name: "Information Technology",
            description: "Programming concepts and digital applications",
            color: "text-orange-600",
            bgColor: "bg-orange-100",
            icon: "",
            lectures: 35,
            dpps: 20,
            notes: 12
        }, {
            id: "hindi",
            name: "Hindi",
            description: " , ,    ",
            color: "text-yellow-600",
            bgColor: "bg-yellow-100",
            icon: "",
            lectures: 50,
            dpps: 0,
            notes: 35
        }],
        "Humanities 11th": [{
            id: "history",
            name: "History",
            description: "World history, Indian history, and historical analysis",
            color: "text-amber-600",
            bgColor: "bg-amber-100",
            icon: "",
            lectures: 40,
            dpps: 22,
            notes: 14
        }, {
            id: "geography",
            name: "Geography",
            description: "Physical and human geography concepts",
            color: "text-emerald-600",
            bgColor: "bg-emerald-100",
            icon: "",
            lectures: 35,
            dpps: 20,
            notes: 12
        }, {
            id: "political-science",
            name: "Political Science",
            description: "Political theory, Indian constitution, and governance",
            color: "text-indigo-600",
            bgColor: "bg-indigo-100",
            icon: "",
            lectures: 38,
            dpps: 18,
            notes: 13
        }],
        "Science 11th (PCMB)": [{
            id: "mathematics",
            name: "Mathematics",
            description: "Sets, functions, trigonometry, and coordinate geometry",
            color: "text-blue-600",
            bgColor: "bg-blue-100",
            icon: "",
            lectures: 55,
            dpps: 32,
            notes: 20
        }, {
            id: "physics",
            name: "Physics",
            description: "Mechanics, thermodynamics, and waves",
            color: "text-red-600",
            bgColor: "bg-red-100",
            icon: "",
            lectures: 50,
            dpps: 28,
            notes: 18
        }, {
            id: "chemistry",
            name: "Chemistry",
            description: "Atomic structure, chemical bonding, and organic chemistry",
            color: "text-green-600",
            bgColor: "bg-green-100",
            icon: "",
            lectures: 48,
            dpps: 26,
            notes: 17
        }, {
            id: "biology",
            name: "Biology",
            description: "Cell biology, plant physiology, and human physiology",
            color: "text-pink-600",
            bgColor: "bg-pink-100",
            icon: "",
            lectures: 45,
            dpps: 24,
            notes: 16
        }],
        "Commerce 11th": [{
            id: "mathematics",
            name: "Mathematics",
            description: "Statistics, probability, and mathematical reasoning",
            color: "text-blue-600",
            bgColor: "bg-blue-100",
            icon: "",
            lectures: 40,
            dpps: 22,
            notes: 14
        }, {
            id: "accounts",
            name: "Accounts",
            description: "Financial accounting principles and practices",
            color: "text-yellow-600",
            bgColor: "bg-yellow-100",
            icon: "",
            lectures: 45,
            dpps: 25,
            notes: 16
        }, {
            id: "business-studies",
            name: "Business Studies",
            description: "Business environment, planning, and management",
            color: "text-purple-600",
            bgColor: "bg-purple-100",
            icon: "",
            lectures: 42,
            dpps: 23,
            notes: 15
        }, {
            id: "economics",
            name: "Economics",
            description: "Microeconomics and macroeconomics fundamentals",
            color: "text-teal-600",
            bgColor: "bg-teal-100",
            icon: "",
            lectures: 38,
            dpps: 20,
            notes: 13
        }],
        "Science 12th (PCMB)": [{
            id: "mathematics",
            name: "Mathematics",
            description: "Calculus, vectors, probability, and linear programming",
            color: "text-blue-600",
            bgColor: "bg-blue-100",
            icon: "",
            lectures: 60,
            dpps: 35,
            notes: 22
        }, {
            id: "physics",
            name: "Physics",
            description: "Electrostatics, magnetism, optics, and modern physics",
            color: "text-red-600",
            bgColor: "bg-red-100",
            icon: "",
            lectures: 55,
            dpps: 32,
            notes: 20
        }, {
            id: "chemistry",
            name: "Chemistry",
            description: "Physical chemistry, organic chemistry, and inorganic chemistry",
            color: "text-green-600",
            bgColor: "bg-green-100",
            icon: "",
            lectures: 52,
            dpps: 30,
            notes: 19
        }, {
            id: "biology",
            name: "Biology",
            description: "Genetics, evolution, biotechnology, and ecology",
            color: "text-pink-600",
            bgColor: "bg-pink-100",
            icon: "",
            lectures: 48,
            dpps: 28,
            notes: 18
        }]
    })[r] || [])(s || "")
      , n = r => r || "Unknown Batch";
    return g.jsx("div", {
        className: "min-h-screen dark-container py-6 md:py-12",
        children: g.jsxs("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: [g.jsxs("div", {
                className: "flex items-center gap-3 md:gap-4 mb-6 md:mb-8",
                children: [g.jsx(Ft, {
                    to: "/batches",
                    className: "p-2 hover:bg-red-900/20 rounded-lg transition-colors border border-red-900/30",
                    children: g.jsx(pS, {
                        className: "h-5 w-5 md:h-6 md:w-6 text-gray-300"
                    })
                }), g.jsxs("div", {
                    children: [g.jsxs("h1", {
                        className: "text-xl md:text-3xl font-bold text-white",
                        children: [n(s || ""), " - Subjects"]
                    }), g.jsx("p", {
                        className: "text-sm md:text-base text-gray-300 mt-2",
                        children: "Choose a subject to access lectures, practice papers, and notes"
                    })]
                })]
            }), t.length === 0 ? g.jsxs("div", {
                className: "text-center py-8 md:py-12",
                children: [g.jsx("div", {
                    className: "h-16 w-16 text-red-400 mx-auto mb-4 flex items-center justify-center text-4xl",
                    children: ""
                }), g.jsx("h3", {
                    className: "text-base md:text-lg font-medium text-white mb-2",
                    children: "No subjects available"
                }), g.jsx("p", {
                    className: "text-sm md:text-base text-gray-300",
                    children: "Please check back later"
                })]
            }) : g.jsxs(g.Fragment, {
                children: [g.jsx("div", {
                    className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                    children: t.map(r => g.jsxs(Ft, {
                        to: `/batch/${s}/subject/${r.id}`,
                        className: "card-futuristic p-4 md:p-6 hover:shadow-xl transition-all duration-300 group",
                        children: [g.jsxs("div", {
                            className: "flex items-start justify-between mb-4",
                            children: [g.jsx("div", {
                                className: `p-3 rounded-full ${r.bgColor} group-hover:scale-110 transition-transform duration-300`,
                                children: g.jsx("span", {
                                    className: "text-xl md:text-2xl",
                                    children: r.icon
                                })
                            }), g.jsxs("div", {
                                className: "flex flex-col gap-1 text-xs hidden sm:flex",
                                children: [g.jsxs("div", {
                                    className: `px-2 py-1 rounded-full font-medium ${r.color} ${r.bgColor}`,
                                    children: [r.lectures, " Lectures"]
                                }), r.dpps > 0 && g.jsxs("div", {
                                    className: "px-2 py-1 rounded-full font-medium text-green-600 bg-green-100",
                                    children: [r.dpps, " DPPs"]
                                }), g.jsxs("div", {
                                    className: "px-2 py-1 rounded-full font-medium text-orange-600 bg-orange-100",
                                    children: [r.notes, " Notes"]
                                })]
                            })]
                        }), g.jsx("h3", {
                            className: "text-lg md:text-xl font-semibold text-white mb-3 group-hover:text-red-400 transition-colors",
                            children: r.name
                        }), g.jsx("p", {
                            className: "text-gray-300 text-xs md:text-sm mb-4 md:mb-6 line-clamp-3",
                            children: r.description
                        }), g.jsxs("div", {
                            className: "flex flex-wrap gap-2 mb-4 sm:hidden",
                            children: [g.jsxs("div", {
                                className: `px-2 py-1 rounded-full font-medium text-xs ${r.color} ${r.bgColor}`,
                                children: [r.lectures, " Lectures"]
                            }), r.dpps > 0 && g.jsxs("div", {
                                className: "px-2 py-1 rounded-full font-medium text-xs text-green-600 bg-green-100",
                                children: [r.dpps, " DPPs"]
                            }), g.jsxs("div", {
                                className: "px-2 py-1 rounded-full font-medium text-xs text-orange-600 bg-orange-100",
                                children: [r.notes, " Notes"]
                            })]
                        }), g.jsxs("div", {
                            className: "hidden sm:flex items-center justify-between text-xs md:text-sm text-gray-500 mb-4",
                            children: [g.jsxs("div", {
                                className: "flex items-center gap-1",
                                children: [g.jsx(rt, {
                                    className: "h-4 w-4 text-red-400"
                                }), g.jsx("span", {
                                    children: "Video Lectures"
                                })]
                            }), r.dpps > 0 && g.jsxs("div", {
                                className: "flex items-center gap-1",
                                children: [g.jsx(ws, {
                                    className: "h-4 w-4 text-red-400"
                                }), g.jsx("span", {
                                    children: "Practice Papers"
                                })]
                            }), g.jsxs("div", {
                                className: "flex items-center gap-1",
                                children: [g.jsx(Qe, {
                                    className: "h-4 w-4 text-red-400"
                                }), g.jsx("span", {
                                    children: "Study Notes"
                                })]
                            })]
                        }), g.jsx("div", {
                            className: "pt-4 border-t border-red-900/30",
                            children: g.jsxs("div", {
                                className: "flex items-center justify-center text-sm md:text-base text-red-400 font-medium group-hover:text-red-300 transition-colors",
                                children: ["Start Learning", g.jsx("svg", {
                                    className: "ml-2 h-4 w-4 group-hover:translate-x-1 transition-transform",
                                    fill: "none",
                                    stroke: "currentColor",
                                    viewBox: "0 0 24 24",
                                    children: g.jsx("path", {
                                        strokeLinecap: "round",
                                        strokeLinejoin: "round",
                                        strokeWidth: 2,
                                        d: "M9 5l7 7-7 7"
                                    })
                                })]
                            })
                        })]
                    }, r.id))
                }), g.jsxs("div", {
                    className: "mt-8 md:mt-16 bg-gradient-to-r from-red-900/50 via-black to-red-900/50 rounded-2xl p-6 md:p-8 text-white text-center border border-red-900/30 neon-border",
                    children: [g.jsx("h2", {
                        className: "text-xl md:text-2xl font-bold mb-4 text-gradient",
                        children: "Complete Your Learning Journey"
                    }), g.jsx("p", {
                        className: "text-gray-300 mb-6 max-w-2xl mx-auto text-sm md:text-base",
                        children: "Each subject contains comprehensive content with lectures, practice papers, and detailed notes to ensure your success"
                    }), g.jsxs("div", {
                        className: "flex flex-wrap items-center justify-center gap-4 md:gap-8 text-xs md:text-sm",
                        children: [g.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [g.jsx(nn, {
                                className: "h-5 w-5 text-red-400"
                            }), g.jsx("span", {
                                children: "Self-paced Learning"
                            })]
                        }), g.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [g.jsx("img", {
                                src: "https://i.ibb.co/23bwFnVF/6179079224833460665-1.jpg",
                                alt: "EduSpark Logo",
                                className: "h-5 w-5 rounded-full object-cover"
                            }), g.jsx("span", {
                                children: "Expert Content"
                            })]
                        }), g.jsxs("div", {
                            className: "flex items-center gap-2",
                            children: [g.jsx(Ii, {
                                className: "h-5 w-5 text-red-400"
                            }), g.jsx("span", {
                                children: "24/7 Support"
                            })]
                        })]
                    })]
                })]
            })]
        })
    })
}
  , z = Number.isFinite || function(s) {
    return typeof s == "number" && isFinite(s)
}
  , FS = Number.isSafeInteger || function(s) {
    return typeof s == "number" && Math.abs(s) <= US
}
  , US = Number.MAX_SAFE_INTEGER || 9007199254740991;
let q = function(s) {
    return s.NETWORK_ERROR = "networkError",
    s.MEDIA_ERROR = "mediaError",
    s.KEY_SYSTEM_ERROR = "keySystemError",
    s.MUX_ERROR = "muxError",
    s.OTHER_ERROR = "otherError",
    s
}({})
  , N = function(s) {
    return s.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys",
    s.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess",
    s.KEY_SYSTEM_NO_SESSION = "keySystemNoSession",
    s.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense",
    s.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed",
    s.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed",
    s.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed",
    s.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed",
    s.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted",
    s.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError",
    s.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR = "keySystemDestroyMediaKeysError",
    s.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR = "keySystemDestroyCloseSessionError",
    s.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR = "keySystemDestroyRemoveSessionError",
    s.MANIFEST_LOAD_ERROR = "manifestLoadError",
    s.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut",
    s.MANIFEST_PARSING_ERROR = "manifestParsingError",
    s.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError",
    s.LEVEL_EMPTY_ERROR = "levelEmptyError",
    s.LEVEL_LOAD_ERROR = "levelLoadError",
    s.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut",
    s.LEVEL_PARSING_ERROR = "levelParsingError",
    s.LEVEL_SWITCH_ERROR = "levelSwitchError",
    s.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError",
    s.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut",
    s.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError",
    s.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut",
    s.FRAG_LOAD_ERROR = "fragLoadError",
    s.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut",
    s.FRAG_DECRYPT_ERROR = "fragDecryptError",
    s.FRAG_PARSING_ERROR = "fragParsingError",
    s.FRAG_GAP = "fragGap",
    s.REMUX_ALLOC_ERROR = "remuxAllocError",
    s.KEY_LOAD_ERROR = "keyLoadError",
    s.KEY_LOAD_TIMEOUT = "keyLoadTimeOut",
    s.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError",
    s.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError",
    s.BUFFER_APPEND_ERROR = "bufferAppendError",
    s.BUFFER_APPENDING_ERROR = "bufferAppendingError",
    s.BUFFER_STALLED_ERROR = "bufferStalledError",
    s.BUFFER_FULL_ERROR = "bufferFullError",
    s.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole",
    s.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall",
    s.ASSET_LIST_LOAD_ERROR = "assetListLoadError",
    s.ASSET_LIST_LOAD_TIMEOUT = "assetListLoadTimeout",
    s.ASSET_LIST_PARSING_ERROR = "assetListParsingError",
    s.INTERSTITIAL_ASSET_ITEM_ERROR = "interstitialAssetItemError",
    s.INTERNAL_EXCEPTION = "internalException",
    s.INTERNAL_ABORTED = "aborted",
    s.ATTACH_MEDIA_ERROR = "attachMediaError",
    s.UNKNOWN = "unknown",
    s
}({})
  , S = function(s) {
    return s.MEDIA_ATTACHING = "hlsMediaAttaching",
    s.MEDIA_ATTACHED = "hlsMediaAttached",
    s.MEDIA_DETACHING = "hlsMediaDetaching",
    s.MEDIA_DETACHED = "hlsMediaDetached",
    s.MEDIA_ENDED = "hlsMediaEnded",
    s.STALL_RESOLVED = "hlsStallResolved",
    s.BUFFER_RESET = "hlsBufferReset",
    s.BUFFER_CODECS = "hlsBufferCodecs",
    s.BUFFER_CREATED = "hlsBufferCreated",
    s.BUFFER_APPENDING = "hlsBufferAppending",
    s.BUFFER_APPENDED = "hlsBufferAppended",
    s.BUFFER_EOS = "hlsBufferEos",
    s.BUFFERED_TO_END = "hlsBufferedToEnd",
    s.BUFFER_FLUSHING = "hlsBufferFlushing",
    s.BUFFER_FLUSHED = "hlsBufferFlushed",
    s.MANIFEST_LOADING = "hlsManifestLoading",
    s.MANIFEST_LOADED = "hlsManifestLoaded",
    s.MANIFEST_PARSED = "hlsManifestParsed",
    s.LEVEL_SWITCHING = "hlsLevelSwitching",
    s.LEVEL_SWITCHED = "hlsLevelSwitched",
    s.LEVEL_LOADING = "hlsLevelLoading",
    s.LEVEL_LOADED = "hlsLevelLoaded",
    s.LEVEL_UPDATED = "hlsLevelUpdated",
    s.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated",
    s.LEVELS_UPDATED = "hlsLevelsUpdated",
    s.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated",
    s.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching",
    s.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched",
    s.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading",
    s.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded",
    s.AUDIO_TRACK_UPDATED = "hlsAudioTrackUpdated",
    s.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated",
    s.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared",
    s.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch",
    s.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading",
    s.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded",
    s.SUBTITLE_TRACK_UPDATED = "hlsSubtitleTrackUpdated",
    s.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed",
    s.CUES_PARSED = "hlsCuesParsed",
    s.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound",
    s.INIT_PTS_FOUND = "hlsInitPtsFound",
    s.FRAG_LOADING = "hlsFragLoading",
    s.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted",
    s.FRAG_LOADED = "hlsFragLoaded",
    s.FRAG_DECRYPTED = "hlsFragDecrypted",
    s.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment",
    s.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata",
    s.FRAG_PARSING_METADATA = "hlsFragParsingMetadata",
    s.FRAG_PARSED = "hlsFragParsed",
    s.FRAG_BUFFERED = "hlsFragBuffered",
    s.FRAG_CHANGED = "hlsFragChanged",
    s.FPS_DROP = "hlsFpsDrop",
    s.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping",
    s.MAX_AUTO_LEVEL_UPDATED = "hlsMaxAutoLevelUpdated",
    s.ERROR = "hlsError",
    s.DESTROYING = "hlsDestroying",
    s.KEY_LOADING = "hlsKeyLoading",
    s.KEY_LOADED = "hlsKeyLoaded",
    s.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached",
    s.BACK_BUFFER_REACHED = "hlsBackBufferReached",
    s.STEERING_MANIFEST_LOADED = "hlsSteeringManifestLoaded",
    s.ASSET_LIST_LOADING = "hlsAssetListLoading",
    s.ASSET_LIST_LOADED = "hlsAssetListLoaded",
    s.INTERSTITIALS_UPDATED = "hlsInterstitialsUpdated",
    s.INTERSTITIALS_BUFFERED_TO_BOUNDARY = "hlsInterstitialsBufferedToBoundary",
    s.INTERSTITIAL_ASSET_PLAYER_CREATED = "hlsInterstitialAssetPlayerCreated",
    s.INTERSTITIAL_STARTED = "hlsInterstitialStarted",
    s.INTERSTITIAL_ASSET_STARTED = "hlsInterstitialAssetStarted",
    s.INTERSTITIAL_ASSET_ENDED = "hlsInterstitialAssetEnded",
    s.INTERSTITIAL_ASSET_ERROR = "hlsInterstitialAssetError",
    s.INTERSTITIAL_ENDED = "hlsInterstitialEnded",
    s.INTERSTITIALS_PRIMARY_RESUMED = "hlsInterstitialsPrimaryResumed",
    s.PLAYOUT_LIMIT_REACHED = "hlsPlayoutLimitReached",
    s.EVENT_CUE_ENTER = "hlsEventCueEnter",
    s
}({});
var le = {
    MANIFEST: "manifest",
    LEVEL: "level",
    AUDIO_TRACK: "audioTrack",
    SUBTITLE_TRACK: "subtitleTrack"
}
  , X = {
    MAIN: "main",
    AUDIO: "audio",
    SUBTITLE: "subtitle"
};
class $n {
    constructor(e, t=0, n=0) {
        this.halfLife = void 0,
        this.alpha_ = void 0,
        this.estimate_ = void 0,
        this.totalWeight_ = void 0,
        this.halfLife = e,
        this.alpha_ = e ? Math.exp(Math.log(.5) / e) : 0,
        this.estimate_ = t,
        this.totalWeight_ = n
    }
    sample(e, t) {
        const n = Math.pow(this.alpha_, e);
        this.estimate_ = t * (1 - n) + n * this.estimate_,
        this.totalWeight_ += e
    }
    getTotalWeight() {
        return this.totalWeight_
    }
    getEstimate() {
        if (this.alpha_) {
            const e = 1 - Math.pow(this.alpha_, this.totalWeight_);
            if (e)
                return this.estimate_ / e
        }
        return this.estimate_
    }
}
class BS {
    constructor(e, t, n, r=100) {
        this.defaultEstimate_ = void 0,
        this.minWeight_ = void 0,
        this.minDelayMs_ = void 0,
        this.slow_ = void 0,
        this.fast_ = void 0,
        this.defaultTTFB_ = void 0,
        this.ttfb_ = void 0,
        this.defaultEstimate_ = n,
        this.minWeight_ = .001,
        this.minDelayMs_ = 50,
        this.slow_ = new $n(e),
        this.fast_ = new $n(t),
        this.defaultTTFB_ = r,
        this.ttfb_ = new $n(e)
    }
    update(e, t) {
        const {slow_: n, fast_: r, ttfb_: i} = this;
        n.halfLife !== e && (this.slow_ = new $n(e,n.getEstimate(),n.getTotalWeight())),
        r.halfLife !== t && (this.fast_ = new $n(t,r.getEstimate(),r.getTotalWeight())),
        i.halfLife !== e && (this.ttfb_ = new $n(e,i.getEstimate(),i.getTotalWeight()))
    }
    sample(e, t) {
        e = Math.max(e, this.minDelayMs_);
        const n = 8 * t
          , r = e / 1e3
          , i = n / r;
        this.fast_.sample(r, i),
        this.slow_.sample(r, i)
    }
    sampleTTFB(e) {
        const t = e / 1e3
          , n = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);
        this.ttfb_.sample(n, Math.max(e, 5))
    }
    canEstimate() {
        return this.fast_.getTotalWeight() >= this.minWeight_
    }
    getEstimate() {
        return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
    }
    getEstimateTTFB() {
        return this.ttfb_.getTotalWeight() >= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_
    }
    get defaultEstimate() {
        return this.defaultEstimate_
    }
    destroy() {}
}
function $S(s, e, t) {
    return (e = GS(e))in s ? Object.defineProperty(s, e, {
        value: t,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : s[e] = t,
    s
}
function ye() {
    return ye = Object.assign ? Object.assign.bind() : function(s) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t)
                ({}).hasOwnProperty.call(t, n) && (s[n] = t[n])
        }
        return s
    }
    ,
    ye.apply(null, arguments)
}
function Qh(s, e) {
    var t = Object.keys(s);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(s);
        e && (n = n.filter(function(r) {
            return Object.getOwnPropertyDescriptor(s, r).enumerable
        })),
        t.push.apply(t, n)
    }
    return t
}
function pe(s) {
    for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e] != null ? arguments[e] : {};
        e % 2 ? Qh(Object(t), !0).forEach(function(n) {
            $S(s, n, t[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(t)) : Qh(Object(t)).forEach(function(n) {
            Object.defineProperty(s, n, Object.getOwnPropertyDescriptor(t, n))
        })
    }
    return s
}
function jS(s, e) {
    if (typeof s != "object" || !s)
        return s;
    var t = s[Symbol.toPrimitive];
    if (t !== void 0) {
        var n = t.call(s, e);
        if (typeof n != "object")
            return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(s)
}
function GS(s) {
    var e = jS(s, "string");
    return typeof e == "symbol" ? e : e + ""
}
class Gt {
    constructor(e, t) {
        this.trace = void 0,
        this.debug = void 0,
        this.log = void 0,
        this.warn = void 0,
        this.info = void 0,
        this.error = void 0;
        const n = `[${e}]:`;
        this.trace = Vs,
        this.debug = t.debug.bind(null, n),
        this.log = t.log.bind(null, n),
        this.warn = t.warn.bind(null, n),
        this.info = t.info.bind(null, n),
        this.error = t.error.bind(null, n)
    }
}
const Vs = function() {}
  , VS = {
    trace: Vs,
    debug: Vs,
    log: Vs,
    warn: Vs,
    info: Vs,
    error: Vs
};
function Wc() {
    return ye({}, VS)
}
function HS(s, e) {
    const t = self.console[s];
    return t ? t.bind(self.console, `${e ? "[" + e + "] " : ""}[${s}] >`) : Vs
}
function Jh(s, e, t) {
    return e[s] ? e[s].bind(e) : HS(s, t)
}
const zc = Wc();
function KS(s, e, t) {
    const n = Wc();
    if (typeof console == "object" && s === !0 || typeof s == "object") {
        const r = ["debug", "log", "info", "warn", "error"];
        r.forEach(i => {
            n[i] = Jh(i, s, t)
        }
        );
        try {
            n.log(`Debug logs enabled for "${e}" in hls.js version 1.6.11`)
        } catch {
            return Wc()
        }
        r.forEach(i => {
            zc[i] = Jh(i, s)
        }
        )
    } else
        ye(zc, n);
    return n
}
const fe = zc;
function on(s=!0) {
    return typeof self > "u" ? void 0 : (s || !self.MediaSource) && self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource
}
function WS(s) {
    return typeof self < "u" && s === self.ManagedMediaSource
}
function zp(s, e) {
    const t = Object.keys(s)
      , n = Object.keys(e)
      , r = t.length
      , i = n.length;
    return !r || !i || r === i && !t.some(a => n.indexOf(a) === -1)
}
function wt(s, e=!1) {
    if (typeof TextDecoder < "u") {
        const c = new TextDecoder("utf-8").decode(s);
        if (e) {
            const u = c.indexOf("\0");
            return u !== -1 ? c.substring(0, u) : c
        }
        return c.replace(/\0/g, "")
    }
    const t = s.length;
    let n, r, i, a = "", o = 0;
    for (; o < t; ) {
        if (n = s[o++],
        n === 0 && e)
            return a;
        if (n === 0 || n === 3)
            continue;
        switch (n >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
            a += String.fromCharCode(n);
            break;
        case 12:
        case 13:
            r = s[o++],
            a += String.fromCharCode((n & 31) << 6 | r & 63);
            break;
        case 14:
            r = s[o++],
            i = s[o++],
            a += String.fromCharCode((n & 15) << 12 | (r & 63) << 6 | (i & 63) << 0);
            break
        }
    }
    return a
}
function It(s) {
    let e = "";
    for (let t = 0; t < s.length; t++) {
        let n = s[t].toString(16);
        n.length < 2 && (n = "0" + n),
        e += n
    }
    return e
}
function Yp(s) {
    return Uint8Array.from(s.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer
}
function zS(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s
}
var wl = {
    exports: {}
}, ef;
function YS() {
    return ef || (ef = 1,
    function(s, e) {
        (function(t) {
            var n = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/
              , r = /^(?=([^\/?#]*))\1([^]*)$/
              , i = /(?:\/|^)\.(?=\/)/g
              , a = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g
              , o = {
                buildAbsoluteURL: function(l, c, u) {
                    if (u = u || {},
                    l = l.trim(),
                    c = c.trim(),
                    !c) {
                        if (!u.alwaysNormalize)
                            return l;
                        var d = o.parseURL(l);
                        if (!d)
                            throw new Error("Error trying to parse base URL.");
                        return d.path = o.normalizePath(d.path),
                        o.buildURLFromParts(d)
                    }
                    var h = o.parseURL(c);
                    if (!h)
                        throw new Error("Error trying to parse relative URL.");
                    if (h.scheme)
                        return u.alwaysNormalize ? (h.path = o.normalizePath(h.path),
                        o.buildURLFromParts(h)) : c;
                    var f = o.parseURL(l);
                    if (!f)
                        throw new Error("Error trying to parse base URL.");
                    if (!f.netLoc && f.path && f.path[0] !== "/") {
                        var m = r.exec(f.path);
                        f.netLoc = m[1],
                        f.path = m[2]
                    }
                    f.netLoc && !f.path && (f.path = "/");
                    var p = {
                        scheme: f.scheme,
                        netLoc: h.netLoc,
                        path: null,
                        params: h.params,
                        query: h.query,
                        fragment: h.fragment
                    };
                    if (!h.netLoc && (p.netLoc = f.netLoc,
                    h.path[0] !== "/"))
                        if (!h.path)
                            p.path = f.path,
                            h.params || (p.params = f.params,
                            h.query || (p.query = f.query));
                        else {
                            var x = f.path
                              , y = x.substring(0, x.lastIndexOf("/") + 1) + h.path;
                            p.path = o.normalizePath(y)
                        }
                    return p.path === null && (p.path = u.alwaysNormalize ? o.normalizePath(h.path) : h.path),
                    o.buildURLFromParts(p)
                },
                parseURL: function(l) {
                    var c = n.exec(l);
                    return c ? {
                        scheme: c[1] || "",
                        netLoc: c[2] || "",
                        path: c[3] || "",
                        params: c[4] || "",
                        query: c[5] || "",
                        fragment: c[6] || ""
                    } : null
                },
                normalizePath: function(l) {
                    for (l = l.split("").reverse().join("").replace(i, ""); l.length !== (l = l.replace(a, "")).length; )
                        ;
                    return l.split("").reverse().join("")
                },
                buildURLFromParts: function(l) {
                    return l.scheme + l.netLoc + l.path + l.params + l.query + l.fragment
                }
            };
            s.exports = o
        }
        )()
    }(wl)),
    wl.exports
}
var dd = YS();
class hd {
    constructor() {
        this.aborted = !1,
        this.loaded = 0,
        this.retry = 0,
        this.total = 0,
        this.chunkCount = 0,
        this.bwEstimate = 0,
        this.loading = {
            start: 0,
            first: 0,
            end: 0
        },
        this.parsing = {
            start: 0,
            end: 0
        },
        this.buffering = {
            start: 0,
            first: 0,
            end: 0
        }
    }
}
var xe = {
    AUDIO: "audio",
    VIDEO: "video",
    AUDIOVIDEO: "audiovideo"
};
class Xp {
    constructor(e) {
        this._byteRange = null,
        this._url = null,
        this._stats = null,
        this._streams = null,
        this.base = void 0,
        this.relurl = void 0,
        typeof e == "string" && (e = {
            url: e
        }),
        this.base = e,
        ZS(this, "stats")
    }
    setByteRange(e, t) {
        const n = e.split("@", 2);
        let r;
        n.length === 1 ? r = (t == null ? void 0 : t.byteRangeEndOffset) || 0 : r = parseInt(n[1]),
        this._byteRange = [r, parseInt(n[0]) + r]
    }
    get baseurl() {
        return this.base.url
    }
    get byteRange() {
        return this._byteRange === null ? [] : this._byteRange
    }
    get byteRangeStartOffset() {
        return this.byteRange[0]
    }
    get byteRangeEndOffset() {
        return this.byteRange[1]
    }
    get elementaryStreams() {
        return this._streams === null && (this._streams = {
            [xe.AUDIO]: null,
            [xe.VIDEO]: null,
            [xe.AUDIOVIDEO]: null
        }),
        this._streams
    }
    set elementaryStreams(e) {
        this._streams = e
    }
    get hasStats() {
        return this._stats !== null
    }
    get hasStreams() {
        return this._streams !== null
    }
    get stats() {
        return this._stats === null && (this._stats = new hd),
        this._stats
    }
    set stats(e) {
        this._stats = e
    }
    get url() {
        return !this._url && this.baseurl && this.relurl && (this._url = dd.buildAbsoluteURL(this.baseurl, this.relurl, {
            alwaysNormalize: !0
        })),
        this._url || ""
    }
    set url(e) {
        this._url = e
    }
    clearElementaryStreamInfo() {
        const {elementaryStreams: e} = this;
        e[xe.AUDIO] = null,
        e[xe.VIDEO] = null,
        e[xe.AUDIOVIDEO] = null
    }
}
function Fe(s) {
    return s.sn !== "initSegment"
}
class Cl extends Xp {
    constructor(e, t) {
        super(t),
        this._decryptdata = null,
        this._programDateTime = null,
        this._ref = null,
        this._bitrate = void 0,
        this.rawProgramDateTime = null,
        this.tagList = [],
        this.duration = 0,
        this.sn = 0,
        this.levelkeys = void 0,
        this.type = void 0,
        this.loader = null,
        this.keyLoader = null,
        this.level = -1,
        this.cc = 0,
        this.startPTS = void 0,
        this.endPTS = void 0,
        this.startDTS = void 0,
        this.endDTS = void 0,
        this.start = 0,
        this.playlistOffset = 0,
        this.deltaPTS = void 0,
        this.maxStartPTS = void 0,
        this.minEndPTS = void 0,
        this.data = void 0,
        this.bitrateTest = !1,
        this.title = null,
        this.initSegment = null,
        this.endList = void 0,
        this.gap = void 0,
        this.urlId = 0,
        this.type = e
    }
    get byteLength() {
        if (this.hasStats) {
            const e = this.stats.total;
            if (e)
                return e
        }
        if (this.byteRange.length) {
            const e = this.byteRange[0]
              , t = this.byteRange[1];
            if (z(e) && z(t))
                return t - e
        }
        return null
    }
    get bitrate() {
        return this.byteLength ? this.byteLength * 8 / this.duration : this._bitrate ? this._bitrate : null
    }
    set bitrate(e) {
        this._bitrate = e
    }
    get decryptdata() {
        const {levelkeys: e} = this;
        if (!e && !this._decryptdata)
            return null;
        if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
            const t = this.levelkeys.identity;
            if (t)
                this._decryptdata = t.getDecryptData(this.sn);
            else {
                const n = Object.keys(this.levelkeys);
                if (n.length === 1) {
                    const r = this._decryptdata = this.levelkeys[n[0]] || null;
                    if (r)
                        return r.getDecryptData(this.sn)
                }
            }
        }
        return this._decryptdata
    }
    get end() {
        return this.start + this.duration
    }
    get endProgramDateTime() {
        if (this.programDateTime === null)
            return null;
        const e = z(this.duration) ? this.duration : 0;
        return this.programDateTime + e * 1e3
    }
    get encrypted() {
        var e;
        if ((e = this._decryptdata) != null && e.encrypted)
            return !0;
        if (this.levelkeys) {
            var t;
            const n = Object.keys(this.levelkeys)
              , r = n.length;
            if (r > 1 || r === 1 && (t = this.levelkeys[n[0]]) != null && t.encrypted)
                return !0
        }
        return !1
    }
    get programDateTime() {
        return this._programDateTime === null && this.rawProgramDateTime && (this.programDateTime = Date.parse(this.rawProgramDateTime)),
        this._programDateTime
    }
    set programDateTime(e) {
        if (!z(e)) {
            this._programDateTime = this.rawProgramDateTime = null;
            return
        }
        this._programDateTime = e
    }
    get ref() {
        return Fe(this) ? (this._ref || (this._ref = {
            base: this.base,
            start: this.start,
            duration: this.duration,
            sn: this.sn,
            programDateTime: this.programDateTime
        }),
        this._ref) : null
    }
    addStart(e) {
        this.setStart(this.start + e)
    }
    setStart(e) {
        this.start = e,
        this._ref && (this._ref.start = e)
    }
    setDuration(e) {
        this.duration = e,
        this._ref && (this._ref.duration = e)
    }
    setKeyFormat(e) {
        if (this.levelkeys) {
            const t = this.levelkeys[e];
            t && !this._decryptdata && (this._decryptdata = t.getDecryptData(this.sn))
        }
    }
    abortRequests() {
        var e, t;
        (e = this.loader) == null || e.abort(),
        (t = this.keyLoader) == null || t.abort()
    }
    setElementaryStreamInfo(e, t, n, r, i, a=!1) {
        const {elementaryStreams: o} = this
          , l = o[e];
        if (!l) {
            o[e] = {
                startPTS: t,
                endPTS: n,
                startDTS: r,
                endDTS: i,
                partial: a
            };
            return
        }
        l.startPTS = Math.min(l.startPTS, t),
        l.endPTS = Math.max(l.endPTS, n),
        l.startDTS = Math.min(l.startDTS, r),
        l.endDTS = Math.max(l.endDTS, i)
    }
}
class XS extends Xp {
    constructor(e, t, n, r, i) {
        super(n),
        this.fragOffset = 0,
        this.duration = 0,
        this.gap = !1,
        this.independent = !1,
        this.relurl = void 0,
        this.fragment = void 0,
        this.index = void 0,
        this.duration = e.decimalFloatingPoint("DURATION"),
        this.gap = e.bool("GAP"),
        this.independent = e.bool("INDEPENDENT"),
        this.relurl = e.enumeratedString("URI"),
        this.fragment = t,
        this.index = r;
        const a = e.enumeratedString("BYTERANGE");
        a && this.setByteRange(a, i),
        i && (this.fragOffset = i.fragOffset + i.duration)
    }
    get start() {
        return this.fragment.start + this.fragOffset
    }
    get end() {
        return this.start + this.duration
    }
    get loaded() {
        const {elementaryStreams: e} = this;
        return !!(e.audio || e.video || e.audiovideo)
    }
}
function Zp(s, e) {
    const t = Object.getPrototypeOf(s);
    if (t) {
        const n = Object.getOwnPropertyDescriptor(t, e);
        return n || Zp(t, e)
    }
}
function ZS(s, e) {
    const t = Zp(s, e);
    t && (t.enumerable = !0,
    Object.defineProperty(s, e, t))
}
const tf = Math.pow(2, 32) - 1
  , qS = [].push
  , qp = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
};
function je(s) {
    return String.fromCharCode.apply(null, s)
}
function Qp(s, e) {
    const t = s[e] << 8 | s[e + 1];
    return t < 0 ? 65536 + t : t
}
function ne(s, e) {
    const t = Jp(s, e);
    return t < 0 ? 4294967296 + t : t
}
function sf(s, e) {
    let t = ne(s, e);
    return t *= Math.pow(2, 32),
    t += ne(s, e + 4),
    t
}
function Jp(s, e) {
    return s[e] << 24 | s[e + 1] << 16 | s[e + 2] << 8 | s[e + 3]
}
function QS(s) {
    const e = s.byteLength;
    for (let t = 0; t < e; ) {
        const n = ne(s, t);
        if (n > 8 && s[t + 4] === 109 && s[t + 5] === 111 && s[t + 6] === 111 && s[t + 7] === 102)
            return !0;
        t = n > 1 ? t + n : e
    }
    return !1
}
function ae(s, e) {
    const t = [];
    if (!e.length)
        return t;
    const n = s.byteLength;
    for (let r = 0; r < n; ) {
        const i = ne(s, r)
          , a = je(s.subarray(r + 4, r + 8))
          , o = i > 1 ? r + i : n;
        if (a === e[0])
            if (e.length === 1)
                t.push(s.subarray(r + 8, o));
            else {
                const l = ae(s.subarray(r + 8, o), e.slice(1));
                l.length && qS.apply(t, l)
            }
        r = o
    }
    return t
}
function JS(s) {
    const e = []
      , t = s[0];
    let n = 8;
    const r = ne(s, n);
    n += 4;
    let i = 0
      , a = 0;
    t === 0 ? (i = ne(s, n),
    a = ne(s, n + 4),
    n += 8) : (i = sf(s, n),
    a = sf(s, n + 8),
    n += 16),
    n += 2;
    let o = s.length + a;
    const l = Qp(s, n);
    n += 2;
    for (let c = 0; c < l; c++) {
        let u = n;
        const d = ne(s, u);
        u += 4;
        const h = d & 2147483647;
        if ((d & 2147483648) >>> 31 === 1)
            return fe.warn("SIDX has hierarchical references (not supported)"),
            null;
        const m = ne(s, u);
        u += 4,
        e.push({
            referenceSize: h,
            subsegmentDuration: m,
            info: {
                duration: m / r,
                start: o,
                end: o + h - 1
            }
        }),
        o += h,
        u += 4,
        n = u
    }
    return {
        earliestPresentationTime: i,
        timescale: r,
        version: t,
        referencesCount: l,
        references: e
    }
}
function e0(s) {
    const e = []
      , t = ae(s, ["moov", "trak"]);
    for (let r = 0; r < t.length; r++) {
        const i = t[r]
          , a = ae(i, ["tkhd"])[0];
        if (a) {
            let o = a[0];
            const l = ne(a, o === 0 ? 12 : 20)
              , c = ae(i, ["mdia", "mdhd"])[0];
            if (c) {
                o = c[0];
                const u = ne(c, o === 0 ? 12 : 20)
                  , d = ae(i, ["mdia", "hdlr"])[0];
                if (d) {
                    const h = je(d.subarray(8, 12))
                      , f = {
                        soun: xe.AUDIO,
                        vide: xe.VIDEO
                    }[h]
                      , m = ae(i, ["mdia", "minf", "stbl", "stsd"])[0]
                      , p = eT(m);
                    f ? (e[l] = {
                        timescale: u,
                        type: f,
                        stsd: p
                    },
                    e[f] = pe({
                        timescale: u,
                        id: l
                    }, p)) : e[l] = {
                        timescale: u,
                        type: h,
                        stsd: p
                    }
                }
            }
        }
    }
    return ae(s, ["moov", "mvex", "trex"]).forEach(r => {
        const i = ne(r, 4)
          , a = e[i];
        a && (a.default = {
            duration: ne(r, 12),
            flags: ne(r, 20)
        })
    }
    ),
    e
}
function eT(s) {
    const e = s.subarray(8)
      , t = e.subarray(86)
      , n = je(e.subarray(4, 8));
    let r = n, i;
    const a = n === "enca" || n === "encv";
    if (a) {
        const c = ae(e, [n])[0].subarray(n === "enca" ? 28 : 78);
        ae(c, ["sinf"]).forEach(d => {
            const h = ae(d, ["schm"])[0];
            if (h) {
                const f = je(h.subarray(4, 8));
                if (f === "cbcs" || f === "cenc") {
                    const m = ae(d, ["frma"])[0];
                    m && (r = je(m))
                }
            }
        }
        )
    }
    const o = r;
    switch (r) {
    case "avc1":
    case "avc2":
    case "avc3":
    case "avc4":
        {
            const l = ae(t, ["avcC"])[0];
            l && l.length > 3 && (r += "." + la(l[1]) + la(l[2]) + la(l[3]),
            i = oa(o === "avc1" ? "dva1" : "dvav", t));
            break
        }
    case "mp4a":
        {
            const l = ae(e, [n])[0]
              , c = ae(l.subarray(28), ["esds"])[0];
            if (c && c.length > 7) {
                let u = 4;
                if (c[u++] !== 3)
                    break;
                u = kl(c, u),
                u += 2;
                const d = c[u++];
                if (d & 128 && (u += 2),
                d & 64 && (u += c[u++]),
                c[u++] !== 4)
                    break;
                u = kl(c, u);
                const h = c[u++];
                if (h === 64)
                    r += "." + la(h);
                else
                    break;
                if (u += 12,
                c[u++] !== 5)
                    break;
                u = kl(c, u);
                const f = c[u++];
                let m = (f & 248) >> 3;
                m === 31 && (m += 1 + ((f & 7) << 3) + ((c[u] & 224) >> 5)),
                r += "." + m
            }
            break
        }
    case "hvc1":
    case "hev1":
        {
            const l = ae(t, ["hvcC"])[0];
            if (l && l.length > 12) {
                const c = l[1]
                  , u = ["", "A", "B", "C"][c >> 6]
                  , d = c & 31
                  , h = ne(l, 2)
                  , f = (c & 32) >> 5 ? "H" : "L"
                  , m = l[12]
                  , p = l.subarray(6, 12);
                r += "." + u + d,
                r += "." + tT(h).toString(16).toUpperCase(),
                r += "." + f + m;
                let x = "";
                for (let y = p.length; y--; ) {
                    const v = p[y];
                    (v || x) && (x = "." + v.toString(16).toUpperCase() + x)
                }
                r += x
            }
            i = oa(o == "hev1" ? "dvhe" : "dvh1", t);
            break
        }
    case "dvh1":
    case "dvhe":
    case "dvav":
    case "dva1":
    case "dav1":
        {
            r = oa(r, t) || r;
            break
        }
    case "vp09":
        {
            const l = ae(t, ["vpcC"])[0];
            if (l && l.length > 6) {
                const c = l[4]
                  , u = l[5]
                  , d = l[6] >> 4 & 15;
                r += "." + is(c) + "." + is(u) + "." + is(d)
            }
            break
        }
    case "av01":
        {
            const l = ae(t, ["av1C"])[0];
            if (l && l.length > 2) {
                const c = l[1] >>> 5
                  , u = l[1] & 31
                  , d = l[2] >>> 7 ? "H" : "M"
                  , h = (l[2] & 64) >> 6
                  , f = (l[2] & 32) >> 5
                  , m = c === 2 && h ? f ? 12 : 10 : h ? 10 : 8
                  , p = (l[2] & 16) >> 4
                  , x = (l[2] & 8) >> 3
                  , y = (l[2] & 4) >> 2
                  , v = l[2] & 3;
                r += "." + c + "." + is(u) + d + "." + is(m) + "." + p + "." + x + y + v + "." + is(1) + "." + is(1) + "." + is(1) + "." + 0,
                i = oa("dav1", t)
            }
            break
        }
    }
    return {
        codec: r,
        encrypted: a,
        supplemental: i
    }
}
function oa(s, e) {
    const t = ae(e, ["dvvC"])
      , n = t.length ? t[0] : ae(e, ["dvcC"])[0];
    if (n) {
        const r = n[2] >> 1 & 127
          , i = n[2] << 5 & 32 | n[3] >> 3 & 31;
        return s + "." + is(r) + "." + is(i)
    }
}
function tT(s) {
    let e = 0;
    for (let t = 0; t < 32; t++)
        e |= (s >> t & 1) << 31 - t;
    return e >>> 0
}
function kl(s, e) {
    const t = e + 5;
    for (; s[e++] & 128 && e < t; )
        ;
    return e
}
function la(s) {
    return ("0" + s.toString(16).toUpperCase()).slice(-2)
}
function is(s) {
    return (s < 10 ? "0" : "") + s
}
function sT(s, e) {
    if (!s || !e)
        return;
    const t = e.keyId;
    t && e.isCommonEncryption && ae(s, ["moov", "trak"]).forEach(r => {
        const a = ae(r, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8);
        let o = ae(a, ["enca"]);
        const l = o.length > 0;
        l || (o = ae(a, ["encv"])),
        o.forEach(c => {
            const u = l ? c.subarray(28) : c.subarray(78);
            ae(u, ["sinf"]).forEach(h => {
                const f = t0(h);
                if (f) {
                    const m = f.subarray(8, 24);
                    m.some(p => p !== 0) || (fe.log(`[eme] Patching keyId in 'enc${l ? "a" : "v"}>sinf>>tenc' box: ${It(m)} -> ${It(t)}`),
                    f.set(t, 8))
                }
            }
            )
        }
        )
    }
    )
}
function t0(s) {
    const e = ae(s, ["schm"])[0];
    if (e) {
        const t = je(e.subarray(4, 8));
        if (t === "cbcs" || t === "cenc")
            return ae(s, ["schi", "tenc"])[0]
    }
    return null
}
function nT(s, e, t) {
    const n = {}
      , r = ae(s, ["moof", "traf"]);
    for (let i = 0; i < r.length; i++) {
        const a = r[i]
          , o = ae(a, ["tfhd"])[0]
          , l = ne(o, 4)
          , c = e[l];
        if (!c)
            continue;
        n[l] || (n[l] = {
            start: NaN,
            duration: 0,
            sampleCount: 0,
            timescale: c.timescale,
            type: c.type
        });
        const u = n[l]
          , d = ae(a, ["tfdt"])[0];
        if (d) {
            const E = d[0];
            let T = ne(d, 4);
            E === 1 && (T === tf ? t.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time") : (T *= tf + 1,
            T += ne(d, 8))),
            z(T) && (!z(u.start) || T < u.start) && (u.start = T)
        }
        const h = c.default
          , f = ne(o, 0) | (h == null ? void 0 : h.flags);
        let m = (h == null ? void 0 : h.duration) || 0;
        f & 8 && (f & 2 ? m = ne(o, 12) : m = ne(o, 8));
        const p = ae(a, ["trun"]);
        let x = u.start || 0
          , y = 0
          , v = m;
        for (let E = 0; E < p.length; E++) {
            const T = p[E]
              , L = ne(T, 4)
              , R = u.sampleCount;
            u.sampleCount += L;
            const I = T[3] & 1
              , A = T[3] & 4
              , C = T[2] & 1
              , b = T[2] & 2
              , O = T[2] & 4
              , _ = T[2] & 8;
            let $ = 8
              , K = L;
            for (I && ($ += 4),
            A && L && (!(T[$ + 1] & 1) && u.keyFrameIndex === void 0 && (u.keyFrameIndex = R),
            $ += 4,
            C ? (v = ne(T, $),
            $ += 4) : v = m,
            b && ($ += 4),
            _ && ($ += 4),
            x += v,
            y += v,
            K--); K--; )
                C ? (v = ne(T, $),
                $ += 4) : v = m,
                b && ($ += 4),
                O && (T[$ + 1] & 1 || u.keyFrameIndex === void 0 && (u.keyFrameIndex = u.sampleCount - (K + 1),
                u.keyFrameStart = x),
                $ += 4),
                _ && ($ += 4),
                x += v,
                y += v;
            !y && m && (y += m * L)
        }
        u.duration += y
    }
    if (!Object.keys(n).some(i => n[i].duration)) {
        let i = 1 / 0
          , a = 0;
        const o = ae(s, ["sidx"]);
        for (let l = 0; l < o.length; l++) {
            const c = JS(o[l]);
            if (c != null && c.references) {
                i = Math.min(i, c.earliestPresentationTime / c.timescale);
                const u = c.references.reduce( (d, h) => d + h.info.duration || 0, 0);
                a = Math.max(a, u + c.earliestPresentationTime / c.timescale)
            }
        }
        a && z(a) && Object.keys(n).forEach(l => {
            n[l].duration || (n[l].duration = a * n[l].timescale - n[l].start)
        }
        )
    }
    return n
}
function rT(s) {
    const e = {
        valid: null,
        remainder: null
    }
      , t = ae(s, ["moof"]);
    if (t.length < 2)
        return e.remainder = s,
        e;
    const n = t[t.length - 1];
    return e.valid = s.slice(0, n.byteOffset - 8),
    e.remainder = s.slice(n.byteOffset - 8),
    e
}
function jt(s, e) {
    const t = new Uint8Array(s.length + e.length);
    return t.set(s),
    t.set(e, s.length),
    t
}
function nf(s, e) {
    const t = []
      , n = e.samples
      , r = e.timescale
      , i = e.id;
    let a = !1;
    return ae(n, ["moof"]).map(l => {
        const c = l.byteOffset - 8;
        ae(l, ["traf"]).map(d => {
            const h = ae(d, ["tfdt"]).map(f => {
                const m = f[0];
                let p = ne(f, 4);
                return m === 1 && (p *= Math.pow(2, 32),
                p += ne(f, 8)),
                p / r
            }
            )[0];
            return h !== void 0 && (s = h),
            ae(d, ["tfhd"]).map(f => {
                const m = ne(f, 4)
                  , p = ne(f, 0) & 16777215
                  , x = (p & 1) !== 0
                  , y = (p & 2) !== 0
                  , v = (p & 8) !== 0;
                let E = 0;
                const T = (p & 16) !== 0;
                let L = 0;
                const R = (p & 32) !== 0;
                let I = 8;
                m === i && (x && (I += 8),
                y && (I += 4),
                v && (E = ne(f, I),
                I += 4),
                T && (L = ne(f, I),
                I += 4),
                R && (I += 4),
                e.type === "video" && (a = Yo(e.codec)),
                ae(d, ["trun"]).map(A => {
                    const C = A[0]
                      , b = ne(A, 0) & 16777215
                      , O = (b & 1) !== 0;
                    let _ = 0;
                    const $ = (b & 4) !== 0
                      , K = (b & 256) !== 0;
                    let W = 0;
                    const G = (b & 512) !== 0;
                    let V = 0;
                    const D = (b & 1024) !== 0
                      , B = (b & 2048) !== 0;
                    let k = 0;
                    const F = ne(A, 4);
                    let j = 8;
                    O && (_ = ne(A, j),
                    j += 4),
                    $ && (j += 4);
                    let J = _ + c;
                    for (let re = 0; re < F; re++) {
                        if (K ? (W = ne(A, j),
                        j += 4) : W = E,
                        G ? (V = ne(A, j),
                        j += 4) : V = L,
                        D && (j += 4),
                        B && (C === 0 ? k = ne(A, j) : k = Jp(A, j),
                        j += 4),
                        e.type === xe.VIDEO) {
                            let Q = 0;
                            for (; Q < V; ) {
                                const se = ne(n, J);
                                if (J += 4,
                                iT(a, n[J])) {
                                    const Le = n.subarray(J, J + se);
                                    fd(Le, a ? 2 : 1, s + k / r, t)
                                }
                                J += se,
                                Q += se + 4
                            }
                        }
                        s += W / r
                    }
                }
                ))
            }
            )
        }
        )
    }
    ),
    t
}
function Yo(s) {
    if (!s)
        return !1;
    const e = s.substring(0, 4);
    return e === "hvc1" || e === "hev1" || e === "dvh1" || e === "dvhe"
}
function iT(s, e) {
    if (s) {
        const t = e >> 1 & 63;
        return t === 39 || t === 40
    } else
        return (e & 31) === 6
}
function fd(s, e, t, n) {
    const r = s0(s);
    let i = 0;
    i += e;
    let a = 0
      , o = 0
      , l = 0;
    for (; i < r.length; ) {
        a = 0;
        do {
            if (i >= r.length)
                break;
            l = r[i++],
            a += l
        } while (l === 255);
        o = 0;
        do {
            if (i >= r.length)
                break;
            l = r[i++],
            o += l
        } while (l === 255);
        const c = r.length - i;
        let u = i;
        if (o < c)
            i += o;
        else if (o > c) {
            fe.error(`Malformed SEI payload. ${o} is too small, only ${c} bytes left to parse.`);
            break
        }
        if (a === 4) {
            if (r[u++] === 181) {
                const h = Qp(r, u);
                if (u += 2,
                h === 49) {
                    const f = ne(r, u);
                    if (u += 4,
                    f === 1195456820) {
                        const m = r[u++];
                        if (m === 3) {
                            const p = r[u++]
                              , x = 31 & p
                              , y = 64 & p
                              , v = y ? 2 + x * 3 : 0
                              , E = new Uint8Array(v);
                            if (y) {
                                E[0] = p;
                                for (let T = 1; T < v; T++)
                                    E[T] = r[u++]
                            }
                            n.push({
                                type: m,
                                payloadType: a,
                                pts: t,
                                bytes: E
                            })
                        }
                    }
                }
            }
        } else if (a === 5 && o > 16) {
            const d = [];
            for (let m = 0; m < 16; m++) {
                const p = r[u++].toString(16);
                d.push(p.length == 1 ? "0" + p : p),
                (m === 3 || m === 5 || m === 7 || m === 9) && d.push("-")
            }
            const h = o - 16
              , f = new Uint8Array(h);
            for (let m = 0; m < h; m++)
                f[m] = r[u++];
            n.push({
                payloadType: a,
                pts: t,
                uuid: d.join(""),
                userData: wt(f),
                userDataBytes: f
            })
        }
    }
}
function s0(s) {
    const e = s.byteLength
      , t = [];
    let n = 1;
    for (; n < e - 2; )
        s[n] === 0 && s[n + 1] === 0 && s[n + 2] === 3 ? (t.push(n + 2),
        n += 2) : n++;
    if (t.length === 0)
        return s;
    const r = e - t.length
      , i = new Uint8Array(r);
    let a = 0;
    for (n = 0; n < r; a++,
    n++)
        a === t[0] && (a++,
        t.shift()),
        i[n] = s[a];
    return i
}
function aT(s) {
    const e = s[0];
    let t = ""
      , n = ""
      , r = 0
      , i = 0
      , a = 0
      , o = 0
      , l = 0
      , c = 0;
    if (e === 0) {
        for (; je(s.subarray(c, c + 1)) !== "\0"; )
            t += je(s.subarray(c, c + 1)),
            c += 1;
        for (t += je(s.subarray(c, c + 1)),
        c += 1; je(s.subarray(c, c + 1)) !== "\0"; )
            n += je(s.subarray(c, c + 1)),
            c += 1;
        n += je(s.subarray(c, c + 1)),
        c += 1,
        r = ne(s, 12),
        i = ne(s, 16),
        o = ne(s, 20),
        l = ne(s, 24),
        c = 28
    } else if (e === 1) {
        c += 4,
        r = ne(s, c),
        c += 4;
        const d = ne(s, c);
        c += 4;
        const h = ne(s, c);
        for (c += 4,
        a = 2 ** 32 * d + h,
        FS(a) || (a = Number.MAX_SAFE_INTEGER,
        fe.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")),
        o = ne(s, c),
        c += 4,
        l = ne(s, c),
        c += 4; je(s.subarray(c, c + 1)) !== "\0"; )
            t += je(s.subarray(c, c + 1)),
            c += 1;
        for (t += je(s.subarray(c, c + 1)),
        c += 1; je(s.subarray(c, c + 1)) !== "\0"; )
            n += je(s.subarray(c, c + 1)),
            c += 1;
        n += je(s.subarray(c, c + 1)),
        c += 1
    }
    const u = s.subarray(c, s.byteLength);
    return {
        schemeIdUri: t,
        value: n,
        timeScale: r,
        presentationTime: a,
        presentationTimeDelta: i,
        eventDuration: o,
        id: l,
        payload: u
    }
}
function oT(s, ...e) {
    const t = e.length;
    let n = 8
      , r = t;
    for (; r--; )
        n += e[r].byteLength;
    const i = new Uint8Array(n);
    for (i[0] = n >> 24 & 255,
    i[1] = n >> 16 & 255,
    i[2] = n >> 8 & 255,
    i[3] = n & 255,
    i.set(s, 4),
    r = 0,
    n = 8; r < t; r++)
        i.set(e[r], n),
        n += e[r].byteLength;
    return i
}
function lT(s, e, t) {
    if (s.byteLength !== 16)
        throw new RangeError("Invalid system id");
    let n, r;
    n = 0,
    r = new Uint8Array;
    let i;
    n > 0 ? (i = new Uint8Array(4),
    e.length > 0 && new DataView(i.buffer).setUint32(0, e.length, !1)) : i = new Uint8Array;
    const a = new Uint8Array(4);
    return t.byteLength > 0 && new DataView(a.buffer).setUint32(0, t.byteLength, !1),
    oT([112, 115, 115, 104], new Uint8Array([n, 0, 0, 0]), s, i, r, a, t)
}
const n0 = () => /\(Windows.+Firefox\//i.test(navigator.userAgent)
  , Lr = {
    audio: {
        a3ds: 1,
        "ac-3": .95,
        "ac-4": 1,
        alac: .9,
        alaw: 1,
        dra1: 1,
        "dts+": 1,
        "dts-": 1,
        dtsc: 1,
        dtse: 1,
        dtsh: 1,
        "ec-3": .9,
        enca: 1,
        fLaC: .9,
        flac: .9,
        FLAC: .9,
        g719: 1,
        g726: 1,
        m4ae: 1,
        mha1: 1,
        mha2: 1,
        mhm1: 1,
        mhm2: 1,
        mlpa: 1,
        mp4a: 1,
        "raw ": 1,
        Opus: 1,
        opus: 1,
        samr: 1,
        sawb: 1,
        sawp: 1,
        sevc: 1,
        sqcp: 1,
        ssmv: 1,
        twos: 1,
        ulaw: 1
    },
    video: {
        avc1: 1,
        avc2: 1,
        avc3: 1,
        avc4: 1,
        avcp: 1,
        av01: .8,
        dav1: .8,
        drac: 1,
        dva1: 1,
        dvav: 1,
        dvh1: .7,
        dvhe: .7,
        encv: 1,
        hev1: .75,
        hvc1: .75,
        mjp2: 1,
        mp4v: 1,
        mvc1: 1,
        mvc2: 1,
        mvc3: 1,
        mvc4: 1,
        resv: 1,
        rv60: 1,
        s263: 1,
        svc1: 1,
        svc2: 1,
        "vc-1": 1,
        vp08: 1,
        vp09: .9
    },
    text: {
        stpp: 1,
        wvtt: 1
    }
};
function md(s, e) {
    const t = Lr[e];
    return !!t && !!t[s.slice(0, 4)]
}
function Yc(s, e, t=!0) {
    return !s.split(",").some(n => !gd(n, e, t))
}
function gd(s, e, t=!0) {
    var n;
    const r = on(t);
    return (n = r == null ? void 0 : r.isTypeSupported(Ai(s, e))) != null ? n : !1
}
function Ai(s, e) {
    return `${e}/mp4;codecs=${s}`
}
function rf(s) {
    if (s) {
        const e = s.substring(0, 4);
        return Lr.video[e]
    }
    return 2
}
function vo(s) {
    const e = n0();
    return s.split(",").reduce( (t, n) => {
        const i = e && Yo(n) ? 9 : Lr.video[n];
        return i ? (i * 2 + t) / (t ? 3 : 2) : (Lr.audio[n] + t) / (t ? 2 : 1)
    }
    , 0)
}
const _l = {};
function cT(s, e=!0) {
    if (_l[s])
        return _l[s];
    const t = {
        flac: ["flac", "fLaC", "FLAC"],
        opus: ["opus", "Opus"],
        "mp4a.40.34": ["mp3"]
    }[s];
    for (let r = 0; r < t.length; r++) {
        var n;
        if (gd(t[r], "audio", e))
            return _l[s] = t[r],
            t[r];
        if (t[r] === "mp3" && (n = on(e)) != null && n.isTypeSupported("audio/mpeg"))
            return ""
    }
    return s
}
const uT = /flac|opus|mp4a\.40\.34/i;
function Eo(s, e=!0) {
    return s.replace(uT, t => cT(t.toLowerCase(), e))
}
function dT(s, e) {
    const t = [];
    if (s) {
        const n = s.split(",");
        for (let r = 0; r < n.length; r++)
            md(n[r], "video") || t.push(n[r])
    }
    return e && t.push(e),
    t.join(",")
}
function Ma(s, e) {
    if (s && (s.length > 4 || ["ac-3", "ec-3", "alac", "fLaC", "Opus"].indexOf(s) !== -1) && (af(s, "audio") || af(s, "video")))
        return s;
    if (e) {
        const t = e.split(",");
        if (t.length > 1) {
            if (s) {
                for (let n = t.length; n--; )
                    if (t[n].substring(0, 4) === s.substring(0, 4))
                        return t[n]
            }
            return t[0]
        }
    }
    return e || s
}
function af(s, e) {
    return md(s, e) && gd(s, e)
}
function hT(s) {
    const e = s.split(",");
    for (let t = 0; t < e.length; t++) {
        const n = e[t].split(".");
        n.length > 2 && n[0] === "avc1" && (e[t] = `avc1.${parseInt(n[1]).toString(16)}${("000" + parseInt(n[2]).toString(16)).slice(-4)}`)
    }
    return e.join(",")
}
function fT(s) {
    if (s.startsWith("av01.")) {
        const e = s.split(".")
          , t = ["0", "111", "01", "01", "01", "0"];
        for (let n = e.length; n > 4 && n < 10; n++)
            e[n] = t[n - 4];
        return e.join(".")
    }
    return s
}
function of(s) {
    const e = on(s) || {
        isTypeSupported: () => !1
    };
    return {
        mpeg: e.isTypeSupported("audio/mpeg"),
        mp3: e.isTypeSupported('audio/mp4; codecs="mp3"'),
        ac3: e.isTypeSupported('audio/mp4; codecs="ac-3"')
    }
}
function Xc(s) {
    return s.replace(/^.+codecs=["']?([^"']+).*$/, "$1")
}
const mT = {
    supported: !0,
    powerEfficient: !0,
    smooth: !0
}
  , gT = {
    supported: !1,
    smooth: !1,
    powerEfficient: !1
}
  , r0 = {
    supported: !0,
    configurations: [],
    decodingInfoResults: [mT]
};
function i0(s, e) {
    return {
        supported: !1,
        configurations: e,
        decodingInfoResults: [gT],
        error: s
    }
}
function pT(s, e, t, n, r, i) {
    const a = s.videoCodec
      , o = s.audioCodec ? s.audioGroups : null
      , l = i == null ? void 0 : i.audioCodec
      , c = i == null ? void 0 : i.channels
      , u = c ? parseInt(c) : l ? 1 / 0 : 2;
    let d = null;
    if (o != null && o.length)
        try {
            o.length === 1 && o[0] ? d = e.groups[o[0]].channels : d = o.reduce( (h, f) => {
                if (f) {
                    const m = e.groups[f];
                    if (!m)
                        throw new Error(`Audio track group ${f} not found`);
                    Object.keys(m.channels).forEach(p => {
                        h[p] = (h[p] || 0) + m.channels[p]
                    }
                    )
                }
                return h
            }
            , {
                2: 0
            })
        } catch {
            return !0
        }
    return a !== void 0 && (a.split(",").some(h => Yo(h)) || s.width > 1920 && s.height > 1088 || s.height > 1920 && s.width > 1088 || s.frameRate > Math.max(n, 30) || s.videoRange !== "SDR" && s.videoRange !== t || s.bitrate > Math.max(r, 8e6)) || !!d && z(u) && Object.keys(d).some(h => parseInt(h) > u)
}
function a0(s, e, t, n={}) {
    const r = s.videoCodec;
    if (!r && !s.audioCodec || !t)
        return Promise.resolve(r0);
    const i = []
      , a = yT(s)
      , o = a.length
      , l = xT(s, e, o > 0)
      , c = l.length;
    for (let u = o || 1 * c || 1; u--; ) {
        const d = {
            type: "media-source"
        };
        if (o && (d.video = a[u % o]),
        c) {
            d.audio = l[u % c];
            const h = d.audio.bitrate;
            d.video && h && (d.video.bitrate -= h)
        }
        i.push(d)
    }
    if (r) {
        const u = navigator.userAgent;
        if (r.split(",").some(d => Yo(d)) && n0())
            return Promise.resolve(i0(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${u})`), i))
    }
    return Promise.all(i.map(u => {
        const d = ET(u);
        return n[d] || (n[d] = t.decodingInfo(u))
    }
    )).then(u => ({
        supported: !u.some(d => !d.supported),
        configurations: i,
        decodingInfoResults: u
    })).catch(u => ({
        supported: !1,
        configurations: i,
        decodingInfoResults: [],
        error: u
    }))
}
function yT(s) {
    var e;
    const t = (e = s.videoCodec) == null ? void 0 : e.split(",")
      , n = o0(s)
      , r = s.width || 640
      , i = s.height || 480
      , a = s.frameRate || 30
      , o = s.videoRange.toLowerCase();
    return t ? t.map(l => {
        const c = {
            contentType: Ai(fT(l), "video"),
            width: r,
            height: i,
            bitrate: n,
            framerate: a
        };
        return o !== "sdr" && (c.transferFunction = o),
        c
    }
    ) : []
}
function xT(s, e, t) {
    var n;
    const r = (n = s.audioCodec) == null ? void 0 : n.split(",")
      , i = o0(s);
    return r && s.audioGroups ? s.audioGroups.reduce( (a, o) => {
        var l;
        const c = o ? (l = e.groups[o]) == null ? void 0 : l.tracks : null;
        return c ? c.reduce( (u, d) => {
            if (d.groupId === o) {
                const h = parseFloat(d.channels || "");
                r.forEach(f => {
                    const m = {
                        contentType: Ai(f, "audio"),
                        bitrate: t ? vT(f, i) : i
                    };
                    h && (m.channels = "" + h),
                    u.push(m)
                }
                )
            }
            return u
        }
        , a) : a
    }
    , []) : []
}
function vT(s, e) {
    if (e <= 1)
        return 1;
    let t = 128e3;
    return s === "ec-3" ? t = 768e3 : s === "ac-3" && (t = 64e4),
    Math.min(e / 2, t)
}
function o0(s) {
    return Math.ceil(Math.max(s.bitrate * .9, s.averageBitrate) / 1e3) * 1e3 || 1
}
function ET(s) {
    let e = "";
    const {audio: t, video: n} = s;
    if (n) {
        const r = Xc(n.contentType);
        e += `${r}_r${n.height}x${n.width}f${Math.ceil(n.framerate)}${n.transferFunction || "sd"}_${Math.ceil(n.bitrate / 1e5)}`
    }
    if (t) {
        const r = Xc(t.contentType);
        e += `${n ? "_" : ""}${r}_c${t.channels}`
    }
    return e
}
const Zc = ["NONE", "TYPE-0", "TYPE-1", null];
function ST(s) {
    return Zc.indexOf(s) > -1
}
const So = ["SDR", "PQ", "HLG"];
function TT(s) {
    return !!s && So.indexOf(s) > -1
}
var Fa = {
    No: "",
    Yes: "YES",
    v2: "v2"
};
function lf(s) {
    const {canSkipUntil: e, canSkipDateRanges: t, age: n} = s
      , r = n < e / 2;
    return e && r ? t ? Fa.v2 : Fa.Yes : Fa.No
}
class cf {
    constructor(e, t, n) {
        this.msn = void 0,
        this.part = void 0,
        this.skip = void 0,
        this.msn = e,
        this.part = t,
        this.skip = n
    }
    addDirectives(e) {
        const t = new self.URL(e);
        return this.msn !== void 0 && t.searchParams.set("_HLS_msn", this.msn.toString()),
        this.part !== void 0 && t.searchParams.set("_HLS_part", this.part.toString()),
        this.skip && t.searchParams.set("_HLS_skip", this.skip),
        t.href
    }
}
class bi {
    constructor(e) {
        if (this._attrs = void 0,
        this.audioCodec = void 0,
        this.bitrate = void 0,
        this.codecSet = void 0,
        this.url = void 0,
        this.frameRate = void 0,
        this.height = void 0,
        this.id = void 0,
        this.name = void 0,
        this.supplemental = void 0,
        this.videoCodec = void 0,
        this.width = void 0,
        this.details = void 0,
        this.fragmentError = 0,
        this.loadError = 0,
        this.loaded = void 0,
        this.realBitrate = 0,
        this.supportedPromise = void 0,
        this.supportedResult = void 0,
        this._avgBitrate = 0,
        this._audioGroups = void 0,
        this._subtitleGroups = void 0,
        this._urlId = 0,
        this.url = [e.url],
        this._attrs = [e.attrs],
        this.bitrate = e.bitrate,
        e.details && (this.details = e.details),
        this.id = e.id || 0,
        this.name = e.name,
        this.width = e.width || 0,
        this.height = e.height || 0,
        this.frameRate = e.attrs.optionalFloat("FRAME-RATE", 0),
        this._avgBitrate = e.attrs.decimalInteger("AVERAGE-BANDWIDTH"),
        this.audioCodec = e.audioCodec,
        this.videoCodec = e.videoCodec,
        this.codecSet = [e.videoCodec, e.audioCodec].filter(n => !!n).map(n => n.substring(0, 4)).join(","),
        "supplemental"in e) {
            var t;
            this.supplemental = e.supplemental;
            const n = (t = e.supplemental) == null ? void 0 : t.videoCodec;
            n && n !== e.videoCodec && (this.codecSet += `,${n.substring(0, 4)}`)
        }
        this.addGroupId("audio", e.attrs.AUDIO),
        this.addGroupId("text", e.attrs.SUBTITLES)
    }
    get maxBitrate() {
        return Math.max(this.realBitrate, this.bitrate)
    }
    get averageBitrate() {
        return this._avgBitrate || this.realBitrate || this.bitrate
    }
    get attrs() {
        return this._attrs[0]
    }
    get codecs() {
        return this.attrs.CODECS || ""
    }
    get pathwayId() {
        return this.attrs["PATHWAY-ID"] || "."
    }
    get videoRange() {
        return this.attrs["VIDEO-RANGE"] || "SDR"
    }
    get score() {
        return this.attrs.optionalFloat("SCORE", 0)
    }
    get uri() {
        return this.url[0] || ""
    }
    hasAudioGroup(e) {
        return uf(this._audioGroups, e)
    }
    hasSubtitleGroup(e) {
        return uf(this._subtitleGroups, e)
    }
    get audioGroups() {
        return this._audioGroups
    }
    get subtitleGroups() {
        return this._subtitleGroups
    }
    addGroupId(e, t) {
        if (t) {
            if (e === "audio") {
                let n = this._audioGroups;
                n || (n = this._audioGroups = []),
                n.indexOf(t) === -1 && n.push(t)
            } else if (e === "text") {
                let n = this._subtitleGroups;
                n || (n = this._subtitleGroups = []),
                n.indexOf(t) === -1 && n.push(t)
            }
        }
    }
    get urlId() {
        return 0
    }
    set urlId(e) {}
    get audioGroupIds() {
        return this.audioGroups ? [this.audioGroupId] : void 0
    }
    get textGroupIds() {
        return this.subtitleGroups ? [this.textGroupId] : void 0
    }
    get audioGroupId() {
        var e;
        return (e = this.audioGroups) == null ? void 0 : e[0]
    }
    get textGroupId() {
        var e;
        return (e = this.subtitleGroups) == null ? void 0 : e[0]
    }
    addFallback() {}
}
function uf(s, e) {
    return !e || !s ? !1 : s.indexOf(e) !== -1
}
function LT() {
    if (typeof matchMedia == "function") {
        const s = matchMedia("(dynamic-range: high)")
          , e = matchMedia("bad query");
        if (s.media !== e.media)
            return s.matches === !0
    }
    return !1
}
function IT(s, e) {
    let t = !1
      , n = [];
    if (s && (t = s !== "SDR",
    n = [s]),
    e) {
        n = e.allowedVideoRanges || So.slice(0);
        const r = n.join("") !== "SDR" && !e.videoCodec;
        t = e.preferHDR !== void 0 ? e.preferHDR : r && LT(),
        t || (n = ["SDR"])
    }
    return {
        preferHDR: t,
        allowedVideoRanges: n
    }
}
const AT = s => {
    const e = new WeakSet;
    return (t, n) => {
        if (s && (n = s(t, n)),
        typeof n == "object" && n !== null) {
            if (e.has(n))
                return;
            e.add(n)
        }
        return n
    }
}
  , Te = (s, e) => JSON.stringify(s, AT(e));
function bT(s, e, t, n, r) {
    const i = Object.keys(s)
      , a = n == null ? void 0 : n.channels
      , o = n == null ? void 0 : n.audioCodec
      , l = r == null ? void 0 : r.videoCodec
      , c = a && parseInt(a) === 2;
    let u = !1
      , d = !1
      , h = 1 / 0
      , f = 1 / 0
      , m = 1 / 0
      , p = 1 / 0
      , x = 0
      , y = [];
    const {preferHDR: v, allowedVideoRanges: E} = IT(e, r);
    for (let A = i.length; A--; ) {
        const C = s[i[A]];
        u || (u = C.channels[2] > 0),
        h = Math.min(h, C.minHeight),
        f = Math.min(f, C.minFramerate),
        m = Math.min(m, C.minBitrate),
        E.filter(O => C.videoRanges[O] > 0).length > 0 && (d = !0)
    }
    h = z(h) ? h : 0,
    f = z(f) ? f : 0;
    const T = Math.max(1080, h)
      , L = Math.max(30, f);
    m = z(m) ? m : t,
    t = Math.max(m, t),
    d || (e = void 0);
    const R = i.length > 1;
    return {
        codecSet: i.reduce( (A, C) => {
            const b = s[C];
            if (C === A)
                return A;
            if (y = d ? E.filter(O => b.videoRanges[O] > 0) : [],
            R) {
                if (b.minBitrate > t)
                    return ss(C, `min bitrate of ${b.minBitrate} > current estimate of ${t}`),
                    A;
                if (!b.hasDefaultAudio)
                    return ss(C, "no renditions with default or auto-select sound found"),
                    A;
                if (o && C.indexOf(o.substring(0, 4)) % 5 !== 0)
                    return ss(C, `audio codec preference "${o}" not found`),
                    A;
                if (a && !c) {
                    if (!b.channels[a])
                        return ss(C, `no renditions with ${a} channel sound found (channels options: ${Object.keys(b.channels)})`),
                        A
                } else if ((!o || c) && u && b.channels[2] === 0)
                    return ss(C, "no renditions with stereo sound found"),
                    A;
                if (b.minHeight > T)
                    return ss(C, `min resolution of ${b.minHeight} > maximum of ${T}`),
                    A;
                if (b.minFramerate > L)
                    return ss(C, `min framerate of ${b.minFramerate} > maximum of ${L}`),
                    A;
                if (!y.some(O => b.videoRanges[O] > 0))
                    return ss(C, `no variants with VIDEO-RANGE of ${Te(y)} found`),
                    A;
                if (l && C.indexOf(l.substring(0, 4)) % 5 !== 0)
                    return ss(C, `video codec preference "${l}" not found`),
                    A;
                if (b.maxScore < x)
                    return ss(C, `max score of ${b.maxScore} < selected max of ${x}`),
                    A
            }
            return A && (vo(C) >= vo(A) || b.fragmentError > s[A].fragmentError) ? A : (p = b.minIndex,
            x = b.maxScore,
            C)
        }
        , void 0),
        videoRanges: y,
        preferHDR: v,
        minFramerate: f,
        minBitrate: m,
        minIndex: p
    }
}
function ss(s, e) {
    fe.log(`[abr] start candidates with "${s}" ignored because ${e}`)
}
function l0(s) {
    return s.reduce( (e, t) => {
        let n = e.groups[t.groupId];
        n || (n = e.groups[t.groupId] = {
            tracks: [],
            channels: {
                2: 0
            },
            hasDefault: !1,
            hasAutoSelect: !1
        }),
        n.tracks.push(t);
        const r = t.channels || "2";
        return n.channels[r] = (n.channels[r] || 0) + 1,
        n.hasDefault = n.hasDefault || t.default,
        n.hasAutoSelect = n.hasAutoSelect || t.autoselect,
        n.hasDefault && (e.hasDefaultAudio = !0),
        n.hasAutoSelect && (e.hasAutoSelectAudio = !0),
        e
    }
    , {
        hasDefaultAudio: !1,
        hasAutoSelectAudio: !1,
        groups: {}
    })
}
function RT(s, e, t, n) {
    return s.slice(t, n + 1).reduce( (r, i, a) => {
        if (!i.codecSet)
            return r;
        const o = i.audioGroups;
        let l = r[i.codecSet];
        l || (r[i.codecSet] = l = {
            minBitrate: 1 / 0,
            minHeight: 1 / 0,
            minFramerate: 1 / 0,
            minIndex: a,
            maxScore: 0,
            videoRanges: {
                SDR: 0
            },
            channels: {
                2: 0
            },
            hasDefaultAudio: !o,
            fragmentError: 0
        }),
        l.minBitrate = Math.min(l.minBitrate, i.bitrate);
        const c = Math.min(i.height, i.width);
        return l.minHeight = Math.min(l.minHeight, c),
        l.minFramerate = Math.min(l.minFramerate, i.frameRate),
        l.minIndex = Math.min(l.minIndex, a),
        l.maxScore = Math.max(l.maxScore, i.score),
        l.fragmentError += i.fragmentError,
        l.videoRanges[i.videoRange] = (l.videoRanges[i.videoRange] || 0) + 1,
        o && o.forEach(u => {
            if (!u)
                return;
            const d = e.groups[u];
            d && (l.hasDefaultAudio = l.hasDefaultAudio || e.hasDefaultAudio ? d.hasDefault : d.hasAutoSelect || !e.hasDefaultAudio && !e.hasAutoSelectAudio,
            Object.keys(d.channels).forEach(h => {
                l.channels[h] = (l.channels[h] || 0) + d.channels[h]
            }
            ))
        }
        ),
        r
    }
    , {})
}
function df(s) {
    if (!s)
        return s;
    const {lang: e, assocLang: t, characteristics: n, channels: r, audioCodec: i} = s;
    return {
        lang: e,
        assocLang: t,
        characteristics: n,
        channels: r,
        audioCodec: i
    }
}
function ls(s, e, t) {
    if ("attrs"in s) {
        const n = e.indexOf(s);
        if (n !== -1)
            return n
    }
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (Rn(s, r, t))
            return n
    }
    return -1
}
function Rn(s, e, t) {
    const {groupId: n, name: r, lang: i, assocLang: a, default: o} = s
      , l = s.forced;
    return (n === void 0 || e.groupId === n) && (r === void 0 || e.name === r) && (i === void 0 || wT(i, e.lang)) && (i === void 0 || e.assocLang === a) && (o === void 0 || e.default === o) && (l === void 0 || e.forced === l) && (!("characteristics"in s) || CT(s.characteristics || "", e.characteristics)) && (t === void 0 || t(s, e))
}
function wT(s, e="--") {
    return s.length === e.length ? s === e : s.startsWith(e) || e.startsWith(s)
}
function CT(s, e="") {
    const t = s.split(",")
      , n = e.split(",");
    return t.length === n.length && !t.some(r => n.indexOf(r) === -1)
}
function Sn(s, e) {
    const {audioCodec: t, channels: n} = s;
    return (t === void 0 || (e.audioCodec || "").substring(0, 4) === t.substring(0, 4)) && (n === void 0 || n === (e.channels || "2"))
}
function kT(s, e, t, n, r) {
    const i = e[n]
      , o = e.reduce( (h, f, m) => {
        const p = f.uri;
        return (h[p] || (h[p] = [])).push(m),
        h
    }
    , {})[i.uri];
    o.length > 1 && (n = Math.max.apply(Math, o));
    const l = i.videoRange
      , c = i.frameRate
      , u = i.codecSet.substring(0, 4)
      , d = hf(e, n, h => {
        if (h.videoRange !== l || h.frameRate !== c || h.codecSet.substring(0, 4) !== u)
            return !1;
        const f = h.audioGroups
          , m = t.filter(p => !f || f.indexOf(p.groupId) !== -1);
        return ls(s, m, r) > -1
    }
    );
    return d > -1 ? d : hf(e, n, h => {
        const f = h.audioGroups
          , m = t.filter(p => !f || f.indexOf(p.groupId) !== -1);
        return ls(s, m, r) > -1
    }
    )
}
function hf(s, e, t) {
    for (let n = e; n > -1; n--)
        if (t(s[n]))
            return n;
    for (let n = e + 1; n < s.length; n++)
        if (t(s[n]))
            return n;
    return -1
}
function To(s, e) {
    var t;
    return !!s && s !== ((t = e.loadLevelObj) == null ? void 0 : t.uri)
}
class _T extends Gt {
    constructor(e) {
        super("abr", e.logger),
        this.hls = void 0,
        this.lastLevelLoadSec = 0,
        this.lastLoadedFragLevel = -1,
        this.firstSelection = -1,
        this._nextAutoLevel = -1,
        this.nextAutoLevelKey = "",
        this.audioTracksByGroup = null,
        this.codecTiers = null,
        this.timer = -1,
        this.fragCurrent = null,
        this.partCurrent = null,
        this.bitrateTestDelay = 0,
        this.rebufferNotice = -1,
        this.supportedCache = {},
        this.bwEstimator = void 0,
        this._abandonRulesCheck = t => {
            var n;
            const {fragCurrent: r, partCurrent: i, hls: a} = this
              , {autoLevelEnabled: o, media: l} = a;
            if (!r || !l)
                return;
            const c = performance.now()
              , u = i ? i.stats : r.stats
              , d = i ? i.duration : r.duration
              , h = c - u.loading.start
              , f = a.minAutoLevel
              , m = r.level
              , p = this._nextAutoLevel;
            if (u.aborted || u.loaded && u.loaded === u.total || m <= f) {
                this.clearTimer(),
                this._nextAutoLevel = -1;
                return
            }
            if (!o)
                return;
            const x = p > -1 && p !== m
              , y = !!t || x;
            if (!y && (l.paused || !l.playbackRate || !l.readyState))
                return;
            const v = a.mainForwardBufferInfo;
            if (!y && v === null)
                return;
            const E = this.bwEstimator.getEstimateTTFB()
              , T = Math.abs(l.playbackRate);
            if (h <= Math.max(E, 1e3 * (d / (T * 2))))
                return;
            const L = v ? v.len / T : 0
              , R = u.loading.first ? u.loading.first - u.loading.start : -1
              , I = u.loaded && R > -1
              , A = this.getBwEstimate()
              , C = a.levels
              , b = C[m]
              , O = Math.max(u.loaded, Math.round(d * (r.bitrate || b.averageBitrate) / 8));
            let _ = I ? h - R : h;
            _ < 1 && I && (_ = Math.min(h, u.loaded * 8 / A));
            const $ = I ? u.loaded * 1e3 / _ : 0
              , K = E / 1e3
              , W = $ ? (O - u.loaded) / $ : O * 8 / A + K;
            if (W <= L)
                return;
            const G = $ ? $ * 8 : A
              , V = ((n = (t == null ? void 0 : t.details) || this.hls.latestLevelDetails) == null ? void 0 : n.live) === !0
              , D = this.hls.config.abrBandWidthUpFactor;
            let B = Number.POSITIVE_INFINITY, k;
            for (k = m - 1; k > f; k--) {
                const re = C[k].maxBitrate
                  , Q = !C[k].details || V;
                if (B = this.getTimeToLoadFrag(K, G, d * re, Q),
                B < Math.min(L, d + K))
                    break
            }
            if (B >= W || B > d * 10)
                return;
            I ? this.bwEstimator.sample(h - Math.min(E, R), u.loaded) : this.bwEstimator.sampleTTFB(h);
            const F = C[k].maxBitrate;
            this.getBwEstimate() * D > F && this.resetEstimator(F);
            const j = this.findBestLevel(F, f, k, 0, L, 1, 1);
            j > -1 && (k = j),
            this.warn(`Fragment ${r.sn}${i ? " part " + i.index : ""} of level ${m} is loading too slowly;
      Fragment duration: ${r.duration.toFixed(3)}
      Time to underbuffer: ${L.toFixed(3)} s
      Estimated load time for current fragment: ${W.toFixed(3)} s
      Estimated load time for down switch fragment: ${B.toFixed(3)} s
      TTFB estimate: ${R | 0} ms
      Current BW estimate: ${z(A) ? A | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${k} @ ${F | 0} bps`),
            a.nextLoadLevel = a.nextAutoLevel = k,
            this.clearTimer();
            const J = () => {
                if (this.clearTimer(),
                this.fragCurrent === r && this.hls.loadLevel === k && k > 0) {
                    const re = this.getStarvationDelay();
                    if (this.warn(`Aborting inflight request ${k > 0 ? "and switching down" : ""}
      Fragment duration: ${r.duration.toFixed(3)} s
      Time to underbuffer: ${re.toFixed(3)} s`),
                    r.abortRequests(),
                    this.fragCurrent = this.partCurrent = null,
                    k > f) {
                        let Q = this.findBestLevel(this.hls.levels[f].bitrate, f, k, 0, re, 1, 1);
                        Q === -1 && (Q = f),
                        this.hls.nextLoadLevel = this.hls.nextAutoLevel = Q,
                        this.resetEstimator(this.hls.levels[Q].bitrate)
                    }
                }
            }
            ;
            x || W > B * 2 ? J() : this.timer = self.setInterval(J, B * 1e3),
            a.trigger(S.FRAG_LOAD_EMERGENCY_ABORTED, {
                frag: r,
                part: i,
                stats: u
            })
        }
        ,
        this.hls = e,
        this.bwEstimator = this.initEstimator(),
        this.registerListeners()
    }
    resetEstimator(e) {
        e && (this.log(`setting initial bwe to ${e}`),
        this.hls.config.abrEwmaDefaultEstimate = e),
        this.firstSelection = -1,
        this.bwEstimator = this.initEstimator()
    }
    initEstimator() {
        const e = this.hls.config;
        return new BS(e.abrEwmaSlowVoD,e.abrEwmaFastVoD,e.abrEwmaDefaultEstimate)
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.FRAG_LOADING, this.onFragLoading, this),
        e.on(S.FRAG_LOADED, this.onFragLoaded, this),
        e.on(S.FRAG_BUFFERED, this.onFragBuffered, this),
        e.on(S.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.on(S.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(S.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(S.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this),
        e.on(S.ERROR, this.onError, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e && (e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.FRAG_LOADING, this.onFragLoading, this),
        e.off(S.FRAG_LOADED, this.onFragLoaded, this),
        e.off(S.FRAG_BUFFERED, this.onFragBuffered, this),
        e.off(S.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.off(S.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(S.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(S.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this),
        e.off(S.ERROR, this.onError, this))
    }
    destroy() {
        this.unregisterListeners(),
        this.clearTimer(),
        this.hls = this._abandonRulesCheck = this.supportedCache = null,
        this.fragCurrent = this.partCurrent = null
    }
    onManifestLoading(e, t) {
        this.lastLoadedFragLevel = -1,
        this.firstSelection = -1,
        this.lastLevelLoadSec = 0,
        this.supportedCache = {},
        this.fragCurrent = this.partCurrent = null,
        this.onLevelsUpdated(),
        this.clearTimer()
    }
    onLevelsUpdated() {
        this.lastLoadedFragLevel > -1 && this.fragCurrent && (this.lastLoadedFragLevel = this.fragCurrent.level),
        this._nextAutoLevel = -1,
        this.onMaxAutoLevelUpdated(),
        this.codecTiers = null,
        this.audioTracksByGroup = null
    }
    onMaxAutoLevelUpdated() {
        this.firstSelection = -1,
        this.nextAutoLevelKey = ""
    }
    onFragLoading(e, t) {
        const n = t.frag;
        if (!this.ignoreFragment(n)) {
            if (!n.bitrateTest) {
                var r;
                this.fragCurrent = n,
                this.partCurrent = (r = t.part) != null ? r : null
            }
            this.clearTimer(),
            this.timer = self.setInterval(this._abandonRulesCheck, 100)
        }
    }
    onLevelSwitching(e, t) {
        this.clearTimer()
    }
    onError(e, t) {
        if (!t.fatal)
            switch (t.details) {
            case N.BUFFER_ADD_CODEC_ERROR:
            case N.BUFFER_APPEND_ERROR:
                this.lastLoadedFragLevel = -1,
                this.firstSelection = -1;
                break;
            case N.FRAG_LOAD_TIMEOUT:
                {
                    const n = t.frag
                      , {fragCurrent: r, partCurrent: i} = this;
                    if (n && r && n.sn === r.sn && n.level === r.level) {
                        const a = performance.now()
                          , o = i ? i.stats : n.stats
                          , l = a - o.loading.start
                          , c = o.loading.first ? o.loading.first - o.loading.start : -1;
                        if (o.loaded && c > -1) {
                            const d = this.bwEstimator.getEstimateTTFB();
                            this.bwEstimator.sample(l - Math.min(d, c), o.loaded)
                        } else
                            this.bwEstimator.sampleTTFB(l)
                    }
                    break
                }
            }
    }
    getTimeToLoadFrag(e, t, n, r) {
        const i = e + n / t
          , a = r ? e + this.lastLevelLoadSec : 0;
        return i + a
    }
    onLevelLoaded(e, t) {
        const n = this.hls.config
          , {loading: r} = t.stats
          , i = r.end - r.first;
        z(i) && (this.lastLevelLoadSec = i / 1e3),
        t.details.live ? this.bwEstimator.update(n.abrEwmaSlowLive, n.abrEwmaFastLive) : this.bwEstimator.update(n.abrEwmaSlowVoD, n.abrEwmaFastVoD),
        this.timer > -1 && this._abandonRulesCheck(t.levelInfo)
    }
    onFragLoaded(e, {frag: t, part: n}) {
        const r = n ? n.stats : t.stats;
        if (t.type === X.MAIN && this.bwEstimator.sampleTTFB(r.loading.first - r.loading.start),
        !this.ignoreFragment(t)) {
            if (this.clearTimer(),
            t.level === this._nextAutoLevel && (this._nextAutoLevel = -1),
            this.firstSelection = -1,
            this.hls.config.abrMaxWithRealBitrate) {
                const i = n ? n.duration : t.duration
                  , a = this.hls.levels[t.level]
                  , o = (a.loaded ? a.loaded.bytes : 0) + r.loaded
                  , l = (a.loaded ? a.loaded.duration : 0) + i;
                a.loaded = {
                    bytes: o,
                    duration: l
                },
                a.realBitrate = Math.round(8 * o / l)
            }
            if (t.bitrateTest) {
                const i = {
                    stats: r,
                    frag: t,
                    part: n,
                    id: t.type
                };
                this.onFragBuffered(S.FRAG_BUFFERED, i),
                t.bitrateTest = !1
            } else
                this.lastLoadedFragLevel = t.level
        }
    }
    onFragBuffered(e, t) {
        const {frag: n, part: r} = t
          , i = r != null && r.stats.loaded ? r.stats : n.stats;
        if (i.aborted || this.ignoreFragment(n))
            return;
        const a = i.parsing.end - i.loading.start - Math.min(i.loading.first - i.loading.start, this.bwEstimator.getEstimateTTFB());
        this.bwEstimator.sample(a, i.loaded),
        i.bwEstimate = this.getBwEstimate(),
        n.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0
    }
    ignoreFragment(e) {
        return e.type !== X.MAIN || e.sn === "initSegment"
    }
    clearTimer() {
        this.timer > -1 && (self.clearInterval(this.timer),
        this.timer = -1)
    }
    get firstAutoLevel() {
        const {maxAutoLevel: e, minAutoLevel: t} = this.hls
          , n = this.getBwEstimate()
          , r = this.hls.config.maxStarvationDelay
          , i = this.findBestLevel(n, t, e, 0, r, 1, 1);
        if (i > -1)
            return i;
        const a = this.hls.firstLevel
          , o = Math.min(Math.max(a, t), e);
        return this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${a} clamped to ${o}`),
        o
    }
    get forcedAutoLevel() {
        return this.nextAutoLevelKey ? -1 : this._nextAutoLevel
    }
    get nextAutoLevel() {
        const e = this.forcedAutoLevel
          , n = this.bwEstimator.canEstimate()
          , r = this.lastLoadedFragLevel > -1;
        if (e !== -1 && (!n || !r || this.nextAutoLevelKey === this.getAutoLevelKey()))
            return e;
        const i = n && r ? this.getNextABRAutoLevel() : this.firstAutoLevel;
        if (e !== -1) {
            const a = this.hls.levels;
            if (a.length > Math.max(e, i) && a[e].loadError <= a[i].loadError)
                return e
        }
        return this._nextAutoLevel = i,
        this.nextAutoLevelKey = this.getAutoLevelKey(),
        i
    }
    getAutoLevelKey() {
        return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`
    }
    getNextABRAutoLevel() {
        const {fragCurrent: e, partCurrent: t, hls: n} = this;
        if (n.levels.length <= 1)
            return n.loadLevel;
        const {maxAutoLevel: r, config: i, minAutoLevel: a} = n
          , o = t ? t.duration : e ? e.duration : 0
          , l = this.getBwEstimate()
          , c = this.getStarvationDelay();
        let u = i.abrBandWidthFactor
          , d = i.abrBandWidthUpFactor;
        if (c) {
            const x = this.findBestLevel(l, a, r, c, 0, u, d);
            if (x >= 0)
                return this.rebufferNotice = -1,
                x
        }
        let h = o ? Math.min(o, i.maxStarvationDelay) : i.maxStarvationDelay;
        if (!c) {
            const x = this.bitrateTestDelay;
            x && (h = (o ? Math.min(o, i.maxLoadingDelay) : i.maxLoadingDelay) - x,
            this.info(`bitrate test took ${Math.round(1e3 * x)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * h)} ms`),
            u = d = 1)
        }
        const f = this.findBestLevel(l, a, r, c, h, u, d);
        if (this.rebufferNotice !== f && (this.rebufferNotice = f,
        this.info(`${c ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${f}`)),
        f > -1)
            return f;
        const m = n.levels[a]
          , p = n.loadLevelObj;
        return p && (m == null ? void 0 : m.bitrate) < p.bitrate ? a : n.loadLevel
    }
    getStarvationDelay() {
        const e = this.hls
          , t = e.media;
        if (!t)
            return 1 / 0;
        const n = t && t.playbackRate !== 0 ? Math.abs(t.playbackRate) : 1
          , r = e.mainForwardBufferInfo;
        return (r ? r.len : 0) / n
    }
    getBwEstimate() {
        return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate
    }
    findBestLevel(e, t, n, r, i, a, o) {
        var l;
        const c = r + i
          , u = this.lastLoadedFragLevel
          , d = u === -1 ? this.hls.firstLevel : u
          , {fragCurrent: h, partCurrent: f} = this
          , {levels: m, allAudioTracks: p, loadLevel: x, config: y} = this.hls;
        if (m.length === 1)
            return 0;
        const v = m[d]
          , E = !!((l = this.hls.latestLevelDetails) != null && l.live)
          , T = x === -1 || u === -1;
        let L, R = "SDR", I = (v == null ? void 0 : v.frameRate) || 0;
        const {audioPreference: A, videoPreference: C} = y
          , b = this.audioTracksByGroup || (this.audioTracksByGroup = l0(p));
        let O = -1;
        if (T) {
            if (this.firstSelection !== -1)
                return this.firstSelection;
            const G = this.codecTiers || (this.codecTiers = RT(m, b, t, n))
              , V = bT(G, R, e, A, C)
              , {codecSet: D, videoRanges: B, minFramerate: k, minBitrate: F, minIndex: j, preferHDR: J} = V;
            O = j,
            L = D,
            R = J ? B[B.length - 1] : B[0],
            I = k,
            e = Math.max(e, F),
            this.log(`picked start tier ${Te(V)}`)
        } else
            L = v == null ? void 0 : v.codecSet,
            R = v == null ? void 0 : v.videoRange;
        const _ = f ? f.duration : h ? h.duration : 0
          , $ = this.bwEstimator.getEstimateTTFB() / 1e3
          , K = [];
        for (let G = n; G >= t; G--) {
            var W;
            const V = m[G]
              , D = G > d;
            if (!V)
                continue;
            if (y.useMediaCapabilities && !V.supportedResult && !V.supportedPromise) {
                const Q = navigator.mediaCapabilities;
                typeof (Q == null ? void 0 : Q.decodingInfo) == "function" && pT(V, b, R, I, e, A) ? (V.supportedPromise = a0(V, b, Q, this.supportedCache),
                V.supportedPromise.then(se => {
                    if (!this.hls)
                        return;
                    V.supportedResult = se;
                    const Le = this.hls.levels
                      , ke = Le.indexOf(V);
                    se.error ? this.warn(`MediaCapabilities decodingInfo error: "${se.error}" for level ${ke} ${Te(se)}`) : se.supported ? se.decodingInfoResults.some(Ne => Ne.smooth === !1 || Ne.powerEfficient === !1) && this.log(`MediaCapabilities decodingInfo for level ${ke} not smooth or powerEfficient: ${Te(se)}`) : (this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${ke} ${Te(se)}`),
                    ke > -1 && Le.length > 1 && (this.log(`Removing unsupported level ${ke}`),
                    this.hls.removeLevel(ke),
                    this.hls.loadLevel === -1 && (this.hls.nextLoadLevel = 0)))
                }
                ).catch(se => {
                    this.warn(`Error handling MediaCapabilities decodingInfo: ${se}`)
                }
                )) : V.supportedResult = r0
            }
            if ((L && V.codecSet !== L || R && V.videoRange !== R || D && I > V.frameRate || !D && I > 0 && I < V.frameRate || (W = V.supportedResult) != null && (W = W.decodingInfoResults) != null && W.some(Q => Q.smooth === !1)) && (!T || G !== O)) {
                K.push(G);
                continue
            }
            const B = V.details
              , k = (f ? B == null ? void 0 : B.partTarget : B == null ? void 0 : B.averagetargetduration) || _;
            let F;
            D ? F = o * e : F = a * e;
            const j = _ && r >= _ * 2 && i === 0 ? V.averageBitrate : V.maxBitrate
              , J = this.getTimeToLoadFrag($, F, j * k, B === void 0);
            if (F >= j && (G === u || V.loadError === 0 && V.fragmentError === 0) && (J <= $ || !z(J) || E && !this.bitrateTestDelay || J < c)) {
                const Q = this.forcedAutoLevel;
                return G !== x && (Q === -1 || Q !== x) && (K.length && this.trace(`Skipped level(s) ${K.join(",")} of ${n} max with CODECS and VIDEO-RANGE:"${m[K[0]].codecs}" ${m[K[0]].videoRange}; not compatible with "${L}" ${R}`),
                this.info(`switch candidate:${d}->${G} adjustedbw(${Math.round(F)})-bitrate=${Math.round(F - j)} ttfb:${$.toFixed(1)} avgDuration:${k.toFixed(1)} maxFetchDuration:${c.toFixed(1)} fetchDuration:${J.toFixed(1)} firstSelection:${T} codecSet:${V.codecSet} videoRange:${V.videoRange} hls.loadLevel:${x}`)),
                T && (this.firstSelection = G),
                G
            }
        }
        return -1
    }
    set nextAutoLevel(e) {
        const t = this.deriveNextAutoLevel(e);
        this._nextAutoLevel !== t && (this.nextAutoLevelKey = "",
        this._nextAutoLevel = t)
    }
    deriveNextAutoLevel(e) {
        const {maxAutoLevel: t, minAutoLevel: n} = this.hls;
        return Math.min(Math.max(e, n), t)
    }
}
const c0 = {
    search: function(s, e) {
        let t = 0
          , n = s.length - 1
          , r = null
          , i = null;
        for (; t <= n; ) {
            r = (t + n) / 2 | 0,
            i = s[r];
            const a = e(i);
            if (a > 0)
                t = r + 1;
            else if (a < 0)
                n = r - 1;
            else
                return i
        }
        return null
    }
};
function DT(s, e, t) {
    if (e === null || !Array.isArray(s) || !s.length || !z(e))
        return null;
    const n = s[0].programDateTime;
    if (e < (n || 0))
        return null;
    const r = s[s.length - 1].endProgramDateTime;
    if (e >= (r || 0))
        return null;
    for (let i = 0; i < s.length; ++i) {
        const a = s[i];
        if (NT(e, t, a))
            return a
    }
    return null
}
function Pn(s, e, t=0, n=0, r=.005) {
    let i = null;
    if (s) {
        i = e[1 + s.sn - e[0].sn] || null;
        const o = s.endDTS - t;
        o > 0 && o < 15e-7 && (t += 15e-7),
        i && s.level !== i.level && i.end <= s.end && (i = e[2 + s.sn - e[0].sn] || null)
    } else
        t === 0 && e[0].start === 0 && (i = e[0]);
    if (i && ((!s || s.level === i.level) && ff(t, n, i) === 0 || PT(i, s, Math.min(r, n))))
        return i;
    const a = c0.search(e, ff.bind(null, t, n));
    return a && (a !== s || !i) ? a : i
}
function PT(s, e, t) {
    if (e && e.start === 0 && e.level < s.level && (e.endPTS || 0) > 0) {
        const n = e.tagList.reduce( (r, i) => (i[0] === "INF" && (r += parseFloat(i[1])),
        r), t);
        return s.start <= n
    }
    return !1
}
function ff(s=0, e=0, t) {
    if (t.start <= s && t.start + t.duration > s)
        return 0;
    const n = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0));
    return t.start + t.duration - n <= s ? 1 : t.start - n > s && t.start ? -1 : 0
}
function NT(s, e, t) {
    const n = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3;
    return (t.endProgramDateTime || 0) - n > s
}
function u0(s, e, t) {
    if (s && s.startCC <= e && s.endCC >= e) {
        let n = s.fragments;
        const {fragmentHint: r} = s;
        r && (n = n.concat(r));
        let i;
        return c0.search(n, a => a.cc < e ? 1 : a.cc > e ? -1 : (i = a,
        a.end <= t ? 1 : a.start > t ? -1 : 0)),
        i || null
    }
    return null
}
function Lo(s) {
    switch (s.details) {
    case N.FRAG_LOAD_TIMEOUT:
    case N.KEY_LOAD_TIMEOUT:
    case N.LEVEL_LOAD_TIMEOUT:
    case N.MANIFEST_LOAD_TIMEOUT:
        return !0
    }
    return !1
}
function mf(s, e) {
    const t = Lo(e);
    return s.default[`${t ? "timeout" : "error"}Retry`]
}
function pd(s, e) {
    const t = s.backoff === "linear" ? 1 : Math.pow(2, e);
    return Math.min(t * s.retryDelayMs, s.maxRetryDelayMs)
}
function gf(s) {
    return pe(pe({}, s), {
        errorRetry: null,
        timeoutRetry: null
    })
}
function Io(s, e, t, n) {
    if (!s)
        return !1;
    const r = n == null ? void 0 : n.code
      , i = e < s.maxNumRetry && (OT(r) || !!t);
    return s.shouldRetry ? s.shouldRetry(s, e, t, n, i) : i
}
function OT(s) {
    return qc(s) || !!s && (s < 400 || s > 499)
}
function qc(s) {
    return s === 0 && navigator.onLine === !1
}
var qe = {
    DoNothing: 0,
    SendEndCallback: 1,
    SendAlternateToPenaltyBox: 2,
    RemoveAlternatePermanently: 3,
    InsertDiscontinuity: 4,
    RetryRequest: 5
}
  , Tt = {
    None: 0,
    MoveAllAlternatesMatchingHost: 1,
    MoveAllAlternatesMatchingHDCP: 2,
    MoveAllAlternatesMatchingKey: 4,
    SwitchToSDR: 8
};
class MT extends Gt {
    constructor(e) {
        super("error-controller", e.logger),
        this.hls = void 0,
        this.playlistError = 0,
        this.hls = e,
        this.registerListeners()
    }
    registerListeners() {
        const e = this.hls;
        e.on(S.ERROR, this.onError, this),
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.LEVEL_UPDATED, this.onLevelUpdated, this)
    }
    unregisterListeners() {
        const e = this.hls;
        e && (e.off(S.ERROR, this.onError, this),
        e.off(S.ERROR, this.onErrorOut, this),
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.LEVEL_UPDATED, this.onLevelUpdated, this))
    }
    destroy() {
        this.unregisterListeners(),
        this.hls = null
    }
    startLoad(e) {}
    stopLoad() {
        this.playlistError = 0
    }
    getVariantLevelIndex(e) {
        return (e == null ? void 0 : e.type) === X.MAIN ? e.level : this.getVariantIndex()
    }
    getVariantIndex() {
        var e;
        const t = this.hls
          , n = t.currentLevel;
        return (e = t.loadLevelObj) != null && e.details || n === -1 ? t.loadLevel : n
    }
    variantHasKey(e, t) {
        if (e) {
            var n;
            if ((n = e.details) != null && n.hasKey(t))
                return !0;
            const r = e.audioGroups;
            if (r)
                return this.hls.allAudioTracks.filter(a => r.indexOf(a.groupId) >= 0).some(a => {
                    var o;
                    return (o = a.details) == null ? void 0 : o.hasKey(t)
                }
                )
        }
        return !1
    }
    onManifestLoading() {
        this.playlistError = 0
    }
    onLevelUpdated() {
        this.playlistError = 0
    }
    onError(e, t) {
        var n;
        if (t.fatal)
            return;
        const r = this.hls
          , i = t.context;
        switch (t.details) {
        case N.FRAG_LOAD_ERROR:
        case N.FRAG_LOAD_TIMEOUT:
        case N.KEY_LOAD_ERROR:
        case N.KEY_LOAD_TIMEOUT:
            t.errorAction = this.getFragRetryOrSwitchAction(t);
            return;
        case N.FRAG_PARSING_ERROR:
            if ((n = t.frag) != null && n.gap) {
                t.errorAction = hr();
                return
            }
        case N.FRAG_GAP:
        case N.FRAG_DECRYPT_ERROR:
            {
                t.errorAction = this.getFragRetryOrSwitchAction(t),
                t.errorAction.action = qe.SendAlternateToPenaltyBox;
                return
            }
        case N.LEVEL_EMPTY_ERROR:
        case N.LEVEL_PARSING_ERROR:
            {
                var a;
                const l = t.parent === X.MAIN ? t.level : r.loadLevel;
                t.details === N.LEVEL_EMPTY_ERROR && ((a = t.context) != null && (a = a.levelDetails) != null && a.live) ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, l) : (t.levelRetry = !1,
                t.errorAction = this.getLevelSwitchAction(t, l))
            }
            return;
        case N.LEVEL_LOAD_ERROR:
        case N.LEVEL_LOAD_TIMEOUT:
            typeof (i == null ? void 0 : i.level) == "number" && (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, i.level));
            return;
        case N.AUDIO_TRACK_LOAD_ERROR:
        case N.AUDIO_TRACK_LOAD_TIMEOUT:
        case N.SUBTITLE_LOAD_ERROR:
        case N.SUBTITLE_TRACK_LOAD_TIMEOUT:
            if (i) {
                const l = r.loadLevelObj;
                if (l && (i.type === le.AUDIO_TRACK && l.hasAudioGroup(i.groupId) || i.type === le.SUBTITLE_TRACK && l.hasSubtitleGroup(i.groupId))) {
                    t.errorAction = this.getPlaylistRetryOrSwitchAction(t, r.loadLevel),
                    t.errorAction.action = qe.SendAlternateToPenaltyBox,
                    t.errorAction.flags = Tt.MoveAllAlternatesMatchingHost;
                    return
                }
            }
            return;
        case N.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
            t.errorAction = {
                action: qe.SendAlternateToPenaltyBox,
                flags: Tt.MoveAllAlternatesMatchingHDCP
            };
            return;
        case N.KEY_SYSTEM_SESSION_UPDATE_FAILED:
        case N.KEY_SYSTEM_STATUS_INTERNAL_ERROR:
        case N.KEY_SYSTEM_NO_SESSION:
            t.errorAction = {
                action: qe.SendAlternateToPenaltyBox,
                flags: Tt.MoveAllAlternatesMatchingKey
            };
            return;
        case N.BUFFER_ADD_CODEC_ERROR:
        case N.REMUX_ALLOC_ERROR:
        case N.BUFFER_APPEND_ERROR:
            if (!t.errorAction) {
                var o;
                t.errorAction = this.getLevelSwitchAction(t, (o = t.level) != null ? o : r.loadLevel)
            }
            return;
        case N.INTERNAL_EXCEPTION:
        case N.BUFFER_APPENDING_ERROR:
        case N.BUFFER_FULL_ERROR:
        case N.LEVEL_SWITCH_ERROR:
        case N.BUFFER_STALLED_ERROR:
        case N.BUFFER_SEEK_OVER_HOLE:
        case N.BUFFER_NUDGE_ON_STALL:
            t.errorAction = hr();
            return
        }
        t.type === q.KEY_SYSTEM_ERROR && (t.levelRetry = !1,
        t.errorAction = hr())
    }
    getPlaylistRetryOrSwitchAction(e, t) {
        const n = this.hls
          , r = mf(n.config.playlistLoadPolicy, e)
          , i = this.playlistError++;
        if (Io(r, i, Lo(e), e.response))
            return {
                action: qe.RetryRequest,
                flags: Tt.None,
                retryConfig: r,
                retryCount: i
            };
        const o = this.getLevelSwitchAction(e, t);
        return r && (o.retryConfig = r,
        o.retryCount = i),
        o
    }
    getFragRetryOrSwitchAction(e) {
        const t = this.hls
          , n = this.getVariantLevelIndex(e.frag)
          , r = t.levels[n]
          , {fragLoadPolicy: i, keyLoadPolicy: a} = t.config
          , o = mf(e.details.startsWith("key") ? a : i, e)
          , l = t.levels.reduce( (u, d) => u + d.fragmentError, 0);
        if (r && (e.details !== N.FRAG_GAP && r.fragmentError++,
        Io(o, l, Lo(e), e.response)))
            return {
                action: qe.RetryRequest,
                flags: Tt.None,
                retryConfig: o,
                retryCount: l
            };
        const c = this.getLevelSwitchAction(e, n);
        return o && (c.retryConfig = o,
        c.retryCount = l),
        c
    }
    getLevelSwitchAction(e, t) {
        const n = this.hls;
        t == null && (t = n.loadLevel);
        const r = this.hls.levels[t];
        if (r) {
            var i, a;
            const c = e.details;
            r.loadError++,
            c === N.BUFFER_APPEND_ERROR && r.fragmentError++;
            let u = -1;
            const {levels: d, loadLevel: h, minAutoLevel: f, maxAutoLevel: m} = n;
            !n.autoLevelEnabled && !n.config.preserveManualLevelOnError && (n.loadLevel = -1);
            const p = (i = e.frag) == null ? void 0 : i.type
              , y = (p === X.AUDIO && c === N.FRAG_PARSING_ERROR || e.sourceBufferName === "audio" && (c === N.BUFFER_ADD_CODEC_ERROR || c === N.BUFFER_APPEND_ERROR)) && d.some( ({audioCodec: R}) => r.audioCodec !== R)
              , E = e.sourceBufferName === "video" && (c === N.BUFFER_ADD_CODEC_ERROR || c === N.BUFFER_APPEND_ERROR) && d.some( ({codecSet: R, audioCodec: I}) => r.codecSet !== R && r.audioCodec === I)
              , {type: T, groupId: L} = (a = e.context) != null ? a : {};
            for (let R = d.length; R--; ) {
                const I = (R + h) % d.length;
                if (I !== h && I >= f && I <= m && d[I].loadError === 0) {
                    var o, l;
                    const A = d[I];
                    if (c === N.FRAG_GAP && p === X.MAIN && e.frag) {
                        const C = d[I].details;
                        if (C) {
                            const b = Pn(e.frag, C.fragments, e.frag.start);
                            if (b != null && b.gap)
                                continue
                        }
                    } else {
                        if (T === le.AUDIO_TRACK && A.hasAudioGroup(L) || T === le.SUBTITLE_TRACK && A.hasSubtitleGroup(L))
                            continue;
                        if (p === X.AUDIO && (o = r.audioGroups) != null && o.some(C => A.hasAudioGroup(C)) || p === X.SUBTITLE && (l = r.subtitleGroups) != null && l.some(C => A.hasSubtitleGroup(C)) || y && r.audioCodec === A.audioCodec || E && r.codecSet === A.codecSet || !y && r.codecSet !== A.codecSet)
                            continue
                    }
                    u = I;
                    break
                }
            }
            if (u > -1 && n.loadLevel !== u)
                return e.levelRetry = !0,
                this.playlistError = 0,
                {
                    action: qe.SendAlternateToPenaltyBox,
                    flags: Tt.None,
                    nextAutoLevel: u
                }
        }
        return {
            action: qe.SendAlternateToPenaltyBox,
            flags: Tt.MoveAllAlternatesMatchingHost
        }
    }
    onErrorOut(e, t) {
        var n;
        switch ((n = t.errorAction) == null ? void 0 : n.action) {
        case qe.DoNothing:
            break;
        case qe.SendAlternateToPenaltyBox:
            this.sendAlternateToPenaltyBox(t),
            !t.errorAction.resolved && t.details !== N.FRAG_GAP ? t.fatal = !0 : /MediaSource readyState: ended/.test(t.error.message) && (this.warn(`MediaSource ended after "${t.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`),
            this.hls.recoverMediaError());
            break
        }
        if (t.fatal) {
            this.hls.stopLoad();
            return
        }
    }
    sendAlternateToPenaltyBox(e) {
        const t = this.hls
          , n = e.errorAction;
        if (!n)
            return;
        const {flags: r} = n
          , i = n.nextAutoLevel;
        switch (r) {
        case Tt.None:
            this.switchLevel(e, i);
            break;
        case Tt.MoveAllAlternatesMatchingHDCP:
            {
                const l = this.getVariantLevelIndex(e.frag)
                  , c = t.levels[l]
                  , u = c == null ? void 0 : c.attrs["HDCP-LEVEL"];
                if (n.hdcpLevel = u,
                u) {
                    t.maxHdcpLevel = Zc[Zc.indexOf(u) - 1],
                    n.resolved = !0,
                    this.warn(`Restricting playback to HDCP-LEVEL of "${t.maxHdcpLevel}" or lower`);
                    break
                }
            }
        case Tt.MoveAllAlternatesMatchingKey:
            {
                const l = e.decryptdata;
                if (l) {
                    const c = this.hls.levels;
                    for (let u = c.length; u--; )
                        if (this.variantHasKey(c[u], l)) {
                            var a, o;
                            this.log(`Banned key found in level ${u} (${c[u].bitrate}bps) or audio group "${(a = c[u].audioGroups) == null ? void 0 : a.join(",")}" (${(o = e.frag) == null ? void 0 : o.type} fragment) ${It(l.keyId || [])}`),
                            c[u].fragmentError++,
                            c[u].loadError++,
                            this.log(`Removing level ${u} with key error (${e.error})`),
                            this.hls.removeLevel(u)
                        }
                    c.length && (n.resolved = !0)
                }
                break
            }
        }
        n.resolved || this.switchLevel(e, i)
    }
    switchLevel(e, t) {
        if (t !== void 0 && e.errorAction && (this.warn(`switching to level ${t} after ${e.details}`),
        this.hls.nextAutoLevel = t,
        e.errorAction.resolved = !0,
        this.hls.nextLoadLevel = this.hls.nextAutoLevel,
        e.details === N.BUFFER_ADD_CODEC_ERROR && e.mimeType && e.sourceBufferName !== "audiovideo")) {
            const n = Xc(e.mimeType)
              , r = this.hls.levels;
            for (let i = r.length; i--; )
                r[i][`${e.sourceBufferName}Codec`] === n && (this.log(`Removing level ${i} for ${e.details} ("${n}" not supported)`),
                this.hls.removeLevel(i))
        }
    }
}
function hr(s) {
    const e = {
        action: qe.DoNothing,
        flags: Tt.None
    };
    return s && (e.resolved = !0),
    e
}
var Ve = {
    NOT_LOADED: "NOT_LOADED",
    APPENDING: "APPENDING",
    PARTIAL: "PARTIAL",
    OK: "OK"
};
class FT {
    constructor(e) {
        this.activePartLists = Object.create(null),
        this.endListFragments = Object.create(null),
        this.fragments = Object.create(null),
        this.timeRanges = Object.create(null),
        this.bufferPadding = .2,
        this.hls = void 0,
        this.hasGaps = !1,
        this.hls = e,
        this._registerListeners()
    }
    _registerListeners() {
        const {hls: e} = this;
        e && (e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.BUFFER_APPENDED, this.onBufferAppended, this),
        e.on(S.FRAG_BUFFERED, this.onFragBuffered, this),
        e.on(S.FRAG_LOADED, this.onFragLoaded, this))
    }
    _unregisterListeners() {
        const {hls: e} = this;
        e && (e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.BUFFER_APPENDED, this.onBufferAppended, this),
        e.off(S.FRAG_BUFFERED, this.onFragBuffered, this),
        e.off(S.FRAG_LOADED, this.onFragLoaded, this))
    }
    destroy() {
        this._unregisterListeners(),
        this.hls = this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null
    }
    getAppendedFrag(e, t) {
        const n = this.activePartLists[t];
        if (n)
            for (let r = n.length; r--; ) {
                const i = n[r];
                if (!i)
                    break;
                if (i.start <= e && e <= i.end && i.loaded)
                    return i
            }
        return this.getBufferedFrag(e, t)
    }
    getBufferedFrag(e, t) {
        return this.getFragAtPos(e, t, !0)
    }
    getFragAtPos(e, t, n) {
        const {fragments: r} = this
          , i = Object.keys(r);
        for (let a = i.length; a--; ) {
            const o = r[i[a]];
            if ((o == null ? void 0 : o.body.type) === t && (!n || o.buffered)) {
                const l = o.body;
                if (l.start <= e && e <= l.end)
                    return l
            }
        }
        return null
    }
    detectEvictedFragments(e, t, n, r, i) {
        this.timeRanges && (this.timeRanges[e] = t);
        const a = (r == null ? void 0 : r.fragment.sn) || -1;
        Object.keys(this.fragments).forEach(o => {
            const l = this.fragments[o];
            if (!l || a >= l.body.sn)
                return;
            if (!l.buffered && (!l.loaded || i)) {
                l.body.type === n && this.removeFragment(l.body);
                return
            }
            const c = l.range[e];
            if (c) {
                if (c.time.length === 0) {
                    this.removeFragment(l.body);
                    return
                }
                c.time.some(u => {
                    const d = !this.isTimeBuffered(u.startPTS, u.endPTS, t);
                    return d && this.removeFragment(l.body),
                    d
                }
                )
            }
        }
        )
    }
    detectPartialFragments(e) {
        const t = this.timeRanges;
        if (!t || e.frag.sn === "initSegment")
            return;
        const n = e.frag
          , r = jn(n)
          , i = this.fragments[r];
        if (!i || i.buffered && n.gap)
            return;
        const a = !n.relurl;
        Object.keys(t).forEach(o => {
            const l = n.elementaryStreams[o];
            if (!l)
                return;
            const c = t[o]
              , u = a || l.partial === !0;
            i.range[o] = this.getBufferedTimes(n, e.part, u, c)
        }
        ),
        i.loaded = null,
        Object.keys(i.range).length ? (i.buffered = !0,
        (i.body.endList = n.endList || i.body.endList) && (this.endListFragments[i.body.type] = i),
        ca(i) || this.removeParts(n.sn - 1, n.type)) : this.removeFragment(i.body)
    }
    removeParts(e, t) {
        const n = this.activePartLists[t];
        n && (this.activePartLists[t] = pf(n, r => r.fragment.sn >= e))
    }
    fragBuffered(e, t) {
        const n = jn(e);
        let r = this.fragments[n];
        !r && t && (r = this.fragments[n] = {
            body: e,
            appendedPTS: null,
            loaded: null,
            buffered: !1,
            range: Object.create(null)
        },
        e.gap && (this.hasGaps = !0)),
        r && (r.loaded = null,
        r.buffered = !0)
    }
    getBufferedTimes(e, t, n, r) {
        const i = {
            time: [],
            partial: n
        }
          , a = e.start
          , o = e.end
          , l = e.minEndPTS || o
          , c = e.maxStartPTS || a;
        for (let u = 0; u < r.length; u++) {
            const d = r.start(u) - this.bufferPadding
              , h = r.end(u) + this.bufferPadding;
            if (c >= d && l <= h) {
                i.time.push({
                    startPTS: Math.max(a, r.start(u)),
                    endPTS: Math.min(o, r.end(u))
                });
                break
            } else if (a < h && o > d) {
                const f = Math.max(a, r.start(u))
                  , m = Math.min(o, r.end(u));
                m > f && (i.partial = !0,
                i.time.push({
                    startPTS: f,
                    endPTS: m
                }))
            } else if (o <= d)
                break
        }
        return i
    }
    getPartialFragment(e) {
        let t = null, n, r, i, a = 0;
        const {bufferPadding: o, fragments: l} = this;
        return Object.keys(l).forEach(c => {
            const u = l[c];
            u && ca(u) && (r = u.body.start - o,
            i = u.body.end + o,
            e >= r && e <= i && (n = Math.min(e - r, i - e),
            a <= n && (t = u.body,
            a = n)))
        }
        ),
        t
    }
    isEndListAppended(e) {
        const t = this.endListFragments[e];
        return t !== void 0 && (t.buffered || ca(t))
    }
    getState(e) {
        const t = jn(e)
          , n = this.fragments[t];
        return n ? n.buffered ? ca(n) ? Ve.PARTIAL : Ve.OK : Ve.APPENDING : Ve.NOT_LOADED
    }
    isTimeBuffered(e, t, n) {
        let r, i;
        for (let a = 0; a < n.length; a++) {
            if (r = n.start(a) - this.bufferPadding,
            i = n.end(a) + this.bufferPadding,
            e >= r && t <= i)
                return !0;
            if (t <= r)
                return !1
        }
        return !1
    }
    onManifestLoading() {
        this.removeAllFragments()
    }
    onFragLoaded(e, t) {
        if (t.frag.sn === "initSegment" || t.frag.bitrateTest)
            return;
        const n = t.frag
          , r = t.part ? null : t
          , i = jn(n);
        this.fragments[i] = {
            body: n,
            appendedPTS: null,
            loaded: r,
            buffered: !1,
            range: Object.create(null)
        }
    }
    onBufferAppended(e, t) {
        const {frag: n, part: r, timeRanges: i, type: a} = t;
        if (n.sn === "initSegment")
            return;
        const o = n.type;
        if (r) {
            let c = this.activePartLists[o];
            c || (this.activePartLists[o] = c = []),
            c.push(r)
        }
        this.timeRanges = i;
        const l = i[a];
        this.detectEvictedFragments(a, l, o, r)
    }
    onFragBuffered(e, t) {
        this.detectPartialFragments(t)
    }
    hasFragment(e) {
        const t = jn(e);
        return !!this.fragments[t]
    }
    hasFragments(e) {
        const {fragments: t} = this
          , n = Object.keys(t);
        if (!e)
            return n.length > 0;
        for (let r = n.length; r--; ) {
            const i = t[n[r]];
            if ((i == null ? void 0 : i.body.type) === e)
                return !0
        }
        return !1
    }
    hasParts(e) {
        var t;
        return !!((t = this.activePartLists[e]) != null && t.length)
    }
    removeFragmentsInRange(e, t, n, r, i) {
        r && !this.hasGaps || Object.keys(this.fragments).forEach(a => {
            const o = this.fragments[a];
            if (!o)
                return;
            const l = o.body;
            l.type !== n || r && !l.gap || l.start < t && l.end > e && (o.buffered || i) && this.removeFragment(l)
        }
        )
    }
    removeFragment(e) {
        const t = jn(e);
        e.clearElementaryStreamInfo();
        const n = this.activePartLists[e.type];
        if (n) {
            const r = e.sn;
            this.activePartLists[e.type] = pf(n, i => i.fragment.sn !== r)
        }
        delete this.fragments[t],
        e.endList && delete this.endListFragments[e.type]
    }
    removeAllFragments() {
        var e;
        this.fragments = Object.create(null),
        this.endListFragments = Object.create(null),
        this.activePartLists = Object.create(null),
        this.hasGaps = !1;
        const t = (e = this.hls) == null || (e = e.latestLevelDetails) == null ? void 0 : e.partList;
        t && t.forEach(n => n.clearElementaryStreamInfo())
    }
}
function ca(s) {
    var e, t, n;
    return s.buffered && !!(s.body.gap || (e = s.range.video) != null && e.partial || (t = s.range.audio) != null && t.partial || (n = s.range.audiovideo) != null && n.partial)
}
function jn(s) {
    return `${s.type}_${s.level}_${s.sn}`
}
function pf(s, e) {
    return s.filter(t => {
        const n = e(t);
        return n || t.clearElementaryStreamInfo(),
        n
    }
    )
}
var ln = {
    cbc: 0,
    ctr: 1
};
class UT {
    constructor(e, t, n) {
        this.subtle = void 0,
        this.aesIV = void 0,
        this.aesMode = void 0,
        this.subtle = e,
        this.aesIV = t,
        this.aesMode = n
    }
    decrypt(e, t) {
        switch (this.aesMode) {
        case ln.cbc:
            return this.subtle.decrypt({
                name: "AES-CBC",
                iv: this.aesIV
            }, t, e);
        case ln.ctr:
            return this.subtle.decrypt({
                name: "AES-CTR",
                counter: this.aesIV,
                length: 64
            }, t, e);
        default:
            throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`)
        }
    }
}
function BT(s) {
    const e = s.byteLength
      , t = e && new DataView(s.buffer).getUint8(e - 1);
    return t ? s.slice(0, e - t) : s
}
class $T {
    constructor() {
        this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
        this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)],
        this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)],
        this.sBox = new Uint32Array(256),
        this.invSBox = new Uint32Array(256),
        this.key = new Uint32Array(0),
        this.ksRows = 0,
        this.keySize = 0,
        this.keySchedule = void 0,
        this.invKeySchedule = void 0,
        this.initTable()
    }
    uint8ArrayToUint32Array_(e) {
        const t = new DataView(e)
          , n = new Uint32Array(4);
        for (let r = 0; r < 4; r++)
            n[r] = t.getUint32(r * 4);
        return n
    }
    initTable() {
        const e = this.sBox
          , t = this.invSBox
          , n = this.subMix
          , r = n[0]
          , i = n[1]
          , a = n[2]
          , o = n[3]
          , l = this.invSubMix
          , c = l[0]
          , u = l[1]
          , d = l[2]
          , h = l[3]
          , f = new Uint32Array(256);
        let m = 0
          , p = 0
          , x = 0;
        for (x = 0; x < 256; x++)
            x < 128 ? f[x] = x << 1 : f[x] = x << 1 ^ 283;
        for (x = 0; x < 256; x++) {
            let y = p ^ p << 1 ^ p << 2 ^ p << 3 ^ p << 4;
            y = y >>> 8 ^ y & 255 ^ 99,
            e[m] = y,
            t[y] = m;
            const v = f[m]
              , E = f[v]
              , T = f[E];
            let L = f[y] * 257 ^ y * 16843008;
            r[m] = L << 24 | L >>> 8,
            i[m] = L << 16 | L >>> 16,
            a[m] = L << 8 | L >>> 24,
            o[m] = L,
            L = T * 16843009 ^ E * 65537 ^ v * 257 ^ m * 16843008,
            c[y] = L << 24 | L >>> 8,
            u[y] = L << 16 | L >>> 16,
            d[y] = L << 8 | L >>> 24,
            h[y] = L,
            m ? (m = v ^ f[f[f[T ^ v]]],
            p ^= f[f[p]]) : m = p = 1
        }
    }
    expandKey(e) {
        const t = this.uint8ArrayToUint32Array_(e);
        let n = !0
          , r = 0;
        for (; r < t.length && n; )
            n = t[r] === this.key[r],
            r++;
        if (n)
            return;
        this.key = t;
        const i = this.keySize = t.length;
        if (i !== 4 && i !== 6 && i !== 8)
            throw new Error("Invalid aes key size=" + i);
        const a = this.ksRows = (i + 6 + 1) * 4;
        let o, l;
        const c = this.keySchedule = new Uint32Array(a)
          , u = this.invKeySchedule = new Uint32Array(a)
          , d = this.sBox
          , h = this.rcon
          , f = this.invSubMix
          , m = f[0]
          , p = f[1]
          , x = f[2]
          , y = f[3];
        let v, E;
        for (o = 0; o < a; o++) {
            if (o < i) {
                v = c[o] = t[o];
                continue
            }
            E = v,
            o % i === 0 ? (E = E << 8 | E >>> 24,
            E = d[E >>> 24] << 24 | d[E >>> 16 & 255] << 16 | d[E >>> 8 & 255] << 8 | d[E & 255],
            E ^= h[o / i | 0] << 24) : i > 6 && o % i === 4 && (E = d[E >>> 24] << 24 | d[E >>> 16 & 255] << 16 | d[E >>> 8 & 255] << 8 | d[E & 255]),
            c[o] = v = (c[o - i] ^ E) >>> 0
        }
        for (l = 0; l < a; l++)
            o = a - l,
            l & 3 ? E = c[o] : E = c[o - 4],
            l < 4 || o <= 4 ? u[l] = E : u[l] = m[d[E >>> 24]] ^ p[d[E >>> 16 & 255]] ^ x[d[E >>> 8 & 255]] ^ y[d[E & 255]],
            u[l] = u[l] >>> 0
    }
    networkToHostOrderSwap(e) {
        return e << 24 | (e & 65280) << 8 | (e & 16711680) >> 8 | e >>> 24
    }
    decrypt(e, t, n) {
        const r = this.keySize + 6
          , i = this.invKeySchedule
          , a = this.invSBox
          , o = this.invSubMix
          , l = o[0]
          , c = o[1]
          , u = o[2]
          , d = o[3]
          , h = this.uint8ArrayToUint32Array_(n);
        let f = h[0]
          , m = h[1]
          , p = h[2]
          , x = h[3];
        const y = new Int32Array(e)
          , v = new Int32Array(y.length);
        let E, T, L, R, I, A, C, b, O, _, $, K, W, G;
        const V = this.networkToHostOrderSwap;
        for (; t < y.length; ) {
            for (O = V(y[t]),
            _ = V(y[t + 1]),
            $ = V(y[t + 2]),
            K = V(y[t + 3]),
            I = O ^ i[0],
            A = K ^ i[1],
            C = $ ^ i[2],
            b = _ ^ i[3],
            W = 4,
            G = 1; G < r; G++)
                E = l[I >>> 24] ^ c[A >> 16 & 255] ^ u[C >> 8 & 255] ^ d[b & 255] ^ i[W],
                T = l[A >>> 24] ^ c[C >> 16 & 255] ^ u[b >> 8 & 255] ^ d[I & 255] ^ i[W + 1],
                L = l[C >>> 24] ^ c[b >> 16 & 255] ^ u[I >> 8 & 255] ^ d[A & 255] ^ i[W + 2],
                R = l[b >>> 24] ^ c[I >> 16 & 255] ^ u[A >> 8 & 255] ^ d[C & 255] ^ i[W + 3],
                I = E,
                A = T,
                C = L,
                b = R,
                W = W + 4;
            E = a[I >>> 24] << 24 ^ a[A >> 16 & 255] << 16 ^ a[C >> 8 & 255] << 8 ^ a[b & 255] ^ i[W],
            T = a[A >>> 24] << 24 ^ a[C >> 16 & 255] << 16 ^ a[b >> 8 & 255] << 8 ^ a[I & 255] ^ i[W + 1],
            L = a[C >>> 24] << 24 ^ a[b >> 16 & 255] << 16 ^ a[I >> 8 & 255] << 8 ^ a[A & 255] ^ i[W + 2],
            R = a[b >>> 24] << 24 ^ a[I >> 16 & 255] << 16 ^ a[A >> 8 & 255] << 8 ^ a[C & 255] ^ i[W + 3],
            v[t] = V(E ^ f),
            v[t + 1] = V(R ^ m),
            v[t + 2] = V(L ^ p),
            v[t + 3] = V(T ^ x),
            f = O,
            m = _,
            p = $,
            x = K,
            t = t + 4
        }
        return v.buffer
    }
}
class jT {
    constructor(e, t, n) {
        this.subtle = void 0,
        this.key = void 0,
        this.aesMode = void 0,
        this.subtle = e,
        this.key = t,
        this.aesMode = n
    }
    expandKey() {
        const e = GT(this.aesMode);
        return this.subtle.importKey("raw", this.key, {
            name: e
        }, !1, ["encrypt", "decrypt"])
    }
}
function GT(s) {
    switch (s) {
    case ln.cbc:
        return "AES-CBC";
    case ln.ctr:
        return "AES-CTR";
    default:
        throw new Error(`[FastAESKey] invalid aes mode ${s}`)
    }
}
const VT = 16;
class yd {
    constructor(e, {removePKCS7Padding: t=!0}={}) {
        if (this.logEnabled = !0,
        this.removePKCS7Padding = void 0,
        this.subtle = null,
        this.softwareDecrypter = null,
        this.key = null,
        this.fastAesKey = null,
        this.remainderData = null,
        this.currentIV = null,
        this.currentResult = null,
        this.useSoftware = void 0,
        this.enableSoftwareAES = void 0,
        this.enableSoftwareAES = e.enableSoftwareAES,
        this.removePKCS7Padding = t,
        t)
            try {
                const n = self.crypto;
                n && (this.subtle = n.subtle || n.webkitSubtle)
            } catch {}
        this.useSoftware = !this.subtle
    }
    destroy() {
        this.subtle = null,
        this.softwareDecrypter = null,
        this.key = null,
        this.fastAesKey = null,
        this.remainderData = null,
        this.currentIV = null,
        this.currentResult = null
    }
    isSync() {
        return this.useSoftware
    }
    flush() {
        const {currentResult: e, remainderData: t} = this;
        if (!e || t)
            return this.reset(),
            null;
        const n = new Uint8Array(e);
        return this.reset(),
        this.removePKCS7Padding ? BT(n) : n
    }
    reset() {
        this.currentResult = null,
        this.currentIV = null,
        this.remainderData = null,
        this.softwareDecrypter && (this.softwareDecrypter = null)
    }
    decrypt(e, t, n, r) {
        return this.useSoftware ? new Promise( (i, a) => {
            const o = ArrayBuffer.isView(e) ? e : new Uint8Array(e);
            this.softwareDecrypt(o, t, n, r);
            const l = this.flush();
            l ? i(l.buffer) : a(new Error("[softwareDecrypt] Failed to decrypt data"))
        }
        ) : this.webCryptoDecrypt(new Uint8Array(e), t, n, r)
    }
    softwareDecrypt(e, t, n, r) {
        const {currentIV: i, currentResult: a, remainderData: o} = this;
        if (r !== ln.cbc || t.byteLength !== 16)
            return fe.warn("SoftwareDecrypt: can only handle AES-128-CBC"),
            null;
        this.logOnce("JS AES decrypt"),
        o && (e = jt(o, e),
        this.remainderData = null);
        const l = this.getValidChunk(e);
        if (!l.length)
            return null;
        i && (n = i);
        let c = this.softwareDecrypter;
        c || (c = this.softwareDecrypter = new $T),
        c.expandKey(t);
        const u = a;
        return this.currentResult = c.decrypt(l.buffer, 0, n),
        this.currentIV = l.slice(-16).buffer,
        u || null
    }
    webCryptoDecrypt(e, t, n, r) {
        if (this.key !== t || !this.fastAesKey) {
            if (!this.subtle)
                return Promise.resolve(this.onWebCryptoError(e, t, n, r));
            this.key = t,
            this.fastAesKey = new jT(this.subtle,t,r)
        }
        return this.fastAesKey.expandKey().then(i => this.subtle ? (this.logOnce("WebCrypto AES decrypt"),
        new UT(this.subtle,new Uint8Array(n),r).decrypt(e.buffer, i)) : Promise.reject(new Error("web crypto not initialized"))).catch(i => (fe.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${i.name}: ${i.message}`),
        this.onWebCryptoError(e, t, n, r)))
    }
    onWebCryptoError(e, t, n, r) {
        const i = this.enableSoftwareAES;
        if (i) {
            this.useSoftware = !0,
            this.logEnabled = !0,
            this.softwareDecrypt(e, t, n, r);
            const a = this.flush();
            if (a)
                return a.buffer
        }
        throw new Error("WebCrypto" + (i ? " and softwareDecrypt" : "") + ": failed to decrypt data")
    }
    getValidChunk(e) {
        let t = e;
        const n = e.length - e.length % VT;
        return n !== e.length && (t = e.slice(0, n),
        this.remainderData = e.slice(n)),
        t
    }
    logOnce(e) {
        this.logEnabled && (fe.log(`[decrypter]: ${e}`),
        this.logEnabled = !1)
    }
}
const yf = Math.pow(2, 17);
class HT {
    constructor(e) {
        this.config = void 0,
        this.loader = null,
        this.partLoadTimeout = -1,
        this.config = e
    }
    destroy() {
        this.loader && (this.loader.destroy(),
        this.loader = null)
    }
    abort() {
        this.loader && this.loader.abort()
    }
    load(e, t) {
        const n = e.url;
        if (!n)
            return Promise.reject(new Ls({
                type: q.NETWORK_ERROR,
                details: N.FRAG_LOAD_ERROR,
                fatal: !1,
                frag: e,
                error: new Error(`Fragment does not have a ${n ? "part list" : "url"}`),
                networkDetails: null
            }));
        this.abort();
        const r = this.config
          , i = r.fLoader
          , a = r.loader;
        return new Promise( (o, l) => {
            if (this.loader && this.loader.destroy(),
            e.gap)
                if (e.tagList.some(m => m[0] === "GAP")) {
                    l(vf(e));
                    return
                } else
                    e.gap = !1;
            const c = this.loader = i ? new i(r) : new a(r)
              , u = xf(e);
            e.loader = c;
            const d = gf(r.fragLoadPolicy.default)
              , h = {
                loadPolicy: d,
                timeout: d.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0,
                highWaterMark: e.sn === "initSegment" ? 1 / 0 : yf
            };
            e.stats = c.stats;
            const f = {
                onSuccess: (m, p, x, y) => {
                    this.resetLoader(e, c);
                    let v = m.data;
                    x.resetIV && e.decryptdata && (e.decryptdata.iv = new Uint8Array(v.slice(0, 16)),
                    v = v.slice(16)),
                    o({
                        frag: e,
                        part: null,
                        payload: v,
                        networkDetails: y
                    })
                }
                ,
                onError: (m, p, x, y) => {
                    this.resetLoader(e, c),
                    l(new Ls({
                        type: q.NETWORK_ERROR,
                        details: N.FRAG_LOAD_ERROR,
                        fatal: !1,
                        frag: e,
                        response: pe({
                            url: n,
                            data: void 0
                        }, m),
                        error: new Error(`HTTP Error ${m.code} ${m.text}`),
                        networkDetails: x,
                        stats: y
                    }))
                }
                ,
                onAbort: (m, p, x) => {
                    this.resetLoader(e, c),
                    l(new Ls({
                        type: q.NETWORK_ERROR,
                        details: N.INTERNAL_ABORTED,
                        fatal: !1,
                        frag: e,
                        error: new Error("Aborted"),
                        networkDetails: x,
                        stats: m
                    }))
                }
                ,
                onTimeout: (m, p, x) => {
                    this.resetLoader(e, c),
                    l(new Ls({
                        type: q.NETWORK_ERROR,
                        details: N.FRAG_LOAD_TIMEOUT,
                        fatal: !1,
                        frag: e,
                        error: new Error(`Timeout after ${h.timeout}ms`),
                        networkDetails: x,
                        stats: m
                    }))
                }
            };
            t && (f.onProgress = (m, p, x, y) => t({
                frag: e,
                part: null,
                payload: x,
                networkDetails: y
            })),
            c.load(u, h, f)
        }
        )
    }
    loadPart(e, t, n) {
        this.abort();
        const r = this.config
          , i = r.fLoader
          , a = r.loader;
        return new Promise( (o, l) => {
            if (this.loader && this.loader.destroy(),
            e.gap || t.gap) {
                l(vf(e, t));
                return
            }
            const c = this.loader = i ? new i(r) : new a(r)
              , u = xf(e, t);
            e.loader = c;
            const d = gf(r.fragLoadPolicy.default)
              , h = {
                loadPolicy: d,
                timeout: d.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0,
                highWaterMark: yf
            };
            t.stats = c.stats,
            c.load(u, h, {
                onSuccess: (f, m, p, x) => {
                    this.resetLoader(e, c),
                    this.updateStatsFromPart(e, t);
                    const y = {
                        frag: e,
                        part: t,
                        payload: f.data,
                        networkDetails: x
                    };
                    n(y),
                    o(y)
                }
                ,
                onError: (f, m, p, x) => {
                    this.resetLoader(e, c),
                    l(new Ls({
                        type: q.NETWORK_ERROR,
                        details: N.FRAG_LOAD_ERROR,
                        fatal: !1,
                        frag: e,
                        part: t,
                        response: pe({
                            url: u.url,
                            data: void 0
                        }, f),
                        error: new Error(`HTTP Error ${f.code} ${f.text}`),
                        networkDetails: p,
                        stats: x
                    }))
                }
                ,
                onAbort: (f, m, p) => {
                    e.stats.aborted = t.stats.aborted,
                    this.resetLoader(e, c),
                    l(new Ls({
                        type: q.NETWORK_ERROR,
                        details: N.INTERNAL_ABORTED,
                        fatal: !1,
                        frag: e,
                        part: t,
                        error: new Error("Aborted"),
                        networkDetails: p,
                        stats: f
                    }))
                }
                ,
                onTimeout: (f, m, p) => {
                    this.resetLoader(e, c),
                    l(new Ls({
                        type: q.NETWORK_ERROR,
                        details: N.FRAG_LOAD_TIMEOUT,
                        fatal: !1,
                        frag: e,
                        part: t,
                        error: new Error(`Timeout after ${h.timeout}ms`),
                        networkDetails: p,
                        stats: f
                    }))
                }
            })
        }
        )
    }
    updateStatsFromPart(e, t) {
        const n = e.stats
          , r = t.stats
          , i = r.total;
        if (n.loaded += r.loaded,
        i) {
            const l = Math.round(e.duration / t.duration)
              , c = Math.min(Math.round(n.loaded / i), l)
              , d = (l - c) * Math.round(n.loaded / c);
            n.total = n.loaded + d
        } else
            n.total = Math.max(n.loaded, n.total);
        const a = n.loading
          , o = r.loading;
        a.start ? a.first += o.first - o.start : (a.start = o.start,
        a.first = o.first),
        a.end = o.end
    }
    resetLoader(e, t) {
        e.loader = null,
        this.loader === t && (self.clearTimeout(this.partLoadTimeout),
        this.loader = null),
        t.destroy()
    }
}
function xf(s, e=null) {
    const t = e || s
      , n = {
        frag: s,
        part: e,
        responseType: "arraybuffer",
        url: t.url,
        headers: {},
        rangeStart: 0,
        rangeEnd: 0
    }
      , r = t.byteRangeStartOffset
      , i = t.byteRangeEndOffset;
    if (z(r) && z(i)) {
        var a;
        let o = r
          , l = i;
        if (s.sn === "initSegment" && KT((a = s.decryptdata) == null ? void 0 : a.method)) {
            const c = i - r;
            c % 16 && (l = i + (16 - c % 16)),
            r !== 0 && (n.resetIV = !0,
            o = r - 16)
        }
        n.rangeStart = o,
        n.rangeEnd = l
    }
    return n
}
function vf(s, e) {
    const t = new Error(`GAP ${s.gap ? "tag" : "attribute"} found`)
      , n = {
        type: q.MEDIA_ERROR,
        details: N.FRAG_GAP,
        fatal: !1,
        frag: s,
        error: t,
        networkDetails: null
    };
    return e && (n.part = e),
    (e || s).stats.aborted = !0,
    new Ls(n)
}
function KT(s) {
    return s === "AES-128" || s === "AES-256"
}
class Ls extends Error {
    constructor(e) {
        super(e.error.message),
        this.data = void 0,
        this.data = e
    }
}
class d0 extends Gt {
    constructor(e, t) {
        super(e, t),
        this._boundTick = void 0,
        this._tickTimer = null,
        this._tickInterval = null,
        this._tickCallCount = 0,
        this._boundTick = this.tick.bind(this)
    }
    destroy() {
        this.onHandlerDestroying(),
        this.onHandlerDestroyed()
    }
    onHandlerDestroying() {
        this.clearNextTick(),
        this.clearInterval()
    }
    onHandlerDestroyed() {}
    hasInterval() {
        return !!this._tickInterval
    }
    hasNextTick() {
        return !!this._tickTimer
    }
    setInterval(e) {
        return this._tickInterval ? !1 : (this._tickCallCount = 0,
        this._tickInterval = self.setInterval(this._boundTick, e),
        !0)
    }
    clearInterval() {
        return this._tickInterval ? (self.clearInterval(this._tickInterval),
        this._tickInterval = null,
        !0) : !1
    }
    clearNextTick() {
        return this._tickTimer ? (self.clearTimeout(this._tickTimer),
        this._tickTimer = null,
        !0) : !1
    }
    tick() {
        this._tickCallCount++,
        this._tickCallCount === 1 && (this.doTick(),
        this._tickCallCount > 1 && this.tickImmediate(),
        this._tickCallCount = 0)
    }
    tickImmediate() {
        this.clearNextTick(),
        this._tickTimer = self.setTimeout(this._boundTick, 0)
    }
    doTick() {}
}
class xd {
    constructor(e, t, n, r=0, i=-1, a=!1) {
        this.level = void 0,
        this.sn = void 0,
        this.part = void 0,
        this.id = void 0,
        this.size = void 0,
        this.partial = void 0,
        this.transmuxing = ua(),
        this.buffering = {
            audio: ua(),
            video: ua(),
            audiovideo: ua()
        },
        this.level = e,
        this.sn = t,
        this.id = n,
        this.size = r,
        this.part = i,
        this.partial = a
    }
}
function ua() {
    return {
        start: 0,
        executeStart: 0,
        executeEnd: 0,
        end: 0
    }
}
const Ef = {
    length: 0,
    start: () => 0,
    end: () => 0
};
class ie {
    static isBuffered(e, t) {
        if (e) {
            const n = ie.getBuffered(e);
            for (let r = n.length; r--; )
                if (t >= n.start(r) && t <= n.end(r))
                    return !0
        }
        return !1
    }
    static bufferedRanges(e) {
        if (e) {
            const t = ie.getBuffered(e);
            return ie.timeRangesToArray(t)
        }
        return []
    }
    static timeRangesToArray(e) {
        const t = [];
        for (let n = 0; n < e.length; n++)
            t.push({
                start: e.start(n),
                end: e.end(n)
            });
        return t
    }
    static bufferInfo(e, t, n) {
        if (e) {
            const r = ie.bufferedRanges(e);
            if (r.length)
                return ie.bufferedInfo(r, t, n)
        }
        return {
            len: 0,
            start: t,
            end: t,
            bufferedIndex: -1
        }
    }
    static bufferedInfo(e, t, n) {
        t = Math.max(0, t),
        e.length > 1 && e.sort( (u, d) => u.start - d.start || d.end - u.end);
        let r = -1
          , i = [];
        if (n)
            for (let u = 0; u < e.length; u++) {
                t >= e[u].start && t <= e[u].end && (r = u);
                const d = i.length;
                if (d) {
                    const h = i[d - 1].end;
                    e[u].start - h < n ? e[u].end > h && (i[d - 1].end = e[u].end) : i.push(e[u])
                } else
                    i.push(e[u])
            }
        else
            i = e;
        let a = 0, o, l = t, c = t;
        for (let u = 0; u < i.length; u++) {
            const d = i[u].start
              , h = i[u].end;
            if (r === -1 && t >= d && t <= h && (r = u),
            t + n >= d && t < h)
                l = d,
                c = h,
                a = c - t;
            else if (t + n < d) {
                o = d;
                break
            }
        }
        return {
            len: a,
            start: l || 0,
            end: c || 0,
            nextStart: o,
            buffered: e,
            bufferedIndex: r
        }
    }
    static getBuffered(e) {
        try {
            return e.buffered || Ef
        } catch (t) {
            return fe.log("failed to get media.buffered", t),
            Ef
        }
    }
}
const h0 = /\{\$([a-zA-Z0-9-_]+)\}/g;
function Sf(s) {
    return h0.test(s)
}
function Qc(s, e) {
    if (s.variableList !== null || s.hasVariableRefs) {
        const t = s.variableList;
        return e.replace(h0, n => {
            const r = n.substring(2, n.length - 1)
              , i = t == null ? void 0 : t[r];
            return i === void 0 ? (s.playlistParsingError || (s.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${r}"`)),
            n) : i
        }
        )
    }
    return e
}
function Tf(s, e, t) {
    let n = s.variableList;
    n || (s.variableList = n = {});
    let r, i;
    if ("QUERYPARAM"in e) {
        r = e.QUERYPARAM;
        try {
            const a = new self.URL(t).searchParams;
            if (a.has(r))
                i = a.get(r);
            else
                throw new Error(`"${r}" does not match any query parameter in URI: "${t}"`)
        } catch (a) {
            s.playlistParsingError || (s.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${a.message}`))
        }
    } else
        r = e.NAME,
        i = e.VALUE;
    r in n ? s.playlistParsingError || (s.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${r}"`)) : n[r] = i || ""
}
function WT(s, e, t) {
    const n = e.IMPORT;
    if (t && n in t) {
        let r = s.variableList;
        r || (s.variableList = r = {}),
        r[n] = t[n]
    } else
        s.playlistParsingError || (s.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${n}"`))
}
const zT = /^(\d+)x(\d+)$/
  , Lf = /(.+?)=(".*?"|.*?)(?:,|$)/g;
class Ae {
    constructor(e, t) {
        typeof e == "string" && (e = Ae.parseAttrList(e, t)),
        ye(this, e)
    }
    get clientAttrs() {
        return Object.keys(this).filter(e => e.substring(0, 2) === "X-")
    }
    decimalInteger(e) {
        const t = parseInt(this[e], 10);
        return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
    }
    hexadecimalInteger(e) {
        if (this[e]) {
            let t = (this[e] || "0x").slice(2);
            t = (t.length & 1 ? "0" : "") + t;
            const n = new Uint8Array(t.length / 2);
            for (let r = 0; r < t.length / 2; r++)
                n[r] = parseInt(t.slice(r * 2, r * 2 + 2), 16);
            return n
        }
        return null
    }
    hexadecimalIntegerAsNumber(e) {
        const t = parseInt(this[e], 16);
        return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
    }
    decimalFloatingPoint(e) {
        return parseFloat(this[e])
    }
    optionalFloat(e, t) {
        const n = this[e];
        return n ? parseFloat(n) : t
    }
    enumeratedString(e) {
        return this[e]
    }
    enumeratedStringList(e, t) {
        const n = this[e];
        return (n ? n.split(/[ ,]+/) : []).reduce( (r, i) => (r[i.toLowerCase()] = !0,
        r), t)
    }
    bool(e) {
        return this[e] === "YES"
    }
    decimalResolution(e) {
        const t = zT.exec(this[e]);
        if (t !== null)
            return {
                width: parseInt(t[1], 10),
                height: parseInt(t[2], 10)
            }
    }
    static parseAttrList(e, t) {
        let n;
        const r = {}
          , i = '"';
        for (Lf.lastIndex = 0; (n = Lf.exec(e)) !== null; ) {
            const a = n[1].trim();
            let o = n[2];
            const l = o.indexOf(i) === 0 && o.lastIndexOf(i) === o.length - 1;
            let c = !1;
            if (l)
                o = o.slice(1, -1);
            else
                switch (a) {
                case "IV":
                case "SCTE35-CMD":
                case "SCTE35-IN":
                case "SCTE35-OUT":
                    c = !0
                }
            if (t && (l || c))
                o = Qc(t, o);
            else if (!c && !l)
                switch (a) {
                case "CLOSED-CAPTIONS":
                    if (o === "NONE")
                        break;
                case "ALLOWED-CPC":
                case "CLASS":
                case "ASSOC-LANGUAGE":
                case "AUDIO":
                case "BYTERANGE":
                case "CHANNELS":
                case "CHARACTERISTICS":
                case "CODECS":
                case "DATA-ID":
                case "END-DATE":
                case "GROUP-ID":
                case "ID":
                case "IMPORT":
                case "INSTREAM-ID":
                case "KEYFORMAT":
                case "KEYFORMATVERSIONS":
                case "LANGUAGE":
                case "NAME":
                case "PATHWAY-ID":
                case "QUERYPARAM":
                case "RECENTLY-REMOVED-DATERANGES":
                case "SERVER-URI":
                case "STABLE-RENDITION-ID":
                case "STABLE-VARIANT-ID":
                case "START-DATE":
                case "SUBTITLES":
                case "SUPPLEMENTAL-CODECS":
                case "URI":
                case "VALUE":
                case "VIDEO":
                case "X-ASSET-LIST":
                case "X-ASSET-URI":
                    fe.warn(`${e}: attribute ${a} is missing quotes`)
                }
            r[a] = o
        }
        return r
    }
}
const YT = "com.apple.hls.interstitial";
function XT(s) {
    return s !== "ID" && s !== "CLASS" && s !== "CUE" && s !== "START-DATE" && s !== "DURATION" && s !== "END-DATE" && s !== "END-ON-NEXT"
}
function ZT(s) {
    return s === "SCTE35-OUT" || s === "SCTE35-IN" || s === "SCTE35-CMD"
}
class f0 {
    constructor(e, t, n=0) {
        var r;
        if (this.attr = void 0,
        this.tagAnchor = void 0,
        this.tagOrder = void 0,
        this._startDate = void 0,
        this._endDate = void 0,
        this._dateAtEnd = void 0,
        this._cue = void 0,
        this._badValueForSameId = void 0,
        this.tagAnchor = (t == null ? void 0 : t.tagAnchor) || null,
        this.tagOrder = (r = t == null ? void 0 : t.tagOrder) != null ? r : n,
        t) {
            const i = t.attr;
            for (const a in i)
                if (Object.prototype.hasOwnProperty.call(e, a) && e[a] !== i[a]) {
                    fe.warn(`DATERANGE tag attribute: "${a}" does not match for tags with ID: "${e.ID}"`),
                    this._badValueForSameId = a;
                    break
                }
            e = ye(new Ae({}), i, e)
        }
        if (this.attr = e,
        t ? (this._startDate = t._startDate,
        this._cue = t._cue,
        this._endDate = t._endDate,
        this._dateAtEnd = t._dateAtEnd) : this._startDate = new Date(e["START-DATE"]),
        "END-DATE"in this.attr) {
            const i = (t == null ? void 0 : t.endDate) || new Date(this.attr["END-DATE"]);
            z(i.getTime()) && (this._endDate = i)
        }
    }
    get id() {
        return this.attr.ID
    }
    get class() {
        return this.attr.CLASS
    }
    get cue() {
        const e = this._cue;
        return e === void 0 ? this._cue = this.attr.enumeratedStringList(this.attr.CUE ? "CUE" : "X-CUE", {
            pre: !1,
            post: !1,
            once: !1
        }) : e
    }
    get startTime() {
        const {tagAnchor: e} = this;
        return e === null || e.programDateTime === null ? (fe.warn(`Expected tagAnchor Fragment with PDT set for DateRange "${this.id}": ${e}`),
        NaN) : e.start + (this.startDate.getTime() - e.programDateTime) / 1e3
    }
    get startDate() {
        return this._startDate
    }
    get endDate() {
        const e = this._endDate || this._dateAtEnd;
        if (e)
            return e;
        const t = this.duration;
        return t !== null ? this._dateAtEnd = new Date(this._startDate.getTime() + t * 1e3) : null
    }
    get duration() {
        if ("DURATION"in this.attr) {
            const e = this.attr.decimalFloatingPoint("DURATION");
            if (z(e))
                return e
        } else if (this._endDate)
            return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
        return null
    }
    get plannedDuration() {
        return "PLANNED-DURATION"in this.attr ? this.attr.decimalFloatingPoint("PLANNED-DURATION") : null
    }
    get endOnNext() {
        return this.attr.bool("END-ON-NEXT")
    }
    get isInterstitial() {
        return this.class === YT
    }
    get isValid() {
        return !!this.id && !this._badValueForSameId && z(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class) && (!this.attr.CUE || !this.cue.pre && !this.cue.post || this.cue.pre !== this.cue.post) && (!this.isInterstitial || "X-ASSET-URI"in this.attr || "X-ASSET-LIST"in this.attr)
    }
}
const qT = 10;
class QT {
    constructor(e) {
        this.PTSKnown = !1,
        this.alignedSliding = !1,
        this.averagetargetduration = void 0,
        this.endCC = 0,
        this.endSN = 0,
        this.fragments = void 0,
        this.fragmentHint = void 0,
        this.partList = null,
        this.dateRanges = void 0,
        this.dateRangeTagCount = 0,
        this.live = !0,
        this.requestScheduled = -1,
        this.ageHeader = 0,
        this.advancedDateTime = void 0,
        this.updated = !0,
        this.advanced = !0,
        this.misses = 0,
        this.startCC = 0,
        this.startSN = 0,
        this.startTimeOffset = null,
        this.targetduration = 0,
        this.totalduration = 0,
        this.type = null,
        this.url = void 0,
        this.m3u8 = "",
        this.version = null,
        this.canBlockReload = !1,
        this.canSkipUntil = 0,
        this.canSkipDateRanges = !1,
        this.skippedSegments = 0,
        this.recentlyRemovedDateranges = void 0,
        this.partHoldBack = 0,
        this.holdBack = 0,
        this.partTarget = 0,
        this.preloadHint = void 0,
        this.renditionReports = void 0,
        this.tuneInGoal = 0,
        this.deltaUpdateFailed = void 0,
        this.driftStartTime = 0,
        this.driftEndTime = 0,
        this.driftStart = 0,
        this.driftEnd = 0,
        this.encryptedFragments = void 0,
        this.playlistParsingError = null,
        this.variableList = null,
        this.hasVariableRefs = !1,
        this.appliedTimelineOffset = void 0,
        this.fragments = [],
        this.encryptedFragments = [],
        this.dateRanges = {},
        this.url = e
    }
    reloaded(e) {
        if (!e) {
            this.advanced = !0,
            this.updated = !0;
            return
        }
        const t = this.lastPartSn - e.lastPartSn
          , n = this.lastPartIndex - e.lastPartIndex;
        this.updated = this.endSN !== e.endSN || !!n || !!t || !this.live,
        this.advanced = this.endSN > e.endSN || t > 0 || t === 0 && n > 0,
        this.updated || this.advanced ? this.misses = Math.floor(e.misses * .6) : this.misses = e.misses + 1
    }
    hasKey(e) {
        return this.encryptedFragments.some(t => {
            let n = t.decryptdata;
            return n || (t.setKeyFormat(e.keyFormat),
            n = t.decryptdata),
            !!n && e.matches(n)
        }
        )
    }
    get hasProgramDateTime() {
        return this.fragments.length ? z(this.fragments[this.fragments.length - 1].programDateTime) : !1
    }
    get levelTargetDuration() {
        return this.averagetargetduration || this.targetduration || qT
    }
    get drift() {
        const e = this.driftEndTime - this.driftStartTime;
        return e > 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1
    }
    get edge() {
        return this.partEnd || this.fragmentEnd
    }
    get partEnd() {
        var e;
        return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
    }
    get fragmentEnd() {
        return this.fragments.length ? this.fragments[this.fragments.length - 1].end : 0
    }
    get fragmentStart() {
        return this.fragments.length ? this.fragments[0].start : 0
    }
    get age() {
        return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
    }
    get lastPartIndex() {
        var e;
        return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].index : -1
    }
    get maxPartIndex() {
        const e = this.partList;
        if (e) {
            const t = this.lastPartIndex;
            if (t !== -1) {
                for (let n = e.length; n--; )
                    if (e[n].index > t)
                        return e[n].index;
                return t
            }
        }
        return 0
    }
    get lastPartSn() {
        var e;
        return (e = this.partList) != null && e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
    }
    get expired() {
        if (this.live && this.age && this.misses < 3) {
            const e = this.partEnd - this.fragmentStart;
            return this.age > Math.max(e, this.totalduration) + this.levelTargetDuration
        }
        return !1
    }
}
function m0(s, e) {
    return s.length === e.length ? !s.some( (t, n) => t !== e[n]) : !1
}
function If(s, e) {
    return !s && !e ? !0 : !s || !e ? !1 : m0(s, e)
}
function fr(s) {
    return s === "AES-128" || s === "AES-256" || s === "AES-256-CTR"
}
function vd(s) {
    switch (s) {
    case "AES-128":
    case "AES-256":
        return ln.cbc;
    case "AES-256-CTR":
        return ln.ctr;
    default:
        throw new Error(`invalid full segment method ${s}`)
    }
}
function Ed(s) {
    return Uint8Array.from(atob(s), e => e.charCodeAt(0))
}
function Jc(s) {
    return Uint8Array.from(unescape(encodeURIComponent(s)), e => e.charCodeAt(0))
}
function JT(s) {
    const e = Jc(s).subarray(0, 16)
      , t = new Uint8Array(16);
    return t.set(e, 16 - e.length),
    t
}
function e1(s) {
    const e = function(n, r, i) {
        const a = n[r];
        n[r] = n[i],
        n[i] = a
    };
    e(s, 0, 3),
    e(s, 1, 2),
    e(s, 4, 5),
    e(s, 6, 7)
}
function t1(s) {
    const e = s.split(":");
    let t = null;
    if (e[0] === "data" && e.length === 2) {
        const n = e[1].split(";")
          , r = n[n.length - 1].split(",");
        if (r.length === 2) {
            const i = r[0] === "base64"
              , a = r[1];
            i ? (n.splice(-1, 1),
            t = Ed(a)) : t = JT(a)
        }
    }
    return t
}
const Ao = typeof self < "u" ? self : void 0;
var Pe = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.fps",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "com.widevine.alpha"
}
  , gt = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.streamingkeydelivery",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
};
function Ua(s) {
    switch (s) {
    case gt.FAIRPLAY:
        return Pe.FAIRPLAY;
    case gt.PLAYREADY:
        return Pe.PLAYREADY;
    case gt.WIDEVINE:
        return Pe.WIDEVINE;
    case gt.CLEARKEY:
        return Pe.CLEARKEY
    }
}
function Dl(s) {
    switch (s) {
    case Pe.FAIRPLAY:
        return gt.FAIRPLAY;
    case Pe.PLAYREADY:
        return gt.PLAYREADY;
    case Pe.WIDEVINE:
        return gt.WIDEVINE;
    case Pe.CLEARKEY:
        return gt.CLEARKEY
    }
}
function zr(s) {
    const {drmSystems: e, widevineLicenseUrl: t} = s
      , n = e ? [Pe.FAIRPLAY, Pe.WIDEVINE, Pe.PLAYREADY, Pe.CLEARKEY].filter(r => !!e[r]) : [];
    return !n[Pe.WIDEVINE] && t && n.push(Pe.WIDEVINE),
    n
}
const g0 = function(s) {
    return Ao != null && (s = Ao.navigator) != null && s.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null
}();
function s1(s, e, t, n) {
    let r;
    switch (s) {
    case Pe.FAIRPLAY:
        r = ["cenc", "sinf"];
        break;
    case Pe.WIDEVINE:
    case Pe.PLAYREADY:
        r = ["cenc"];
        break;
    case Pe.CLEARKEY:
        r = ["cenc", "keyids"];
        break;
    default:
        throw new Error(`Unknown key-system: ${s}`)
    }
    return n1(r, e, t, n)
}
function n1(s, e, t, n) {
    return [{
        initDataTypes: s,
        persistentState: n.persistentState || "optional",
        distinctiveIdentifier: n.distinctiveIdentifier || "optional",
        sessionTypes: n.sessionTypes || [n.sessionType || "temporary"],
        audioCapabilities: e.map(i => ({
            contentType: `audio/mp4; codecs=${i}`,
            robustness: n.audioRobustness || "",
            encryptionScheme: n.audioEncryptionScheme || null
        })),
        videoCapabilities: t.map(i => ({
            contentType: `video/mp4; codecs=${i}`,
            robustness: n.videoRobustness || "",
            encryptionScheme: n.videoEncryptionScheme || null
        }))
    }]
}
function r1(s) {
    var e;
    return !!s && (s.sessionType === "persistent-license" || !!((e = s.sessionTypes) != null && e.some(t => t === "persistent-license")))
}
function i1(s) {
    const e = new Uint16Array(s.buffer,s.byteOffset,s.byteLength / 2)
      , t = String.fromCharCode.apply(null, Array.from(e))
      , n = t.substring(t.indexOf("<"), t.length)
      , a = new DOMParser().parseFromString(n, "text/xml").getElementsByTagName("KID")[0];
    if (a) {
        const o = a.childNodes[0] ? a.childNodes[0].nodeValue : a.getAttribute("VALUE");
        if (o) {
            const l = Ed(o).subarray(0, 16);
            return e1(l),
            l
        }
    }
    return null
}
let da = {};
class Xo {
    static clearKeyUriToKeyIdMap() {
        da = {}
    }
    constructor(e, t, n, r=[1], i=null, a) {
        this.uri = void 0,
        this.method = void 0,
        this.keyFormat = void 0,
        this.keyFormatVersions = void 0,
        this.encrypted = void 0,
        this.isCommonEncryption = void 0,
        this.iv = null,
        this.key = null,
        this.keyId = null,
        this.pssh = null,
        this.method = e,
        this.uri = t,
        this.keyFormat = n,
        this.keyFormatVersions = r,
        this.iv = i,
        this.encrypted = e ? e !== "NONE" : !1,
        this.isCommonEncryption = this.encrypted && !fr(e),
        a != null && a.startsWith("0x") && (this.keyId = new Uint8Array(Yp(a)))
    }
    matches(e) {
        return e.uri === this.uri && e.method === this.method && e.encrypted === this.encrypted && e.keyFormat === this.keyFormat && m0(e.keyFormatVersions, this.keyFormatVersions) && If(e.iv, this.iv) && If(e.keyId, this.keyId)
    }
    isSupported() {
        if (this.method) {
            if (fr(this.method) || this.method === "NONE")
                return !0;
            if (this.keyFormat === "identity")
                return this.method === "SAMPLE-AES";
            switch (this.keyFormat) {
            case gt.FAIRPLAY:
            case gt.WIDEVINE:
            case gt.PLAYREADY:
            case gt.CLEARKEY:
                return ["SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1
            }
        }
        return !1
    }
    getDecryptData(e) {
        if (!this.encrypted || !this.uri)
            return null;
        if (fr(this.method) && this.uri && !this.iv) {
            typeof e != "number" && (fe.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`),
            e = 0);
            const n = a1(e);
            return new Xo(this.method,this.uri,"identity",this.keyFormatVersions,n)
        }
        if (this.pssh && this.keyId)
            return this;
        const t = t1(this.uri);
        if (t)
            switch (this.keyFormat) {
            case gt.WIDEVINE:
                if (this.pssh = t,
                !this.keyId && t.length >= 22) {
                    const n = t.length - 22;
                    this.keyId = t.subarray(n, n + 16)
                }
                break;
            case gt.PLAYREADY:
                {
                    const n = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
                    this.pssh = lT(n, null, t),
                    this.keyId = i1(t);
                    break
                }
            default:
                {
                    let n = t.subarray(0, 16);
                    if (n.length !== 16) {
                        const r = new Uint8Array(16);
                        r.set(n, 16 - n.length),
                        n = r
                    }
                    this.keyId = n;
                    break
                }
            }
        if (!this.keyId || this.keyId.byteLength !== 16) {
            let n = da[this.uri];
            if (!n) {
                const r = Object.keys(da).length % Number.MAX_SAFE_INTEGER;
                n = new Uint8Array(16),
                new DataView(n.buffer,12,4).setUint32(0, r),
                da[this.uri] = n
            }
            this.keyId = n
        }
        return this
    }
}
function a1(s) {
    const e = new Uint8Array(16);
    for (let t = 12; t < 16; t++)
        e[t] = s >> 8 * (15 - t) & 255;
    return e
}
const Af = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g
  , bf = /#EXT-X-MEDIA:(.*)/g
  , o1 = /^#EXT(?:INF|-X-TARGETDURATION):/m
  , Pl = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[^\r\n]*)/.source, /#.*/.source].join("|"),"g")
  , l1 = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
class cs {
    static findGroup(e, t) {
        for (let n = 0; n < e.length; n++) {
            const r = e[n];
            if (r.id === t)
                return r
        }
    }
    static resolve(e, t) {
        return dd.buildAbsoluteURL(t, e, {
            alwaysNormalize: !0
        })
    }
    static isMediaPlaylist(e) {
        return o1.test(e)
    }
    static parseMasterPlaylist(e, t) {
        const n = Sf(e)
          , r = {
            contentSteering: null,
            levels: [],
            playlistParsingError: null,
            sessionData: null,
            sessionKeys: null,
            startTimeOffset: null,
            variableList: null,
            hasVariableRefs: n
        }
          , i = [];
        Af.lastIndex = 0;
        let a;
        for (; (a = Af.exec(e)) != null; )
            if (a[1]) {
                var o;
                const c = new Ae(a[1],r)
                  , u = Qc(r, a[2])
                  , d = {
                    attrs: c,
                    bitrate: c.decimalInteger("BANDWIDTH") || c.decimalInteger("AVERAGE-BANDWIDTH"),
                    name: c.NAME,
                    url: cs.resolve(u, t)
                }
                  , h = c.decimalResolution("RESOLUTION");
                h && (d.width = h.width,
                d.height = h.height),
                Cf(c.CODECS, d);
                const f = c["SUPPLEMENTAL-CODECS"];
                f && (d.supplemental = {},
                Cf(f, d.supplemental)),
                (o = d.unknownCodecs) != null && o.length || i.push(d),
                r.levels.push(d)
            } else if (a[3]) {
                const c = a[3]
                  , u = a[4];
                switch (c) {
                case "SESSION-DATA":
                    {
                        const d = new Ae(u,r)
                          , h = d["DATA-ID"];
                        h && (r.sessionData === null && (r.sessionData = {}),
                        r.sessionData[h] = d);
                        break
                    }
                case "SESSION-KEY":
                    {
                        const d = Rf(u, t, r);
                        d.encrypted && d.isSupported() ? (r.sessionKeys === null && (r.sessionKeys = []),
                        r.sessionKeys.push(d)) : fe.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${u}"`);
                        break
                    }
                case "DEFINE":
                    {
                        {
                            const d = new Ae(u,r);
                            Tf(r, d, t)
                        }
                        break
                    }
                case "CONTENT-STEERING":
                    {
                        const d = new Ae(u,r);
                        r.contentSteering = {
                            uri: cs.resolve(d["SERVER-URI"], t),
                            pathwayId: d["PATHWAY-ID"] || "."
                        };
                        break
                    }
                case "START":
                    {
                        r.startTimeOffset = wf(u);
                        break
                    }
                }
            }
        const l = i.length > 0 && i.length < r.levels.length;
        return r.levels = l ? i : r.levels,
        r.levels.length === 0 && (r.playlistParsingError = new Error("no levels found in manifest")),
        r
    }
    static parseMasterPlaylistMedia(e, t, n) {
        let r;
        const i = {}
          , a = n.levels
          , o = {
            AUDIO: a.map(c => ({
                id: c.attrs.AUDIO,
                audioCodec: c.audioCodec
            })),
            SUBTITLES: a.map(c => ({
                id: c.attrs.SUBTITLES,
                textCodec: c.textCodec
            })),
            "CLOSED-CAPTIONS": []
        };
        let l = 0;
        for (bf.lastIndex = 0; (r = bf.exec(e)) !== null; ) {
            const c = new Ae(r[1],n)
              , u = c.TYPE;
            if (u) {
                const d = o[u]
                  , h = i[u] || [];
                i[u] = h;
                const f = c.LANGUAGE
                  , m = c["ASSOC-LANGUAGE"]
                  , p = c.CHANNELS
                  , x = c.CHARACTERISTICS
                  , y = c["INSTREAM-ID"]
                  , v = {
                    attrs: c,
                    bitrate: 0,
                    id: l++,
                    groupId: c["GROUP-ID"] || "",
                    name: c.NAME || f || "",
                    type: u,
                    default: c.bool("DEFAULT"),
                    autoselect: c.bool("AUTOSELECT"),
                    forced: c.bool("FORCED"),
                    lang: f,
                    url: c.URI ? cs.resolve(c.URI, t) : ""
                };
                if (m && (v.assocLang = m),
                p && (v.channels = p),
                x && (v.characteristics = x),
                y && (v.instreamId = y),
                d != null && d.length) {
                    const E = cs.findGroup(d, v.groupId) || d[0];
                    kf(v, E, "audioCodec"),
                    kf(v, E, "textCodec")
                }
                h.push(v)
            }
        }
        return i
    }
    static parseLevelPlaylist(e, t, n, r, i, a) {
        var o;
        const l = {
            url: t
        }
          , c = new QT(t)
          , u = c.fragments
          , d = [];
        let h = null, f = 0, m = 0, p = 0, x = 0, y = 0, v = null, E = new Cl(r,l), T, L, R, I = -1, A = !1, C = null, b;
        if (Pl.lastIndex = 0,
        c.m3u8 = e,
        c.hasVariableRefs = Sf(e),
        ((o = Pl.exec(e)) == null ? void 0 : o[0]) !== "#EXTM3U")
            return c.playlistParsingError = new Error("Missing format identifier #EXTM3U"),
            c;
        for (; (T = Pl.exec(e)) !== null; ) {
            A && (A = !1,
            E = new Cl(r,l),
            E.playlistOffset = p,
            E.setStart(p),
            E.sn = f,
            E.cc = x,
            y && (E.bitrate = y),
            E.level = n,
            h && (E.initSegment = h,
            h.rawProgramDateTime && (E.rawProgramDateTime = h.rawProgramDateTime,
            h.rawProgramDateTime = null),
            C && (E.setByteRange(C),
            C = null)));
            const K = T[1];
            if (K) {
                E.duration = parseFloat(K);
                const W = (" " + T[2]).slice(1);
                E.title = W || null,
                E.tagList.push(W ? ["INF", K, W] : ["INF", K])
            } else if (T[3]) {
                if (z(E.duration)) {
                    E.playlistOffset = p,
                    E.setStart(p),
                    R && Df(E, R, c),
                    E.sn = f,
                    E.level = n,
                    E.cc = x,
                    u.push(E);
                    const W = (" " + T[3]).slice(1);
                    E.relurl = Qc(c, W),
                    eu(E, v, d),
                    v = E,
                    p += E.duration,
                    f++,
                    m = 0,
                    A = !0
                }
            } else {
                if (T = T[0].match(l1),
                !T) {
                    fe.warn("No matches on slow regex match for level playlist!");
                    continue
                }
                for (L = 1; L < T.length && T[L] === void 0; L++)
                    ;
                const W = (" " + T[L]).slice(1)
                  , G = (" " + T[L + 1]).slice(1)
                  , V = T[L + 2] ? (" " + T[L + 2]).slice(1) : null;
                switch (W) {
                case "BYTERANGE":
                    v ? E.setByteRange(G, v) : E.setByteRange(G);
                    break;
                case "PROGRAM-DATE-TIME":
                    E.rawProgramDateTime = G,
                    E.tagList.push(["PROGRAM-DATE-TIME", G]),
                    I === -1 && (I = u.length);
                    break;
                case "PLAYLIST-TYPE":
                    c.type && Es(c, W, T),
                    c.type = G.toUpperCase();
                    break;
                case "MEDIA-SEQUENCE":
                    c.startSN !== 0 ? Es(c, W, T) : u.length > 0 && Pf(c, W, T),
                    f = c.startSN = parseInt(G);
                    break;
                case "SKIP":
                    {
                        c.skippedSegments && Es(c, W, T);
                        const D = new Ae(G,c)
                          , B = D.decimalInteger("SKIPPED-SEGMENTS");
                        if (z(B)) {
                            c.skippedSegments += B;
                            for (let F = B; F--; )
                                u.push(null);
                            f += B
                        }
                        const k = D.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                        k && (c.recentlyRemovedDateranges = (c.recentlyRemovedDateranges || []).concat(k.split("	")));
                        break
                    }
                case "TARGETDURATION":
                    c.targetduration !== 0 && Es(c, W, T),
                    c.targetduration = Math.max(parseInt(G), 1);
                    break;
                case "VERSION":
                    c.version !== null && Es(c, W, T),
                    c.version = parseInt(G);
                    break;
                case "INDEPENDENT-SEGMENTS":
                    break;
                case "ENDLIST":
                    c.live || Es(c, W, T),
                    c.live = !1;
                    break;
                case "#":
                    (G || V) && E.tagList.push(V ? [G, V] : [G]);
                    break;
                case "DISCONTINUITY":
                    x++,
                    E.tagList.push(["DIS"]);
                    break;
                case "GAP":
                    E.gap = !0,
                    E.tagList.push([W]);
                    break;
                case "BITRATE":
                    E.tagList.push([W, G]),
                    y = parseInt(G) * 1e3,
                    z(y) ? E.bitrate = y : y = 0;
                    break;
                case "DATERANGE":
                    {
                        const D = new Ae(G,c)
                          , B = new f0(D,c.dateRanges[D.ID],c.dateRangeTagCount);
                        c.dateRangeTagCount++,
                        B.isValid || c.skippedSegments ? c.dateRanges[B.id] = B : fe.warn(`Ignoring invalid DATERANGE tag: "${G}"`),
                        E.tagList.push(["EXT-X-DATERANGE", G]);
                        break
                    }
                case "DEFINE":
                    {
                        {
                            const D = new Ae(G,c);
                            "IMPORT"in D ? WT(c, D, a) : Tf(c, D, t)
                        }
                        break
                    }
                case "DISCONTINUITY-SEQUENCE":
                    c.startCC !== 0 ? Es(c, W, T) : u.length > 0 && Pf(c, W, T),
                    c.startCC = x = parseInt(G);
                    break;
                case "KEY":
                    {
                        const D = Rf(G, t, c);
                        if (D.isSupported()) {
                            if (D.method === "NONE") {
                                R = void 0;
                                break
                            }
                            R || (R = {});
                            const B = R[D.keyFormat];
                            B != null && B.matches(D) || (B && (R = ye({}, R)),
                            R[D.keyFormat] = D)
                        } else
                            fe.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${G}"`);
                        break
                    }
                case "START":
                    c.startTimeOffset = wf(G);
                    break;
                case "MAP":
                    {
                        const D = new Ae(G,c);
                        if (E.duration) {
                            const B = new Cl(r,l);
                            _f(B, D, n, R),
                            h = B,
                            E.initSegment = h,
                            h.rawProgramDateTime && !E.rawProgramDateTime && (E.rawProgramDateTime = h.rawProgramDateTime)
                        } else {
                            const B = E.byteRangeEndOffset;
                            if (B) {
                                const k = E.byteRangeStartOffset;
                                C = `${B - k}@${k}`
                            } else
                                C = null;
                            _f(E, D, n, R),
                            h = E,
                            A = !0
                        }
                        h.cc = x;
                        break
                    }
                case "SERVER-CONTROL":
                    {
                        b && Es(c, W, T),
                        b = new Ae(G),
                        c.canBlockReload = b.bool("CAN-BLOCK-RELOAD"),
                        c.canSkipUntil = b.optionalFloat("CAN-SKIP-UNTIL", 0),
                        c.canSkipDateRanges = c.canSkipUntil > 0 && b.bool("CAN-SKIP-DATERANGES"),
                        c.partHoldBack = b.optionalFloat("PART-HOLD-BACK", 0),
                        c.holdBack = b.optionalFloat("HOLD-BACK", 0);
                        break
                    }
                case "PART-INF":
                    {
                        c.partTarget && Es(c, W, T);
                        const D = new Ae(G);
                        c.partTarget = D.decimalFloatingPoint("PART-TARGET");
                        break
                    }
                case "PART":
                    {
                        let D = c.partList;
                        D || (D = c.partList = []);
                        const B = m > 0 ? D[D.length - 1] : void 0
                          , k = m++
                          , F = new Ae(G,c)
                          , j = new XS(F,E,l,k,B);
                        D.push(j),
                        E.duration += j.duration;
                        break
                    }
                case "PRELOAD-HINT":
                    {
                        const D = new Ae(G,c);
                        c.preloadHint = D;
                        break
                    }
                case "RENDITION-REPORT":
                    {
                        const D = new Ae(G,c);
                        c.renditionReports = c.renditionReports || [],
                        c.renditionReports.push(D);
                        break
                    }
                default:
                    fe.warn(`line parsed but not handled: ${T}`);
                    break
                }
            }
        }
        v && !v.relurl ? (u.pop(),
        p -= v.duration,
        c.partList && (c.fragmentHint = v)) : c.partList && (eu(E, v, d),
        E.cc = x,
        c.fragmentHint = E,
        R && Df(E, R, c)),
        c.targetduration || (c.playlistParsingError = new Error("#EXT-X-TARGETDURATION is required"));
        const O = u.length
          , _ = u[0]
          , $ = u[O - 1];
        if (p += c.skippedSegments * c.targetduration,
        p > 0 && O && $) {
            c.averagetargetduration = p / O;
            const K = $.sn;
            c.endSN = K !== "initSegment" ? K : 0,
            c.live || ($.endList = !0),
            I > 0 && (u1(u, I),
            _ && d.unshift(_))
        }
        return c.fragmentHint && (p += c.fragmentHint.duration),
        c.totalduration = p,
        d.length && c.dateRangeTagCount && _ && p0(d, c),
        c.endCC = x,
        c
    }
}
function p0(s, e) {
    let t = s.length;
    if (!t)
        if (e.hasProgramDateTime) {
            const o = e.fragments[e.fragments.length - 1];
            s.push(o),
            t++
        } else
            return;
    const n = s[t - 1]
      , r = e.live ? 1 / 0 : e.totalduration
      , i = Object.keys(e.dateRanges);
    for (let o = i.length; o--; ) {
        const l = e.dateRanges[i[o]]
          , c = l.startDate.getTime();
        l.tagAnchor = n.ref;
        for (let u = t; u--; ) {
            var a;
            if (((a = s[u]) == null ? void 0 : a.sn) < e.startSN)
                break;
            const d = c1(e, c, s, u, r);
            if (d !== -1) {
                l.tagAnchor = e.fragments[d].ref;
                break
            }
        }
    }
}
function c1(s, e, t, n, r) {
    const i = t[n];
    if (i) {
        const o = i.programDateTime;
        if (e >= o || n === 0) {
            var a;
            const l = (((a = t[n + 1]) == null ? void 0 : a.start) || r) - i.start;
            if (e <= o + l * 1e3) {
                const c = t[n].sn - s.startSN;
                if (c < 0)
                    return -1;
                const u = s.fragments;
                if (u.length > t.length) {
                    const h = (t[n + 1] || u[u.length - 1]).sn - s.startSN;
                    for (let f = h; f > c; f--) {
                        const m = u[f].programDateTime;
                        if (e >= m && e < m + u[f].duration * 1e3)
                            return f
                    }
                }
                return c
            }
        }
    }
    return -1
}
function Rf(s, e, t) {
    var n, r;
    const i = new Ae(s,t)
      , a = (n = i.METHOD) != null ? n : ""
      , o = i.URI
      , l = i.hexadecimalInteger("IV")
      , c = i.KEYFORMATVERSIONS
      , u = (r = i.KEYFORMAT) != null ? r : "identity";
    o && i.IV && !l && fe.error(`Invalid IV: ${i.IV}`);
    const d = o ? cs.resolve(o, e) : ""
      , h = (c || "1").split("/").map(Number).filter(Number.isFinite);
    return new Xo(a,d,u,h,l,i.KEYID)
}
function wf(s) {
    const t = new Ae(s).decimalFloatingPoint("TIME-OFFSET");
    return z(t) ? t : null
}
function Cf(s, e) {
    let t = (s || "").split(/[ ,]+/).filter(n => n);
    ["video", "audio", "text"].forEach(n => {
        const r = t.filter(i => md(i, n));
        r.length && (e[`${n}Codec`] = r.map(i => i.split("/")[0]).join(","),
        t = t.filter(i => r.indexOf(i) === -1))
    }
    ),
    e.unknownCodecs = t
}
function kf(s, e, t) {
    const n = e[t];
    n && (s[t] = n)
}
function u1(s, e) {
    let t = s[e];
    for (let n = e; n--; ) {
        const r = s[n];
        if (!r)
            return;
        r.programDateTime = t.programDateTime - r.duration * 1e3,
        t = r
    }
}
function eu(s, e, t) {
    s.rawProgramDateTime ? t.push(s) : e != null && e.programDateTime && (s.programDateTime = e.endProgramDateTime)
}
function _f(s, e, t, n) {
    s.relurl = e.URI,
    e.BYTERANGE && s.setByteRange(e.BYTERANGE),
    s.level = t,
    s.sn = "initSegment",
    n && (s.levelkeys = n),
    s.initSegment = null
}
function Df(s, e, t) {
    s.levelkeys = e;
    const {encryptedFragments: n} = t;
    (!n.length || n[n.length - 1].levelkeys !== e) && Object.keys(e).some(r => e[r].isCommonEncryption) && n.push(s)
}
function Es(s, e, t) {
    s.playlistParsingError = new Error(`#EXT-X-${e} must not appear more than once (${t[0]})`)
}
function Pf(s, e, t) {
    s.playlistParsingError = new Error(`#EXT-X-${e} must appear before the first Media Segment (${t[0]})`)
}
function Nl(s, e) {
    const t = e.startPTS;
    if (z(t)) {
        let n = 0, r;
        e.sn > s.sn ? (n = t - s.start,
        r = s) : (n = s.start - t,
        r = e),
        r.duration !== n && r.setDuration(n)
    } else
        e.sn > s.sn ? s.cc === e.cc && s.minEndPTS ? e.setStart(s.start + (s.minEndPTS - s.start)) : e.setStart(s.start + s.duration) : e.setStart(Math.max(s.start - e.duration, 0))
}
function y0(s, e, t, n, r, i, a) {
    n - t <= 0 && (a.warn("Fragment should have a positive duration", e),
    n = t + e.duration,
    i = r + e.duration);
    let l = t
      , c = n;
    const u = e.startPTS
      , d = e.endPTS;
    if (z(u)) {
        const y = Math.abs(u - t);
        s && y > s.totalduration ? a.warn(`media timestamps and playlist times differ by ${y}s for level ${e.level} ${s.url}`) : z(e.deltaPTS) ? e.deltaPTS = Math.max(y, e.deltaPTS) : e.deltaPTS = y,
        l = Math.max(t, u),
        t = Math.min(t, u),
        r = e.startDTS !== void 0 ? Math.min(r, e.startDTS) : r,
        c = Math.min(n, d),
        n = Math.max(n, d),
        i = e.endDTS !== void 0 ? Math.max(i, e.endDTS) : i
    }
    const h = t - e.start;
    e.start !== 0 && e.setStart(t),
    e.setDuration(n - e.start),
    e.startPTS = t,
    e.maxStartPTS = l,
    e.startDTS = r,
    e.endPTS = n,
    e.minEndPTS = c,
    e.endDTS = i;
    const f = e.sn;
    if (!s || f < s.startSN || f > s.endSN)
        return 0;
    let m;
    const p = f - s.startSN
      , x = s.fragments;
    for (x[p] = e,
    m = p; m > 0; m--)
        Nl(x[m], x[m - 1]);
    for (m = p; m < x.length - 1; m++)
        Nl(x[m], x[m + 1]);
    return s.fragmentHint && Nl(x[x.length - 1], s.fragmentHint),
    s.PTSKnown = s.alignedSliding = !0,
    h
}
function d1(s, e, t) {
    if (s === e)
        return;
    let n = null;
    const r = s.fragments;
    for (let u = r.length - 1; u >= 0; u--) {
        const d = r[u].initSegment;
        if (d) {
            n = d;
            break
        }
    }
    s.fragmentHint && delete s.fragmentHint.endPTS;
    let i;
    m1(s, e, (u, d, h, f) => {
        if ((!e.startCC || e.skippedSegments) && d.cc !== u.cc) {
            const m = u.cc - d.cc;
            for (let p = h; p < f.length; p++)
                f[p].cc += m;
            e.endCC = f[f.length - 1].cc
        }
        z(u.startPTS) && z(u.endPTS) && (d.setStart(d.startPTS = u.startPTS),
        d.startDTS = u.startDTS,
        d.maxStartPTS = u.maxStartPTS,
        d.endPTS = u.endPTS,
        d.endDTS = u.endDTS,
        d.minEndPTS = u.minEndPTS,
        d.setDuration(u.endPTS - u.startPTS),
        d.duration && (i = d),
        e.PTSKnown = e.alignedSliding = !0),
        u.hasStreams && (d.elementaryStreams = u.elementaryStreams),
        d.loader = u.loader,
        u.hasStats && (d.stats = u.stats),
        u.initSegment && (d.initSegment = u.initSegment,
        n = u.initSegment)
    }
    );
    const a = e.fragments
      , o = e.fragmentHint ? a.concat(e.fragmentHint) : a;
    if (n && o.forEach(u => {
        var d;
        u && (!u.initSegment || u.initSegment.relurl === ((d = n) == null ? void 0 : d.relurl)) && (u.initSegment = n)
    }
    ),
    e.skippedSegments) {
        if (e.deltaUpdateFailed = a.some(u => !u),
        e.deltaUpdateFailed) {
            t.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
            for (let u = e.skippedSegments; u--; )
                a.shift();
            e.startSN = a[0].sn
        } else {
            e.canSkipDateRanges && (e.dateRanges = h1(s.dateRanges, e, t));
            const u = s.fragments.filter(d => d.rawProgramDateTime);
            if (s.hasProgramDateTime && !e.hasProgramDateTime)
                for (let d = 1; d < o.length; d++)
                    o[d].programDateTime === null && eu(o[d], o[d - 1], u);
            p0(u, e)
        }
        e.endCC = a[a.length - 1].cc
    }
    if (!e.startCC) {
        var l;
        const u = E0(s, e.startSN - 1);
        e.startCC = (l = u == null ? void 0 : u.cc) != null ? l : a[0].cc
    }
    f1(s.partList, e.partList, (u, d) => {
        d.elementaryStreams = u.elementaryStreams,
        d.stats = u.stats
    }
    ),
    i ? y0(e, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS, t) : x0(s, e),
    a.length && (e.totalduration = e.edge - a[0].start),
    e.driftStartTime = s.driftStartTime,
    e.driftStart = s.driftStart;
    const c = e.advancedDateTime;
    if (e.advanced && c) {
        const u = e.edge;
        e.driftStart || (e.driftStartTime = c,
        e.driftStart = u),
        e.driftEndTime = c,
        e.driftEnd = u
    } else
        e.driftEndTime = s.driftEndTime,
        e.driftEnd = s.driftEnd,
        e.advancedDateTime = s.advancedDateTime;
    e.requestScheduled === -1 && (e.requestScheduled = s.requestScheduled)
}
function h1(s, e, t) {
    const {dateRanges: n, recentlyRemovedDateranges: r} = e
      , i = ye({}, s);
    r && r.forEach(l => {
        delete i[l]
    }
    );
    const o = Object.keys(i).length;
    return o ? (Object.keys(n).forEach(l => {
        const c = i[l]
          , u = new f0(n[l].attr,c);
        u.isValid ? (i[l] = u,
        c || (u.tagOrder += o)) : t.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${Te(n[l].attr)}"`)
    }
    ),
    i) : n
}
function f1(s, e, t) {
    if (s && e) {
        let n = 0;
        for (let r = 0, i = s.length; r <= i; r++) {
            const a = s[r]
              , o = e[r + n];
            a && o && a.index === o.index && a.fragment.sn === o.fragment.sn ? t(a, o) : n--
        }
    }
}
function m1(s, e, t) {
    const n = e.skippedSegments
      , r = Math.max(s.startSN, e.startSN) - e.startSN
      , i = (s.fragmentHint ? 1 : 0) + (n ? e.endSN : Math.min(s.endSN, e.endSN)) - e.startSN
      , a = e.startSN - s.startSN
      , o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments
      , l = s.fragmentHint ? s.fragments.concat(s.fragmentHint) : s.fragments;
    for (let c = r; c <= i; c++) {
        const u = l[a + c];
        let d = o[c];
        if (n && !d && u && (d = e.fragments[c] = u),
        u && d) {
            t(u, d, c, o);
            const h = u.relurl
              , f = d.relurl;
            if (h && g1(h, f)) {
                e.playlistParsingError = Nf(`media sequence mismatch ${d.sn}:`, s, e, u, d);
                return
            } else if (u.cc !== d.cc) {
                e.playlistParsingError = Nf(`discontinuity sequence mismatch (${u.cc}!=${d.cc})`, s, e, u, d);
                return
            }
        }
    }
}
function Nf(s, e, t, n, r) {
    return new Error(`${s} ${r.url}
Playlist starting @${e.startSN}
${e.m3u8}

Playlist starting @${t.startSN}
${t.m3u8}`)
}
function x0(s, e, t=!0) {
    const n = e.startSN + e.skippedSegments - s.startSN
      , r = s.fragments
      , i = n >= 0;
    let a = 0;
    if (i && n < r.length)
        a = r[n].start;
    else if (i && e.startSN === s.endSN + 1)
        a = s.fragmentEnd;
    else if (i && t)
        a = s.fragmentStart + n * e.levelTargetDuration;
    else if (!e.skippedSegments && e.fragmentStart === 0)
        a = s.fragmentStart;
    else
        return;
    tu(e, a)
}
function tu(s, e) {
    if (e) {
        const t = s.fragments;
        for (let n = s.skippedSegments; n < t.length; n++)
            t[n].addStart(e);
        s.fragmentHint && s.fragmentHint.addStart(e)
    }
}
function v0(s, e=1 / 0) {
    let t = 1e3 * s.targetduration;
    if (s.updated) {
        const n = s.fragments;
        if (n.length && t * 4 > e) {
            const i = n[n.length - 1].duration * 1e3;
            i < t && (t = i)
        }
    } else
        t /= 2;
    return Math.round(t)
}
function E0(s, e, t) {
    if (!s)
        return null;
    let n = s.fragments[e - s.startSN];
    return n || (n = s.fragmentHint,
    n && n.sn === e) ? n : e < s.startSN && t && t.sn === e ? t : null
}
function Of(s, e, t) {
    return s ? S0(s.partList, e, t) : null
}
function S0(s, e, t) {
    if (s)
        for (let n = s.length; n--; ) {
            const r = s[n];
            if (r.index === t && r.fragment.sn === e)
                return r
        }
    return null
}
function T0(s) {
    s.forEach( (e, t) => {
        var n;
        (n = e.details) == null || n.fragments.forEach(r => {
            r.level = t,
            r.initSegment && (r.initSegment.level = t)
        }
        )
    }
    )
}
function g1(s, e) {
    return s !== e && e ? Mf(s) !== Mf(e) : !1
}
function Mf(s) {
    return s.replace(/\?[^?]*$/, "")
}
function ni(s, e) {
    for (let n = 0, r = s.length; n < r; n++) {
        var t;
        if (((t = s[n]) == null ? void 0 : t.cc) === e)
            return s[n]
    }
    return null
}
function p1(s, e) {
    return !!(s && e.startCC < s.endCC && e.endCC > s.startCC)
}
function Ff(s, e) {
    const t = s.start + e;
    s.startPTS = t,
    s.setStart(t),
    s.endPTS = t + s.duration
}
function L0(s, e) {
    const t = e.fragments;
    for (let n = 0, r = t.length; n < r; n++)
        Ff(t[n], s);
    e.fragmentHint && Ff(e.fragmentHint, s),
    e.alignedSliding = !0
}
function y1(s, e) {
    s && (I0(e, s),
    e.alignedSliding || bo(e, s),
    !e.alignedSliding && !e.skippedSegments && x0(s, e, !1))
}
function I0(s, e) {
    if (!p1(e, s))
        return;
    const t = Math.min(e.endCC, s.endCC)
      , n = ni(e.fragments, t)
      , r = ni(s.fragments, t);
    if (!n || !r)
        return;
    fe.log(`Aligning playlist at start of dicontinuity sequence ${t}`);
    const i = n.start - r.start;
    L0(i, s)
}
function bo(s, e) {
    if (!s.hasProgramDateTime || !e.hasProgramDateTime)
        return;
    const t = s.fragments
      , n = e.fragments;
    if (!t.length || !n.length)
        return;
    let r, i;
    const a = Math.min(e.endCC, s.endCC);
    e.startCC < a && s.startCC < a && (r = ni(n, a),
    i = ni(t, a)),
    (!r || !i) && (r = n[Math.floor(n.length / 2)],
    i = ni(t, r.cc) || t[Math.floor(t.length / 2)]);
    const o = r.programDateTime
      , l = i.programDateTime;
    if (!o || !l)
        return;
    const c = (l - o) / 1e3 - (i.start - r.start);
    L0(c, s)
}
function lt(s, e, t) {
    yt(s, e, t),
    s.addEventListener(e, t)
}
function yt(s, e, t) {
    s.removeEventListener(e, t)
}
const x1 = {
    toString: function(s) {
        let e = "";
        const t = s.length;
        for (let n = 0; n < t; n++)
            e += `[${s.start(n).toFixed(3)}-${s.end(n).toFixed(3)}]`;
        return e
    }
}
  , U = {
    STOPPED: "STOPPED",
    IDLE: "IDLE",
    KEY_LOADING: "KEY_LOADING",
    FRAG_LOADING: "FRAG_LOADING",
    FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
    WAITING_TRACK: "WAITING_TRACK",
    PARSING: "PARSING",
    PARSED: "PARSED",
    ENDED: "ENDED",
    ERROR: "ERROR",
    WAITING_INIT_PTS: "WAITING_INIT_PTS",
    WAITING_LEVEL: "WAITING_LEVEL"
};
class Sd extends d0 {
    constructor(e, t, n, r, i) {
        super(r, e.logger),
        this.hls = void 0,
        this.fragPrevious = null,
        this.fragCurrent = null,
        this.fragmentTracker = void 0,
        this.transmuxer = null,
        this._state = U.STOPPED,
        this.playlistType = void 0,
        this.media = null,
        this.mediaBuffer = null,
        this.config = void 0,
        this.bitrateTest = !1,
        this.lastCurrentTime = 0,
        this.nextLoadPosition = 0,
        this.startPosition = 0,
        this.startTimeOffset = null,
        this.retryDate = 0,
        this.levels = null,
        this.fragmentLoader = void 0,
        this.keyLoader = void 0,
        this.levelLastLoaded = null,
        this.startFragRequested = !1,
        this.decrypter = void 0,
        this.initPTS = [],
        this.buffering = !0,
        this.loadingParts = !1,
        this.loopSn = void 0,
        this.onMediaSeeking = () => {
            const {config: a, fragCurrent: o, media: l, mediaBuffer: c, state: u} = this
              , d = l ? l.currentTime : 0
              , h = ie.bufferInfo(c || l, d, a.maxBufferHole)
              , f = !h.len;
            if (this.log(`Media seeking to ${z(d) ? d.toFixed(3) : d}, state: ${u}, ${f ? "out of" : "in"} buffer`),
            this.state === U.ENDED)
                this.resetLoadingState();
            else if (o) {
                const m = a.maxFragLookUpTolerance
                  , p = o.start - m
                  , x = o.start + o.duration + m;
                if (f || x < h.start || p > h.end) {
                    const y = d > x;
                    (d < p || y) && (y && o.loader && (this.log(`Cancelling fragment load for seek (sn: ${o.sn})`),
                    o.abortRequests(),
                    this.resetLoadingState()),
                    this.fragPrevious = null)
                }
            }
            if (l) {
                this.fragmentTracker.removeFragmentsInRange(d, 1 / 0, this.playlistType, !0);
                const m = this.lastCurrentTime;
                if (d > m && (this.lastCurrentTime = d),
                !this.loadingParts) {
                    const p = Math.max(h.end, d)
                      , x = this.shouldLoadParts(this.getLevelDetails(), p);
                    x && (this.log(`LL-Part loading ON after seeking to ${d.toFixed(2)} with buffer @${p.toFixed(2)}`),
                    this.loadingParts = x)
                }
            }
            this.hls.hasEnoughToStart || (this.log(`Setting ${f ? "startPosition" : "nextLoadPosition"} to ${d} for seek without enough to start`),
            this.nextLoadPosition = d,
            f && (this.startPosition = d)),
            f && this.state === U.IDLE && this.tickImmediate()
        }
        ,
        this.onMediaEnded = () => {
            this.log("setting startPosition to 0 because media ended"),
            this.startPosition = this.lastCurrentTime = 0
        }
        ,
        this.playlistType = i,
        this.hls = e,
        this.fragmentLoader = new HT(e.config),
        this.keyLoader = n,
        this.fragmentTracker = t,
        this.config = e.config,
        this.decrypter = new yd(e.config)
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(S.ERROR, this.onError, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(S.ERROR, this.onError, this)
    }
    doTick() {
        this.onTickEnd()
    }
    onTickEnd() {}
    startLoad(e) {}
    stopLoad() {
        if (this.state === U.STOPPED)
            return;
        this.fragmentLoader.abort(),
        this.keyLoader.abort(this.playlistType);
        const e = this.fragCurrent;
        e != null && e.loader && (e.abortRequests(),
        this.fragmentTracker.removeFragment(e)),
        this.resetTransmuxer(),
        this.fragCurrent = null,
        this.fragPrevious = null,
        this.clearInterval(),
        this.clearNextTick(),
        this.state = U.STOPPED
    }
    get startPositionValue() {
        const {nextLoadPosition: e, startPosition: t} = this;
        return t === -1 && e ? e : t
    }
    get bufferingEnabled() {
        return this.buffering
    }
    pauseBuffering() {
        this.buffering = !1
    }
    resumeBuffering() {
        this.buffering = !0
    }
    get inFlightFrag() {
        return {
            frag: this.fragCurrent,
            state: this.state
        }
    }
    _streamEnded(e, t) {
        if (t.live || !this.media)
            return !1;
        const n = e.end || 0
          , r = this.config.timelineOffset || 0;
        if (n <= r)
            return !1;
        const i = e.buffered;
        this.config.maxBufferHole && i && i.length > 1 && (e = ie.bufferedInfo(i, e.start, 0));
        const a = e.nextStart;
        if (a && a > r && a < t.edge || this.media.currentTime < e.start)
            return !1;
        const l = t.partList;
        if (l != null && l.length) {
            const u = l[l.length - 1];
            return ie.isBuffered(this.media, u.start + u.duration / 2)
        }
        const c = t.fragments[t.fragments.length - 1].type;
        return this.fragmentTracker.isEndListAppended(c)
    }
    getLevelDetails() {
        if (this.levels && this.levelLastLoaded !== null)
            return this.levelLastLoaded.details
    }
    get timelineOffset() {
        const e = this.config.timelineOffset;
        if (e) {
            var t;
            return ((t = this.getLevelDetails()) == null ? void 0 : t.appliedTimelineOffset) || e
        }
        return 0
    }
    onMediaAttached(e, t) {
        const n = this.media = this.mediaBuffer = t.media;
        lt(n, "seeking", this.onMediaSeeking),
        lt(n, "ended", this.onMediaEnded);
        const r = this.config;
        this.levels && r.autoStartLoad && this.state === U.STOPPED && this.startLoad(r.startPosition)
    }
    onMediaDetaching(e, t) {
        const n = !!t.transferMedia
          , r = this.media;
        if (r !== null) {
            if (r.ended && (this.log("MSE detaching and video ended, reset startPosition"),
            this.startPosition = this.lastCurrentTime = 0),
            yt(r, "seeking", this.onMediaSeeking),
            yt(r, "ended", this.onMediaEnded),
            this.keyLoader && !n && this.keyLoader.detach(),
            this.media = this.mediaBuffer = null,
            this.loopSn = void 0,
            n) {
                this.resetLoadingState(),
                this.resetTransmuxer();
                return
            }
            this.loadingParts = !1,
            this.fragmentTracker.removeAllFragments(),
            this.stopLoad()
        }
    }
    onManifestLoading() {
        this.initPTS = [],
        this.levels = this.levelLastLoaded = this.fragCurrent = null,
        this.lastCurrentTime = this.startPosition = 0,
        this.startFragRequested = !1
    }
    onError(e, t) {}
    onManifestLoaded(e, t) {
        this.startTimeOffset = t.startTimeOffset
    }
    onHandlerDestroying() {
        this.stopLoad(),
        this.transmuxer && (this.transmuxer.destroy(),
        this.transmuxer = null),
        super.onHandlerDestroying(),
        this.hls = this.onMediaSeeking = this.onMediaEnded = null
    }
    onHandlerDestroyed() {
        this.state = U.STOPPED,
        this.fragmentLoader && this.fragmentLoader.destroy(),
        this.keyLoader && this.keyLoader.destroy(),
        this.decrypter && this.decrypter.destroy(),
        this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null,
        super.onHandlerDestroyed()
    }
    loadFragment(e, t, n) {
        this.startFragRequested = !0,
        this._loadFragForPlayback(e, t, n)
    }
    _loadFragForPlayback(e, t, n) {
        const r = i => {
            const a = i.frag;
            if (this.fragContextChanged(a)) {
                this.warn(`${a.type} sn: ${a.sn}${i.part ? " part: " + i.part.index : ""} of ${this.fragInfo(a, !1, i.part)}) was dropped during download.`),
                this.fragmentTracker.removeFragment(a);
                return
            }
            a.stats.chunkCount++,
            this._handleFragmentLoadProgress(i)
        }
        ;
        this._doFragLoad(e, t, n, r).then(i => {
            if (!i)
                return;
            const a = this.state
              , o = i.frag;
            if (this.fragContextChanged(o)) {
                (a === U.FRAG_LOADING || !this.fragCurrent && a === U.PARSING) && (this.fragmentTracker.removeFragment(o),
                this.state = U.IDLE);
                return
            }
            "payload"in i && (this.log(`Loaded ${o.type} sn: ${o.sn} of ${this.playlistLabel()} ${o.level}`),
            this.hls.trigger(S.FRAG_LOADED, i)),
            this._handleFragmentLoadComplete(i)
        }
        ).catch(i => {
            this.state === U.STOPPED || this.state === U.ERROR || (this.warn(`Frag error: ${(i == null ? void 0 : i.message) || i}`),
            this.resetFragmentLoading(e))
        }
        )
    }
    clearTrackerIfNeeded(e) {
        var t;
        const {fragmentTracker: n} = this;
        if (n.getState(e) === Ve.APPENDING) {
            const i = e.type
              , a = this.getFwdBufferInfo(this.mediaBuffer, i)
              , o = Math.max(e.duration, a ? a.len : this.config.maxBufferLength)
              , l = this.backtrackFragment;
            ((l ? e.sn - l.sn : 0) === 1 || this.reduceMaxBufferLength(o, e.duration)) && n.removeFragment(e)
        } else
            ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0 ? n.removeAllFragments() : n.hasParts(e.type) && (n.detectPartialFragments({
                frag: e,
                part: null,
                stats: e.stats,
                id: e.type
            }),
            n.getState(e) === Ve.PARTIAL && n.removeFragment(e))
    }
    checkLiveUpdate(e) {
        if (e.updated && !e.live) {
            const t = e.fragments[e.fragments.length - 1];
            this.fragmentTracker.detectPartialFragments({
                frag: t,
                part: null,
                stats: t.stats,
                id: t.type
            })
        }
        e.fragments[0] || (e.deltaUpdateFailed = !0)
    }
    waitForLive(e) {
        const t = e.details;
        return (t == null ? void 0 : t.live) && t.type !== "EVENT" && (this.levelLastLoaded !== e || t.expired)
    }
    flushMainBuffer(e, t, n=null) {
        if (!(e - t))
            return;
        const r = {
            startOffset: e,
            endOffset: t,
            type: n
        };
        this.hls.trigger(S.BUFFER_FLUSHING, r)
    }
    _loadInitSegment(e, t) {
        this._doFragLoad(e, t).then(n => {
            const r = n == null ? void 0 : n.frag;
            if (!r || this.fragContextChanged(r) || !this.levels)
                throw new Error("init load aborted");
            return n
        }
        ).then(n => {
            const {hls: r} = this
              , {frag: i, payload: a} = n
              , o = i.decryptdata;
            if (a && a.byteLength > 0 && o != null && o.key && o.iv && fr(o.method)) {
                const l = self.performance.now();
                return this.decrypter.decrypt(new Uint8Array(a), o.key.buffer, o.iv.buffer, vd(o.method)).catch(c => {
                    throw r.trigger(S.ERROR, {
                        type: q.MEDIA_ERROR,
                        details: N.FRAG_DECRYPT_ERROR,
                        fatal: !1,
                        error: c,
                        reason: c.message,
                        frag: i
                    }),
                    c
                }
                ).then(c => {
                    const u = self.performance.now();
                    return r.trigger(S.FRAG_DECRYPTED, {
                        frag: i,
                        payload: c,
                        stats: {
                            tstart: l,
                            tdecrypt: u
                        }
                    }),
                    n.payload = c,
                    this.completeInitSegmentLoad(n)
                }
                )
            }
            return this.completeInitSegmentLoad(n)
        }
        ).catch(n => {
            this.state === U.STOPPED || this.state === U.ERROR || (this.warn(n),
            this.resetFragmentLoading(e))
        }
        )
    }
    completeInitSegmentLoad(e) {
        const {levels: t} = this;
        if (!t)
            throw new Error("init load aborted, missing levels");
        const n = e.frag.stats;
        this.state !== U.STOPPED && (this.state = U.IDLE),
        e.frag.data = new Uint8Array(e.payload),
        n.parsing.start = n.buffering.start = self.performance.now(),
        n.parsing.end = n.buffering.end = self.performance.now(),
        this.tick()
    }
    unhandledEncryptionError(e, t) {
        var n, r;
        const i = e.tracks;
        if (i && !t.encrypted && ((n = i.audio) != null && n.encrypted || (r = i.video) != null && r.encrypted) && (!this.config.emeEnabled || !this.keyLoader.emeController)) {
            const a = this.media
              , o = new Error(`Encrypted track with no key in ${this.fragInfo(t)} (media ${a ? "attached mediaKeys: " + a.mediaKeys : "detached"})`);
            return this.warn(o.message),
            !a || a.mediaKeys ? !1 : (this.hls.trigger(S.ERROR, {
                type: q.KEY_SYSTEM_ERROR,
                details: N.KEY_SYSTEM_NO_KEYS,
                fatal: !1,
                error: o,
                frag: t
            }),
            this.resetTransmuxer(),
            !0)
        }
        return !1
    }
    fragContextChanged(e) {
        const {fragCurrent: t} = this;
        return !e || !t || e.sn !== t.sn || e.level !== t.level
    }
    fragBufferedComplete(e, t) {
        const n = this.mediaBuffer ? this.mediaBuffer : this.media;
        if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.fragInfo(e, !1, t)} > buffer:${n ? x1.toString(ie.getBuffered(n)) : "(detached)"})`),
        Fe(e)) {
            var r;
            if (e.type !== X.SUBTITLE) {
                const a = e.elementaryStreams;
                if (!Object.keys(a).some(o => !!a[o])) {
                    this.state = U.IDLE;
                    return
                }
            }
            const i = (r = this.levels) == null ? void 0 : r[e.level];
            i != null && i.fragmentError && (this.log(`Resetting level fragment error count of ${i.fragmentError} on frag buffered`),
            i.fragmentError = 0)
        }
        this.state = U.IDLE
    }
    _handleFragmentLoadComplete(e) {
        const {transmuxer: t} = this;
        if (!t)
            return;
        const {frag: n, part: r, partsLoaded: i} = e
          , a = !i || i.length === 0 || i.some(l => !l)
          , o = new xd(n.level,n.sn,n.stats.chunkCount + 1,0,r ? r.index : -1,!a);
        t.flush(o)
    }
    _handleFragmentLoadProgress(e) {}
    _doFragLoad(e, t, n=null, r) {
        var i;
        this.fragCurrent = e;
        const a = t.details;
        if (!this.levels || !a)
            throw new Error(`frag load aborted, missing level${a ? "" : " detail"}s`);
        let o = null;
        if (e.encrypted && !((i = e.decryptdata) != null && i.key)) {
            if (this.log(`Loading key for ${e.sn} of [${a.startSN}-${a.endSN}], ${this.playlistLabel()} ${e.level}`),
            this.state = U.KEY_LOADING,
            this.fragCurrent = e,
            o = this.keyLoader.load(e).then(h => {
                if (!this.fragContextChanged(h.frag))
                    return this.hls.trigger(S.KEY_LOADED, h),
                    this.state === U.KEY_LOADING && (this.state = U.IDLE),
                    h
            }
            ),
            this.hls.trigger(S.KEY_LOADING, {
                frag: e
            }),
            this.fragCurrent === null)
                return this.log("context changed in KEY_LOADING"),
                Promise.resolve(null)
        } else
            e.encrypted || (o = this.keyLoader.loadClear(e, a.encryptedFragments, this.startFragRequested),
            o && this.log("[eme] blocking frag load until media-keys acquired"));
        const l = this.fragPrevious;
        if (Fe(e) && (!l || e.sn !== l.sn)) {
            const h = this.shouldLoadParts(t.details, e.end);
            h !== this.loadingParts && (this.log(`LL-Part loading ${h ? "ON" : "OFF"} loading sn ${l == null ? void 0 : l.sn}->${e.sn}`),
            this.loadingParts = h)
        }
        if (n = Math.max(e.start, n || 0),
        this.loadingParts && Fe(e)) {
            const h = a.partList;
            if (h && r) {
                n > a.fragmentEnd && a.fragmentHint && (e = a.fragmentHint);
                const f = this.getNextPart(h, e, n);
                if (f > -1) {
                    const m = h[f];
                    e = this.fragCurrent = m.fragment,
                    this.log(`Loading ${e.type} sn: ${e.sn} part: ${m.index} (${f}/${h.length - 1}) of ${this.fragInfo(e, !1, m)}) cc: ${e.cc} [${a.startSN}-${a.endSN}], target: ${parseFloat(n.toFixed(3))}`),
                    this.nextLoadPosition = m.start + m.duration,
                    this.state = U.FRAG_LOADING;
                    let p;
                    return o ? p = o.then(x => !x || this.fragContextChanged(x.frag) ? null : this.doFragPartsLoad(e, m, t, r)).catch(x => this.handleFragLoadError(x)) : p = this.doFragPartsLoad(e, m, t, r).catch(x => this.handleFragLoadError(x)),
                    this.hls.trigger(S.FRAG_LOADING, {
                        frag: e,
                        part: m,
                        targetBufferTime: n
                    }),
                    this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts")) : p
                } else if (!e.url || this.loadedEndOfParts(h, n))
                    return Promise.resolve(null)
            }
        }
        if (Fe(e) && this.loadingParts) {
            var c;
            this.log(`LL-Part loading OFF after next part miss @${n.toFixed(2)} Check buffer at sn: ${e.sn} loaded parts: ${(c = a.partList) == null ? void 0 : c.filter(h => h.loaded).map(h => `[${h.start}-${h.end}]`)}`),
            this.loadingParts = !1
        } else if (!e.url)
            return Promise.resolve(null);
        this.log(`Loading ${e.type} sn: ${e.sn} of ${this.fragInfo(e, !1)}) cc: ${e.cc} ${"[" + a.startSN + "-" + a.endSN + "]"}, target: ${parseFloat(n.toFixed(3))}`),
        z(e.sn) && !this.bitrateTest && (this.nextLoadPosition = e.start + e.duration),
        this.state = U.FRAG_LOADING;
        const u = this.config.progressive;
        let d;
        return u && o ? d = o.then(h => !h || this.fragContextChanged(h.frag) ? null : this.fragmentLoader.load(e, r)).catch(h => this.handleFragLoadError(h)) : d = Promise.all([this.fragmentLoader.load(e, u ? r : void 0), o]).then( ([h]) => (!u && r && r(h),
        h)).catch(h => this.handleFragLoadError(h)),
        this.hls.trigger(S.FRAG_LOADING, {
            frag: e,
            targetBufferTime: n
        }),
        this.fragCurrent === null ? Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING")) : d
    }
    doFragPartsLoad(e, t, n, r) {
        return new Promise( (i, a) => {
            var o;
            const l = []
              , c = (o = n.details) == null ? void 0 : o.partList
              , u = d => {
                this.fragmentLoader.loadPart(e, d, r).then(h => {
                    l[d.index] = h;
                    const f = h.part;
                    this.hls.trigger(S.FRAG_LOADED, h);
                    const m = Of(n.details, e.sn, d.index + 1) || S0(c, e.sn, d.index + 1);
                    if (m)
                        u(m);
                    else
                        return i({
                            frag: e,
                            part: f,
                            partsLoaded: l
                        })
                }
                ).catch(a)
            }
            ;
            u(t)
        }
        )
    }
    handleFragLoadError(e) {
        if ("data"in e) {
            const t = e.data;
            t.frag && t.details === N.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : t.frag && t.type === q.KEY_SYSTEM_ERROR ? (t.frag.abortRequests(),
            this.resetFragmentLoading(t.frag)) : this.hls.trigger(S.ERROR, t)
        } else
            this.hls.trigger(S.ERROR, {
                type: q.OTHER_ERROR,
                details: N.INTERNAL_EXCEPTION,
                err: e,
                error: e,
                fatal: !0
            });
        return null
    }
    _handleTransmuxerFlush(e) {
        const t = this.getCurrentContext(e);
        if (!t || this.state !== U.PARSING) {
            !this.fragCurrent && this.state !== U.STOPPED && this.state !== U.ERROR && (this.state = U.IDLE);
            return
        }
        const {frag: n, part: r, level: i} = t
          , a = self.performance.now();
        n.stats.parsing.end = a,
        r && (r.stats.parsing.end = a);
        const o = this.getLevelDetails()
          , c = o && n.sn > o.endSN || this.shouldLoadParts(o, n.end);
        c !== this.loadingParts && (this.log(`LL-Part loading ${c ? "ON" : "OFF"} after parsing segment ending @${n.end.toFixed(2)}`),
        this.loadingParts = c),
        this.updateLevelTiming(n, r, i, e.partial)
    }
    shouldLoadParts(e, t) {
        if (this.config.lowLatencyMode) {
            if (!e)
                return this.loadingParts;
            if (e.partList) {
                var n;
                const i = e.partList[0];
                if (i.fragment.type === X.SUBTITLE)
                    return !1;
                const a = i.end + (((n = e.fragmentHint) == null ? void 0 : n.duration) || 0);
                if (t >= a) {
                    var r;
                    if ((this.hls.hasEnoughToStart ? ((r = this.media) == null ? void 0 : r.currentTime) || this.lastCurrentTime : this.getLoadPosition()) > i.start - i.fragment.duration)
                        return !0
                }
            }
        }
        return !1
    }
    getCurrentContext(e) {
        const {levels: t, fragCurrent: n} = this
          , {level: r, sn: i, part: a} = e;
        if (!(t != null && t[r]))
            return this.warn(`Levels object was unset while buffering fragment ${i} of ${this.playlistLabel()} ${r}. The current chunk will not be buffered.`),
            null;
        const o = t[r]
          , l = o.details
          , c = a > -1 ? Of(l, i, a) : null
          , u = c ? c.fragment : E0(l, i, n);
        return u ? (n && n !== u && (u.stats = n.stats),
        {
            frag: u,
            part: c,
            level: o
        }) : null
    }
    bufferFragmentData(e, t, n, r, i) {
        if (this.state !== U.PARSING)
            return;
        const {data1: a, data2: o} = e;
        let l = a;
        if (o && (l = jt(a, o)),
        !l.length)
            return;
        const c = this.initPTS[t.cc]
          , u = c ? -c.baseTime / c.timescale : void 0
          , d = {
            type: e.type,
            frag: t,
            part: n,
            chunkMeta: r,
            offset: u,
            parent: t.type,
            data: l
        };
        if (this.hls.trigger(S.BUFFER_APPENDING, d),
        e.dropped && e.independent && !n) {
            if (i)
                return;
            this.flushBufferGap(t)
        }
    }
    flushBufferGap(e) {
        const t = this.media;
        if (!t)
            return;
        if (!ie.isBuffered(t, t.currentTime)) {
            this.flushMainBuffer(0, e.start);
            return
        }
        const n = t.currentTime
          , r = ie.bufferInfo(t, n, 0)
          , i = e.duration
          , a = Math.min(this.config.maxFragLookUpTolerance * 2, i * .25)
          , o = Math.max(Math.min(e.start - a, r.end - a), n + a);
        e.start - o > a && this.flushMainBuffer(o, e.start)
    }
    getFwdBufferInfo(e, t) {
        var n;
        const r = this.getLoadPosition();
        if (!z(r))
            return null;
        const a = this.lastCurrentTime > r || (n = this.media) != null && n.paused ? 0 : this.config.maxBufferHole;
        return this.getFwdBufferInfoAtPos(e, r, t, a)
    }
    getFwdBufferInfoAtPos(e, t, n, r) {
        const i = ie.bufferInfo(e, t, r);
        if (i.len === 0 && i.nextStart !== void 0) {
            const a = this.fragmentTracker.getBufferedFrag(t, n);
            if (a && (i.nextStart <= a.end || a.gap)) {
                const o = Math.max(Math.min(i.nextStart, a.end) - t, r);
                return ie.bufferInfo(e, t, o)
            }
        }
        return i
    }
    getMaxBufferLength(e) {
        const {config: t} = this;
        let n;
        return e ? n = Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : n = t.maxBufferLength,
        Math.min(n, t.maxMaxBufferLength)
    }
    reduceMaxBufferLength(e, t) {
        const n = this.config
          , r = Math.max(Math.min(e - t, n.maxBufferLength), t)
          , i = Math.max(e - t * 3, n.maxMaxBufferLength / 2, r);
        return i >= r ? (n.maxMaxBufferLength = i,
        this.warn(`Reduce max buffer length to ${i}s`),
        !0) : !1
    }
    getAppendedFrag(e, t=X.MAIN) {
        const n = this.fragmentTracker ? this.fragmentTracker.getAppendedFrag(e, t) : null;
        return n && "fragment"in n ? n.fragment : n
    }
    getNextFragment(e, t) {
        const n = t.fragments
          , r = n.length;
        if (!r)
            return null;
        const {config: i} = this
          , a = n[0].start
          , o = i.lowLatencyMode && !!t.partList;
        let l = null;
        if (t.live) {
            const d = i.initialLiveManifestSize;
            if (r < d)
                return this.warn(`Not enough fragments to start playback (have: ${r}, need: ${d})`),
                null;
            if (!t.PTSKnown && !this.startFragRequested && this.startPosition === -1 || e < a) {
                var c;
                o && !this.loadingParts && (this.log("LL-Part loading ON for initial live fragment"),
                this.loadingParts = !0),
                l = this.getInitialLiveFragment(t);
                const h = this.hls.startPosition
                  , f = this.hls.liveSyncPosition
                  , m = l ? (h !== -1 && h >= a ? h : f) || l.start : e;
                this.log(`Setting startPosition to ${m} to match start frag at live edge. mainStart: ${h} liveSyncPosition: ${f} frag.start: ${(c = l) == null ? void 0 : c.start}`),
                this.startPosition = this.nextLoadPosition = m
            }
        } else
            e <= a && (l = n[0]);
        if (!l) {
            const d = this.loadingParts ? t.partEnd : t.fragmentEnd;
            l = this.getFragmentAtPosition(e, d, t)
        }
        let u = this.filterReplacedPrimary(l, t);
        if (!u && l) {
            const d = l.sn - t.startSN;
            u = this.filterReplacedPrimary(n[d + 1] || null, t)
        }
        return this.mapToInitFragWhenRequired(u)
    }
    isLoopLoading(e, t) {
        const n = this.fragmentTracker.getState(e);
        return (n === Ve.OK || n === Ve.PARTIAL && !!e.gap) && this.nextLoadPosition > t
    }
    getNextFragmentLoopLoading(e, t, n, r, i) {
        let a = null;
        if (e.gap && (a = this.getNextFragment(this.nextLoadPosition, t),
        a && !a.gap && n.nextStart)) {
            const o = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, n.nextStart, r, 0);
            if (o !== null && n.len + o.len >= i) {
                const l = a.sn;
                return this.loopSn !== l && (this.log(`buffer full after gaps in "${r}" playlist starting at sn: ${l}`),
                this.loopSn = l),
                null
            }
        }
        return this.loopSn = void 0,
        a
    }
    get primaryPrefetch() {
        if (Uf(this.config)) {
            var e;
            if ((e = this.hls.interstitialsManager) == null || (e = e.playingItem) == null ? void 0 : e.event)
                return !0
        }
        return !1
    }
    filterReplacedPrimary(e, t) {
        if (!e)
            return e;
        if (Uf(this.config) && e.type !== X.SUBTITLE) {
            const n = this.hls.interstitialsManager
              , r = n == null ? void 0 : n.bufferingItem;
            if (r) {
                const a = r.event;
                if (a) {
                    if (a.appendInPlace || Math.abs(e.start - r.start) > 1 || r.start === 0)
                        return null
                } else if (e.end <= r.start && (t == null ? void 0 : t.live) === !1 || e.start > r.end && r.nextEvent && (r.nextEvent.appendInPlace || e.start - r.end > 1))
                    return null
            }
            const i = n == null ? void 0 : n.playerQueue;
            if (i)
                for (let a = i.length; a--; ) {
                    const o = i[a].interstitial;
                    if (o.appendInPlace && e.start >= o.startTime && e.end <= o.resumeTime)
                        return null
                }
        }
        return e
    }
    mapToInitFragWhenRequired(e) {
        return e != null && e.initSegment && !e.initSegment.data && !this.bitrateTest ? e.initSegment : e
    }
    getNextPart(e, t, n) {
        let r = -1
          , i = !1
          , a = !0;
        for (let o = 0, l = e.length; o < l; o++) {
            const c = e[o];
            if (a = a && !c.independent,
            r > -1 && n < c.start)
                break;
            const u = c.loaded;
            u ? r = -1 : (i || (c.independent || a) && c.fragment === t) && (c.fragment !== t && this.warn(`Need buffer at ${n} but next unloaded part starts at ${c.start}`),
            r = o),
            i = u
        }
        return r
    }
    loadedEndOfParts(e, t) {
        let n;
        for (let r = e.length; r--; ) {
            if (n = e[r],
            !n.loaded)
                return !1;
            if (t > n.start)
                return !0
        }
        return !1
    }
    getInitialLiveFragment(e) {
        const t = e.fragments
          , n = this.fragPrevious;
        let r = null;
        if (n) {
            if (e.hasProgramDateTime && (this.log(`Live playlist, switching playlist, load frag with same PDT: ${n.programDateTime}`),
            r = DT(t, n.endProgramDateTime, this.config.maxFragLookUpTolerance)),
            !r) {
                const i = n.sn + 1;
                if (i >= e.startSN && i <= e.endSN) {
                    const a = t[i - e.startSN];
                    n.cc === a.cc && (r = a,
                    this.log(`Live playlist, switching playlist, load frag with next SN: ${r.sn}`))
                }
                r || (r = u0(e, n.cc, n.end),
                r && this.log(`Live playlist, switching playlist, load frag with same CC: ${r.sn}`))
            }
        } else {
            const i = this.hls.liveSyncPosition;
            i !== null && (r = this.getFragmentAtPosition(i, this.bitrateTest ? e.fragmentEnd : e.edge, e))
        }
        return r
    }
    getFragmentAtPosition(e, t, n) {
        const {config: r} = this;
        let {fragPrevious: i} = this
          , {fragments: a, endSN: o} = n;
        const {fragmentHint: l} = n
          , {maxFragLookUpTolerance: c} = r
          , u = n.partList
          , d = !!(this.loadingParts && u != null && u.length && l);
        d && !this.bitrateTest && u[u.length - 1].fragment.sn === l.sn && (a = a.concat(l),
        o = l.sn);
        let h;
        if (e < t) {
            var f;
            const p = e < this.lastCurrentTime || e > t - c || (f = this.media) != null && f.paused || !this.startFragRequested ? 0 : c;
            h = Pn(i, a, e, p)
        } else
            h = a[a.length - 1];
        if (h) {
            const m = h.sn - n.startSN
              , p = this.fragmentTracker.getState(h);
            if ((p === Ve.OK || p === Ve.PARTIAL && h.gap) && (i = h),
            i && h.sn === i.sn && (!d || u[0].fragment.sn > h.sn || !n.live) && h.level === i.level) {
                const y = a[m + 1];
                h.sn < o && this.fragmentTracker.getState(y) !== Ve.OK ? h = y : h = null
            }
        }
        return h
    }
    alignPlaylists(e, t, n) {
        const r = e.fragments.length;
        if (!r)
            return this.warn("No fragments in live playlist"),
            0;
        const i = e.fragmentStart
          , a = !t
          , o = e.alignedSliding && z(i);
        if (a || !o && !i) {
            y1(n, e);
            const l = e.fragmentStart;
            return this.log(`Live playlist sliding: ${l.toFixed(2)} start-sn: ${t ? t.startSN : "na"}->${e.startSN} fragments: ${r}`),
            l
        }
        return i
    }
    waitForCdnTuneIn(e) {
        return e.live && e.canBlockReload && e.partTarget && e.tuneInGoal > Math.max(e.partHoldBack, e.partTarget * 3)
    }
    setStartPosition(e, t) {
        let n = this.startPosition;
        n < t && (n = -1);
        const r = this.timelineOffset;
        if (n === -1) {
            const i = this.startTimeOffset !== null
              , a = i ? this.startTimeOffset : e.startTimeOffset;
            a !== null && z(a) ? (n = t + a,
            a < 0 && (n += e.edge),
            n = Math.min(Math.max(t, n), t + e.totalduration),
            this.log(`Setting startPosition to ${n} for start time offset ${a} found in ${i ? "multivariant" : "media"} playlist`),
            this.startPosition = n) : e.live ? (n = this.hls.liveSyncPosition || t,
            this.log(`Setting startPosition to -1 to start at live edge ${n}`),
            this.startPosition = -1) : (this.log("setting startPosition to 0 by default"),
            this.startPosition = n = 0),
            this.lastCurrentTime = n + r
        }
        this.nextLoadPosition = n + r
    }
    getLoadPosition() {
        var e;
        const {media: t} = this;
        let n = 0;
        return (e = this.hls) != null && e.hasEnoughToStart && t ? n = t.currentTime : this.nextLoadPosition >= 0 && (n = this.nextLoadPosition),
        n
    }
    handleFragLoadAborted(e, t) {
        this.transmuxer && e.type === this.playlistType && Fe(e) && e.stats.aborted && (this.log(`Fragment ${e.sn}${t ? " part " + t.index : ""} of ${this.playlistLabel()} ${e.level} was aborted`),
        this.resetFragmentLoading(e))
    }
    resetFragmentLoading(e) {
        (!this.fragCurrent || !this.fragContextChanged(e) && this.state !== U.FRAG_LOADING_WAITING_RETRY) && (this.state = U.IDLE)
    }
    onFragmentOrKeyLoadError(e, t) {
        var n;
        if (t.chunkMeta && !t.frag) {
            const y = this.getCurrentContext(t.chunkMeta);
            y && (t.frag = y.frag)
        }
        const r = t.frag;
        if (!r || r.type !== e || !this.levels)
            return;
        if (this.fragContextChanged(r)) {
            var i;
            this.warn(`Frag load error must match current frag to retry ${r.url} > ${(i = this.fragCurrent) == null ? void 0 : i.url}`);
            return
        }
        const a = t.details === N.FRAG_GAP;
        a && this.fragmentTracker.fragBuffered(r, !0);
        const o = t.errorAction;
        if (!o) {
            this.state = U.ERROR;
            return
        }
        const {action: l, flags: c, retryCount: u=0, retryConfig: d} = o
          , h = !!d
          , f = h && l === qe.RetryRequest
          , m = h && !o.resolved && c === Tt.MoveAllAlternatesMatchingHost
          , p = (n = this.hls.latestLevelDetails) == null ? void 0 : n.live;
        if (!f && m && Fe(r) && !r.endList && p)
            this.resetFragmentErrors(e),
            this.treatAsGap(r),
            o.resolved = !0;
        else if ((f || m) && u < d.maxNumRetry) {
            var x;
            const y = qc((x = t.response) == null ? void 0 : x.code)
              , v = pd(d, u);
            if (this.resetStartWhenNotLoaded(),
            this.retryDate = self.performance.now() + v,
            this.state = U.FRAG_LOADING_WAITING_RETRY,
            o.resolved = !0,
            y) {
                this.log("Waiting for connection (offline)"),
                this.retryDate = 1 / 0,
                t.reason = "offline";
                return
            }
            this.warn(`Fragment ${r.sn} of ${e} ${r.level} errored with ${t.details}, retrying loading ${u + 1}/${d.maxNumRetry} in ${v}ms`)
        } else if (d)
            if (this.resetFragmentErrors(e),
            u < d.maxNumRetry)
                !a && l !== qe.RemoveAlternatePermanently && (o.resolved = !0);
            else {
                this.warn(`${t.details} reached or exceeded max retry (${u})`);
                return
            }
        else
            l === qe.SendAlternateToPenaltyBox ? this.state = U.WAITING_LEVEL : this.state = U.ERROR;
        this.tickImmediate()
    }
    checkRetryDate() {
        const e = self.performance.now()
          , t = this.retryDate
          , n = t === 1 / 0;
        (!t || e >= t || n && !qc(0)) && (n && this.log("Connection restored (online)"),
        this.resetStartWhenNotLoaded(),
        this.state = U.IDLE)
    }
    reduceLengthAndFlushBuffer(e) {
        if (this.state === U.PARSING || this.state === U.PARSED) {
            const t = e.frag
              , n = e.parent
              , r = this.getFwdBufferInfo(this.mediaBuffer, n)
              , i = r && r.len > .5;
            i && this.reduceMaxBufferLength(r.len, (t == null ? void 0 : t.duration) || 10);
            const a = !i;
            return a && this.warn(`Buffer full error while media.currentTime (${this.getLoadPosition()}) is not buffered, flush ${n} buffer`),
            t && (this.fragmentTracker.removeFragment(t),
            this.nextLoadPosition = t.start),
            this.resetLoadingState(),
            a
        }
        return !1
    }
    resetFragmentErrors(e) {
        e === X.AUDIO && (this.fragCurrent = null),
        this.hls.hasEnoughToStart || (this.startFragRequested = !1),
        this.state !== U.STOPPED && (this.state = U.IDLE)
    }
    afterBufferFlushed(e, t, n) {
        if (!e)
            return;
        const r = ie.getBuffered(e);
        this.fragmentTracker.detectEvictedFragments(t, r, n),
        this.state === U.ENDED && this.resetLoadingState()
    }
    resetLoadingState() {
        this.log("Reset loading state"),
        this.fragCurrent = null,
        this.fragPrevious = null,
        this.state !== U.STOPPED && (this.state = U.IDLE)
    }
    resetStartWhenNotLoaded() {
        if (!this.hls.hasEnoughToStart) {
            this.startFragRequested = !1;
            const e = this.levelLastLoaded
              , t = e ? e.details : null;
            t != null && t.live ? (this.log("resetting startPosition for live start"),
            this.startPosition = -1,
            this.setStartPosition(t, t.fragmentStart),
            this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
        }
    }
    resetWhenMissingContext(e) {
        this.log(`Loading context changed while buffering sn ${e.sn} of ${this.playlistLabel()} ${e.level === -1 ? "<removed>" : e.level}. This chunk will not be buffered.`),
        this.removeUnbufferedFrags(),
        this.resetStartWhenNotLoaded(),
        this.resetLoadingState()
    }
    removeUnbufferedFrags(e=0) {
        this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0)
    }
    updateLevelTiming(e, t, n, r) {
        const i = n.details;
        if (!i) {
            this.warn("level.details undefined");
            return
        }
        if (!Object.keys(e.elementaryStreams).reduce( (l, c) => {
            const u = e.elementaryStreams[c];
            if (u) {
                const d = u.endPTS - u.startPTS;
                if (d <= 0)
                    return this.warn(`Could not parse fragment ${e.sn} ${c} duration reliably (${d})`),
                    l || !1;
                const h = r ? 0 : y0(i, e, u.startPTS, u.endPTS, u.startDTS, u.endDTS, this);
                return this.hls.trigger(S.LEVEL_PTS_UPDATED, {
                    details: i,
                    level: n,
                    drift: h,
                    type: c,
                    frag: e,
                    start: u.startPTS,
                    end: u.endPTS
                }),
                !0
            }
            return l
        }
        , !1)) {
            var o;
            if (n.fragmentError === 0 && this.treatAsGap(e, n),
            ((o = this.transmuxer) == null ? void 0 : o.error) === null) {
                const l = new Error(`Found no media in fragment ${e.sn} of ${this.playlistLabel()} ${e.level} resetting transmuxer to fallback to playlist timing`);
                if (this.warn(l.message),
                this.hls.trigger(S.ERROR, {
                    type: q.MEDIA_ERROR,
                    details: N.FRAG_PARSING_ERROR,
                    fatal: !1,
                    error: l,
                    frag: e,
                    reason: `Found no media in msn ${e.sn} of ${this.playlistLabel()} "${n.url}"`
                }),
                !this.hls)
                    return;
                this.resetTransmuxer()
            }
        }
        this.state = U.PARSED,
        this.log(`Parsed ${e.type} sn: ${e.sn}${t ? " part: " + t.index : ""} of ${this.fragInfo(e, !1, t)})`),
        this.hls.trigger(S.FRAG_PARSED, {
            frag: e,
            part: t
        })
    }
    playlistLabel() {
        return this.playlistType === X.MAIN ? "level" : "track"
    }
    fragInfo(e, t=!0, n) {
        var r, i;
        return `${this.playlistLabel()} ${e.level} (${n ? "part" : "frag"}:[${((r = t && !n ? e.startPTS : (n || e).start) != null ? r : NaN).toFixed(3)}-${((i = t && !n ? e.endPTS : (n || e).end) != null ? i : NaN).toFixed(3)}]${n && e.type === "main" ? "INDEPENDENT=" + (n.independent ? "YES" : "NO") : ""}`
    }
    treatAsGap(e, t) {
        t && t.fragmentError++,
        e.gap = !0,
        this.fragmentTracker.removeFragment(e),
        this.fragmentTracker.fragBuffered(e, !0)
    }
    resetTransmuxer() {
        var e;
        (e = this.transmuxer) == null || e.reset()
    }
    recoverWorkerError(e) {
        e.event === "demuxerWorker" && (this.fragmentTracker.removeAllFragments(),
        this.transmuxer && (this.transmuxer.destroy(),
        this.transmuxer = null),
        this.resetStartWhenNotLoaded(),
        this.resetLoadingState())
    }
    set state(e) {
        const t = this._state;
        t !== e && (this._state = e,
        this.log(`${t}->${e}`))
    }
    get state() {
        return this._state
    }
}
function Uf(s) {
    return !!s.interstitialsController && s.enableInterstitialPlayback !== !1
}
class A0 {
    constructor() {
        this.chunks = [],
        this.dataLength = 0
    }
    push(e) {
        this.chunks.push(e),
        this.dataLength += e.length
    }
    flush() {
        const {chunks: e, dataLength: t} = this;
        let n;
        if (e.length)
            e.length === 1 ? n = e[0] : n = v1(e, t);
        else
            return new Uint8Array(0);
        return this.reset(),
        n
    }
    reset() {
        this.chunks.length = 0,
        this.dataLength = 0
    }
}
function v1(s, e) {
    const t = new Uint8Array(e);
    let n = 0;
    for (let r = 0; r < s.length; r++) {
        const i = s[r];
        t.set(i, n),
        n += i.length
    }
    return t
}
var Ol = {
    exports: {}
}, Bf;
function E1() {
    return Bf || (Bf = 1,
    function(s) {
        var e = Object.prototype.hasOwnProperty
          , t = "~";
        function n() {}
        Object.create && (n.prototype = Object.create(null),
        new n().__proto__ || (t = !1));
        function r(l, c, u) {
            this.fn = l,
            this.context = c,
            this.once = u || !1
        }
        function i(l, c, u, d, h) {
            if (typeof u != "function")
                throw new TypeError("The listener must be a function");
            var f = new r(u,d || l,h)
              , m = t ? t + c : c;
            return l._events[m] ? l._events[m].fn ? l._events[m] = [l._events[m], f] : l._events[m].push(f) : (l._events[m] = f,
            l._eventsCount++),
            l
        }
        function a(l, c) {
            --l._eventsCount === 0 ? l._events = new n : delete l._events[c]
        }
        function o() {
            this._events = new n,
            this._eventsCount = 0
        }
        o.prototype.eventNames = function() {
            var c = [], u, d;
            if (this._eventsCount === 0)
                return c;
            for (d in u = this._events)
                e.call(u, d) && c.push(t ? d.slice(1) : d);
            return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c
        }
        ,
        o.prototype.listeners = function(c) {
            var u = t ? t + c : c
              , d = this._events[u];
            if (!d)
                return [];
            if (d.fn)
                return [d.fn];
            for (var h = 0, f = d.length, m = new Array(f); h < f; h++)
                m[h] = d[h].fn;
            return m
        }
        ,
        o.prototype.listenerCount = function(c) {
            var u = t ? t + c : c
              , d = this._events[u];
            return d ? d.fn ? 1 : d.length : 0
        }
        ,
        o.prototype.emit = function(c, u, d, h, f, m) {
            var p = t ? t + c : c;
            if (!this._events[p])
                return !1;
            var x = this._events[p], y = arguments.length, v, E;
            if (x.fn) {
                switch (x.once && this.removeListener(c, x.fn, void 0, !0),
                y) {
                case 1:
                    return x.fn.call(x.context),
                    !0;
                case 2:
                    return x.fn.call(x.context, u),
                    !0;
                case 3:
                    return x.fn.call(x.context, u, d),
                    !0;
                case 4:
                    return x.fn.call(x.context, u, d, h),
                    !0;
                case 5:
                    return x.fn.call(x.context, u, d, h, f),
                    !0;
                case 6:
                    return x.fn.call(x.context, u, d, h, f, m),
                    !0
                }
                for (E = 1,
                v = new Array(y - 1); E < y; E++)
                    v[E - 1] = arguments[E];
                x.fn.apply(x.context, v)
            } else {
                var T = x.length, L;
                for (E = 0; E < T; E++)
                    switch (x[E].once && this.removeListener(c, x[E].fn, void 0, !0),
                    y) {
                    case 1:
                        x[E].fn.call(x[E].context);
                        break;
                    case 2:
                        x[E].fn.call(x[E].context, u);
                        break;
                    case 3:
                        x[E].fn.call(x[E].context, u, d);
                        break;
                    case 4:
                        x[E].fn.call(x[E].context, u, d, h);
                        break;
                    default:
                        if (!v)
                            for (L = 1,
                            v = new Array(y - 1); L < y; L++)
                                v[L - 1] = arguments[L];
                        x[E].fn.apply(x[E].context, v)
                    }
            }
            return !0
        }
        ,
        o.prototype.on = function(c, u, d) {
            return i(this, c, u, d, !1)
        }
        ,
        o.prototype.once = function(c, u, d) {
            return i(this, c, u, d, !0)
        }
        ,
        o.prototype.removeListener = function(c, u, d, h) {
            var f = t ? t + c : c;
            if (!this._events[f])
                return this;
            if (!u)
                return a(this, f),
                this;
            var m = this._events[f];
            if (m.fn)
                m.fn === u && (!h || m.once) && (!d || m.context === d) && a(this, f);
            else {
                for (var p = 0, x = [], y = m.length; p < y; p++)
                    (m[p].fn !== u || h && !m[p].once || d && m[p].context !== d) && x.push(m[p]);
                x.length ? this._events[f] = x.length === 1 ? x[0] : x : a(this, f)
            }
            return this
        }
        ,
        o.prototype.removeAllListeners = function(c) {
            var u;
            return c ? (u = t ? t + c : c,
            this._events[u] && a(this, u)) : (this._events = new n,
            this._eventsCount = 0),
            this
        }
        ,
        o.prototype.off = o.prototype.removeListener,
        o.prototype.addListener = o.prototype.on,
        o.prefixed = t,
        o.EventEmitter = o,
        s.exports = o
    }(Ol)),
    Ol.exports
}
var S1 = E1()
  , Td = zS(S1);
const Ri = "1.6.11"
  , Ir = {};
function T1() {
    return typeof __HLS_WORKER_BUNDLE__ == "function"
}
function L1() {
    const s = Ir[Ri];
    if (s)
        return s.clientCount++,
        s;
    const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`],{
        type: "text/javascript"
    })
      , t = self.URL.createObjectURL(e)
      , r = {
        worker: new self.Worker(t),
        objectURL: t,
        clientCount: 1
    };
    return Ir[Ri] = r,
    r
}
function I1(s) {
    const e = Ir[s];
    if (e)
        return e.clientCount++,
        e;
    const t = new self.URL(s,self.location.href).href
      , r = {
        worker: new self.Worker(t),
        scriptURL: t,
        clientCount: 1
    };
    return Ir[s] = r,
    r
}
function A1(s) {
    const e = Ir[s || Ri];
    if (e && e.clientCount-- === 1) {
        const {worker: n, objectURL: r} = e;
        delete Ir[s || Ri],
        r && self.URL.revokeObjectURL(r),
        n.terminate()
    }
}
function b0(s, e) {
    return e + 10 <= s.length && s[e] === 51 && s[e + 1] === 68 && s[e + 2] === 73 && s[e + 3] < 255 && s[e + 4] < 255 && s[e + 6] < 128 && s[e + 7] < 128 && s[e + 8] < 128 && s[e + 9] < 128
}
function Ld(s, e) {
    return e + 10 <= s.length && s[e] === 73 && s[e + 1] === 68 && s[e + 2] === 51 && s[e + 3] < 255 && s[e + 4] < 255 && s[e + 6] < 128 && s[e + 7] < 128 && s[e + 8] < 128 && s[e + 9] < 128
}
function Zo(s, e) {
    let t = 0;
    return t = (s[e] & 127) << 21,
    t |= (s[e + 1] & 127) << 14,
    t |= (s[e + 2] & 127) << 7,
    t |= s[e + 3] & 127,
    t
}
function wi(s, e) {
    const t = e;
    let n = 0;
    for (; Ld(s, e); ) {
        n += 10;
        const r = Zo(s, e + 6);
        n += r,
        b0(s, e + 10) && (n += 10),
        e += n
    }
    if (n > 0)
        return s.subarray(t, t + n)
}
function b1(s, e, t, n) {
    const r = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]
      , i = e[t + 2]
      , a = i >> 2 & 15;
    if (a > 12) {
        const f = new Error(`invalid ADTS sampling index:${a}`);
        s.emit(S.ERROR, S.ERROR, {
            type: q.MEDIA_ERROR,
            details: N.FRAG_PARSING_ERROR,
            fatal: !0,
            error: f,
            reason: f.message
        });
        return
    }
    const o = (i >> 6 & 3) + 1
      , l = e[t + 3] >> 6 & 3 | (i & 1) << 2
      , c = "mp4a.40." + o
      , u = r[a];
    let d = a;
    (o === 5 || o === 29) && (d -= 3);
    const h = [o << 3 | (d & 14) >> 1, (d & 1) << 7 | l << 3];
    return fe.log(`manifest codec:${n}, parsed codec:${c}, channels:${l}, rate:${u} (ADTS object type:${o} sampling index:${a})`),
    {
        config: h,
        samplerate: u,
        channelCount: l,
        codec: c,
        parsedCodec: c,
        manifestCodec: n
    }
}
function R0(s, e) {
    return s[e] === 255 && (s[e + 1] & 246) === 240
}
function w0(s, e) {
    return s[e + 1] & 1 ? 7 : 9
}
function Id(s, e) {
    return (s[e + 3] & 3) << 11 | s[e + 4] << 3 | (s[e + 5] & 224) >>> 5
}
function R1(s, e) {
    return e + 5 < s.length
}
function Ro(s, e) {
    return e + 1 < s.length && R0(s, e)
}
function w1(s, e) {
    return R1(s, e) && R0(s, e) && Id(s, e) <= s.length - e
}
function C1(s, e) {
    if (Ro(s, e)) {
        const t = w0(s, e);
        if (e + t >= s.length)
            return !1;
        const n = Id(s, e);
        if (n <= t)
            return !1;
        const r = e + n;
        return r === s.length || Ro(s, r)
    }
    return !1
}
function C0(s, e, t, n, r) {
    if (!s.samplerate) {
        const i = b1(e, t, n, r);
        if (!i)
            return;
        ye(s, i)
    }
}
function k0(s) {
    return 1024 * 9e4 / s
}
function k1(s, e) {
    const t = w0(s, e);
    if (e + t <= s.length) {
        const n = Id(s, e) - t;
        if (n > 0)
            return {
                headerLength: t,
                frameLength: n
            }
    }
}
function _0(s, e, t, n, r) {
    const i = k0(s.samplerate)
      , a = n + r * i
      , o = k1(e, t);
    let l;
    if (o) {
        const {frameLength: d, headerLength: h} = o
          , f = h + d
          , m = Math.max(0, t + f - e.length);
        m ? (l = new Uint8Array(f - h),
        l.set(e.subarray(t + h, e.length), 0)) : l = e.subarray(t + h, t + f);
        const p = {
            unit: l,
            pts: a
        };
        return m || s.samples.push(p),
        {
            sample: p,
            length: f,
            missing: m
        }
    }
    const c = e.length - t;
    return l = new Uint8Array(c),
    l.set(e.subarray(t, e.length), 0),
    {
        sample: {
            unit: l,
            pts: a
        },
        length: c,
        missing: -1
    }
}
function _1(s, e) {
    return Ld(s, e) && Zo(s, e + 6) + 10 <= s.length - e
}
function D1(s) {
    return s instanceof ArrayBuffer ? s : s.byteOffset == 0 && s.byteLength == s.buffer.byteLength ? s.buffer : new Uint8Array(s).buffer
}
function Ml(s, e=0, t=1 / 0) {
    return P1(s, e, t, Uint8Array)
}
function P1(s, e, t, n) {
    const r = N1(s);
    let i = 1;
    "BYTES_PER_ELEMENT"in n && (i = n.BYTES_PER_ELEMENT);
    const a = O1(s) ? s.byteOffset : 0
      , o = (a + s.byteLength) / i
      , l = (a + e) / i
      , c = Math.floor(Math.max(0, Math.min(l, o)))
      , u = Math.floor(Math.min(c + Math.max(t, 0), o));
    return new n(r,c,u - c)
}
function N1(s) {
    return s instanceof ArrayBuffer ? s : s.buffer
}
function O1(s) {
    return s && s.buffer instanceof ArrayBuffer && s.byteLength !== void 0 && s.byteOffset !== void 0
}
function M1(s) {
    const e = {
        key: s.type,
        description: "",
        data: "",
        mimeType: null,
        pictureType: null
    }
      , t = 3;
    if (s.size < 2)
        return;
    if (s.data[0] !== t) {
        console.log("Ignore frame with unrecognized character encoding");
        return
    }
    const n = s.data.subarray(1).indexOf(0);
    if (n === -1)
        return;
    const r = wt(Ml(s.data, 1, n))
      , i = s.data[2 + n]
      , a = s.data.subarray(3 + n).indexOf(0);
    if (a === -1)
        return;
    const o = wt(Ml(s.data, 3 + n, a));
    let l;
    return r === "-->" ? l = wt(Ml(s.data, 4 + n + a)) : l = D1(s.data.subarray(4 + n + a)),
    e.mimeType = r,
    e.pictureType = i,
    e.description = o,
    e.data = l,
    e
}
function F1(s) {
    if (s.size < 2)
        return;
    const e = wt(s.data, !0)
      , t = new Uint8Array(s.data.subarray(e.length + 1));
    return {
        key: s.type,
        info: e,
        data: t.buffer
    }
}
function U1(s) {
    if (s.size < 2)
        return;
    if (s.type === "TXXX") {
        let t = 1;
        const n = wt(s.data.subarray(t), !0);
        t += n.length + 1;
        const r = wt(s.data.subarray(t));
        return {
            key: s.type,
            info: n,
            data: r
        }
    }
    const e = wt(s.data.subarray(1));
    return {
        key: s.type,
        info: "",
        data: e
    }
}
function B1(s) {
    if (s.type === "WXXX") {
        if (s.size < 2)
            return;
        let t = 1;
        const n = wt(s.data.subarray(t), !0);
        t += n.length + 1;
        const r = wt(s.data.subarray(t));
        return {
            key: s.type,
            info: n,
            data: r
        }
    }
    const e = wt(s.data);
    return {
        key: s.type,
        info: "",
        data: e
    }
}
function $1(s) {
    return s.type === "PRIV" ? F1(s) : s.type[0] === "W" ? B1(s) : s.type === "APIC" ? M1(s) : U1(s)
}
function j1(s) {
    const e = String.fromCharCode(s[0], s[1], s[2], s[3])
      , t = Zo(s, 4)
      , n = 10;
    return {
        type: e,
        size: t,
        data: s.subarray(n, n + t)
    }
}
const ha = 10
  , G1 = 10;
function D0(s) {
    let e = 0;
    const t = [];
    for (; Ld(s, e); ) {
        const n = Zo(s, e + 6);
        s[e + 5] >> 6 & 1 && (e += ha),
        e += ha;
        const r = e + n;
        for (; e + G1 < r; ) {
            const i = j1(s.subarray(e))
              , a = $1(i);
            a && t.push(a),
            e += i.size + ha
        }
        b0(s, e) && (e += ha)
    }
    return t
}
function P0(s) {
    return s && s.key === "PRIV" && s.info === "com.apple.streaming.transportStreamTimestamp"
}
function V1(s) {
    if (s.data.byteLength === 8) {
        const e = new Uint8Array(s.data)
          , t = e[3] & 1;
        let n = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
        return n /= 45,
        t && (n += 4772185884e-2),
        Math.round(n)
    }
}
function Ad(s) {
    const e = D0(s);
    for (let t = 0; t < e.length; t++) {
        const n = e[t];
        if (P0(n))
            return V1(n)
    }
}
let At = function(s) {
    return s.audioId3 = "org.id3",
    s.dateRange = "com.apple.quicktime.HLS",
    s.emsg = "https://aomedia.org/emsg/ID3",
    s.misbklv = "urn:misb:KLV:bin:1910.1",
    s
}({});
function as(s="", e=9e4) {
    return {
        type: s,
        id: -1,
        pid: -1,
        inputTimeScale: e,
        sequenceNumber: -1,
        samples: [],
        dropped: 0
    }
}
class bd {
    constructor() {
        this._audioTrack = void 0,
        this._id3Track = void 0,
        this.frameIndex = 0,
        this.cachedData = null,
        this.basePTS = null,
        this.initPTS = null,
        this.lastPTS = null
    }
    resetInitSegment(e, t, n, r) {
        this._id3Track = {
            type: "id3",
            id: 3,
            pid: -1,
            inputTimeScale: 9e4,
            sequenceNumber: 0,
            samples: [],
            dropped: 0
        }
    }
    resetTimeStamp(e) {
        this.initPTS = e,
        this.resetContiguity()
    }
    resetContiguity() {
        this.basePTS = null,
        this.lastPTS = null,
        this.frameIndex = 0
    }
    canParse(e, t) {
        return !1
    }
    appendFrame(e, t, n) {}
    demux(e, t) {
        this.cachedData && (e = jt(this.cachedData, e),
        this.cachedData = null);
        let n = wi(e, 0), r = n ? n.length : 0, i;
        const a = this._audioTrack
          , o = this._id3Track
          , l = n ? Ad(n) : void 0
          , c = e.length;
        for ((this.basePTS === null || this.frameIndex === 0 && z(l)) && (this.basePTS = H1(l, t, this.initPTS),
        this.lastPTS = this.basePTS),
        this.lastPTS === null && (this.lastPTS = this.basePTS),
        n && n.length > 0 && o.samples.push({
            pts: this.lastPTS,
            dts: this.lastPTS,
            data: n,
            type: At.audioId3,
            duration: Number.POSITIVE_INFINITY
        }); r < c; ) {
            if (this.canParse(e, r)) {
                const u = this.appendFrame(a, e, r);
                u ? (this.frameIndex++,
                this.lastPTS = u.sample.pts,
                r += u.length,
                i = r) : r = c
            } else
                _1(e, r) ? (n = wi(e, r),
                o.samples.push({
                    pts: this.lastPTS,
                    dts: this.lastPTS,
                    data: n,
                    type: At.audioId3,
                    duration: Number.POSITIVE_INFINITY
                }),
                r += n.length,
                i = r) : r++;
            if (r === c && i !== c) {
                const u = e.slice(i);
                this.cachedData ? this.cachedData = jt(this.cachedData, u) : this.cachedData = u
            }
        }
        return {
            audioTrack: a,
            videoTrack: as(),
            id3Track: o,
            textTrack: as()
        }
    }
    demuxSampleAes(e, t, n) {
        return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`))
    }
    flush(e) {
        const t = this.cachedData;
        return t && (this.cachedData = null,
        this.demux(t, 0)),
        {
            audioTrack: this._audioTrack,
            videoTrack: as(),
            id3Track: this._id3Track,
            textTrack: as()
        }
    }
    destroy() {
        this.cachedData = null,
        this._audioTrack = this._id3Track = void 0
    }
}
const H1 = (s, e, t) => {
    if (z(s))
        return s * 90;
    const n = t ? t.baseTime * 9e4 / t.timescale : 0;
    return e * 9e4 + n
}
;
let fa = null;
const K1 = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160]
  , W1 = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3]
  , z1 = [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]]
  , Y1 = [0, 1, 1, 4];
function N0(s, e, t, n, r) {
    if (t + 24 > e.length)
        return;
    const i = O0(e, t);
    if (i && t + i.frameLength <= e.length) {
        const a = i.samplesPerFrame * 9e4 / i.sampleRate
          , o = n + r * a
          , l = {
            unit: e.subarray(t, t + i.frameLength),
            pts: o,
            dts: o
        };
        return s.config = [],
        s.channelCount = i.channelCount,
        s.samplerate = i.sampleRate,
        s.samples.push(l),
        {
            sample: l,
            length: i.frameLength,
            missing: 0
        }
    }
}
function O0(s, e) {
    const t = s[e + 1] >> 3 & 3
      , n = s[e + 1] >> 1 & 3
      , r = s[e + 2] >> 4 & 15
      , i = s[e + 2] >> 2 & 3;
    if (t !== 1 && r !== 0 && r !== 15 && i !== 3) {
        const a = s[e + 2] >> 1 & 1
          , o = s[e + 3] >> 6
          , l = t === 3 ? 3 - n : n === 3 ? 3 : 4
          , c = K1[l * 14 + r - 1] * 1e3
          , d = W1[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + i]
          , h = o === 3 ? 1 : 2
          , f = z1[t][n]
          , m = Y1[n]
          , p = f * 8 * m
          , x = Math.floor(f * c / d + a) * m;
        if (fa === null) {
            const E = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
            fa = E ? parseInt(E[1]) : 0
        }
        return !!fa && fa <= 87 && n === 2 && c >= 224e3 && o === 0 && (s[e + 3] = s[e + 3] | 128),
        {
            sampleRate: d,
            channelCount: h,
            frameLength: x,
            samplesPerFrame: p
        }
    }
}
function Rd(s, e) {
    return s[e] === 255 && (s[e + 1] & 224) === 224 && (s[e + 1] & 6) !== 0
}
function M0(s, e) {
    return e + 1 < s.length && Rd(s, e)
}
function X1(s, e) {
    return Rd(s, e) && 4 <= s.length - e
}
function F0(s, e) {
    if (e + 1 < s.length && Rd(s, e)) {
        const n = O0(s, e);
        let r = 4;
        n != null && n.frameLength && (r = n.frameLength);
        const i = e + r;
        return i === s.length || M0(s, i)
    }
    return !1
}
class Z1 extends bd {
    constructor(e, t) {
        super(),
        this.observer = void 0,
        this.config = void 0,
        this.observer = e,
        this.config = t
    }
    resetInitSegment(e, t, n, r) {
        super.resetInitSegment(e, t, n, r),
        this._audioTrack = {
            container: "audio/adts",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "aac",
            samples: [],
            manifestCodec: t,
            duration: r,
            inputTimeScale: 9e4,
            dropped: 0
        }
    }
    static probe(e, t) {
        if (!e)
            return !1;
        const n = wi(e, 0);
        let r = (n == null ? void 0 : n.length) || 0;
        if (F0(e, r))
            return !1;
        for (let i = e.length; r < i; r++)
            if (C1(e, r))
                return t.log("ADTS sync word found !"),
                !0;
        return !1
    }
    canParse(e, t) {
        return w1(e, t)
    }
    appendFrame(e, t, n) {
        C0(e, this.observer, t, n, e.manifestCodec);
        const r = _0(e, t, n, this.basePTS, this.frameIndex);
        if (r && r.missing === 0)
            return r
    }
}
const U0 = (s, e) => {
    let t = 0
      , n = 5;
    e += n;
    const r = new Uint32Array(1)
      , i = new Uint32Array(1)
      , a = new Uint8Array(1);
    for (; n > 0; ) {
        a[0] = s[e];
        const o = Math.min(n, 8)
          , l = 8 - o;
        i[0] = 4278190080 >>> 24 + l << l,
        r[0] = (a[0] & i[0]) >> l,
        t = t ? t << o | r[0] : r[0],
        e += 1,
        n -= o
    }
    return t
}
;
class q1 extends bd {
    constructor(e) {
        super(),
        this.observer = void 0,
        this.observer = e
    }
    resetInitSegment(e, t, n, r) {
        super.resetInitSegment(e, t, n, r),
        this._audioTrack = {
            container: "audio/ac-3",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "ac3",
            samples: [],
            manifestCodec: t,
            duration: r,
            inputTimeScale: 9e4,
            dropped: 0
        }
    }
    canParse(e, t) {
        return t + 64 < e.length
    }
    appendFrame(e, t, n) {
        const r = B0(e, t, n, this.basePTS, this.frameIndex);
        if (r !== -1)
            return {
                sample: e.samples[e.samples.length - 1],
                length: r,
                missing: 0
            }
    }
    static probe(e) {
        if (!e)
            return !1;
        const t = wi(e, 0);
        if (!t)
            return !1;
        const n = t.length;
        return e[n] === 11 && e[n + 1] === 119 && Ad(t) !== void 0 && U0(e, n) < 16
    }
}
function B0(s, e, t, n, r) {
    if (t + 8 > e.length || e[t] !== 11 || e[t + 1] !== 119)
        return -1;
    const i = e[t + 4] >> 6;
    if (i >= 3)
        return -1;
    const o = [48e3, 44100, 32e3][i]
      , l = e[t + 4] & 63
      , u = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][l * 3 + i] * 2;
    if (t + u > e.length)
        return -1;
    const d = e[t + 6] >> 5;
    let h = 0;
    d === 2 ? h += 2 : (d & 1 && d !== 1 && (h += 2),
    d & 4 && (h += 2));
    const f = (e[t + 6] << 8 | e[t + 7]) >> 12 - h & 1
      , p = [2, 1, 2, 3, 3, 4, 4, 5][d] + f
      , x = e[t + 5] >> 3
      , y = e[t + 5] & 7
      , v = new Uint8Array([i << 6 | x << 1 | y >> 2, (y & 3) << 6 | d << 3 | f << 2 | l >> 4, l << 4 & 224])
      , E = 1536 / o * 9e4
      , T = n + r * E
      , L = e.subarray(t, t + u);
    return s.config = v,
    s.channelCount = p,
    s.samplerate = o,
    s.samples.push({
        unit: L,
        pts: T
    }),
    u
}
class Q1 extends bd {
    resetInitSegment(e, t, n, r) {
        super.resetInitSegment(e, t, n, r),
        this._audioTrack = {
            container: "audio/mpeg",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "mp3",
            samples: [],
            manifestCodec: t,
            duration: r,
            inputTimeScale: 9e4,
            dropped: 0
        }
    }
    static probe(e) {
        if (!e)
            return !1;
        const t = wi(e, 0);
        let n = (t == null ? void 0 : t.length) || 0;
        if (t && e[n] === 11 && e[n + 1] === 119 && Ad(t) !== void 0 && U0(e, n) <= 16)
            return !1;
        for (let r = e.length; n < r; n++)
            if (F0(e, n))
                return fe.log("MPEG Audio sync word found !"),
                !0;
        return !1
    }
    canParse(e, t) {
        return X1(e, t)
    }
    appendFrame(e, t, n) {
        if (this.basePTS !== null)
            return N0(e, t, n, this.basePTS, this.frameIndex)
    }
}
const J1 = /\/emsg[-/]ID3/i;
class eL {
    constructor(e, t) {
        this.remainderData = null,
        this.timeOffset = 0,
        this.config = void 0,
        this.videoTrack = void 0,
        this.audioTrack = void 0,
        this.id3Track = void 0,
        this.txtTrack = void 0,
        this.config = t
    }
    resetTimeStamp() {}
    resetInitSegment(e, t, n, r) {
        const i = this.videoTrack = as("video", 1)
          , a = this.audioTrack = as("audio", 1)
          , o = this.txtTrack = as("text", 1);
        if (this.id3Track = as("id3", 1),
        this.timeOffset = 0,
        !(e != null && e.byteLength))
            return;
        const l = e0(e);
        if (l.video) {
            const {id: c, timescale: u, codec: d, supplemental: h} = l.video;
            i.id = c,
            i.timescale = o.timescale = u,
            i.codec = d,
            i.supplemental = h
        }
        if (l.audio) {
            const {id: c, timescale: u, codec: d} = l.audio;
            a.id = c,
            a.timescale = u,
            a.codec = d
        }
        o.id = qp.text,
        i.sampleDuration = 0,
        i.duration = a.duration = r
    }
    resetContiguity() {
        this.remainderData = null
    }
    static probe(e) {
        return QS(e)
    }
    demux(e, t) {
        this.timeOffset = t;
        let n = e;
        const r = this.videoTrack
          , i = this.txtTrack;
        if (this.config.progressive) {
            this.remainderData && (n = jt(this.remainderData, e));
            const o = rT(n);
            this.remainderData = o.remainder,
            r.samples = o.valid || new Uint8Array
        } else
            r.samples = n;
        const a = this.extractID3Track(r, t);
        return i.samples = nf(t, r),
        {
            videoTrack: r,
            audioTrack: this.audioTrack,
            id3Track: a,
            textTrack: this.txtTrack
        }
    }
    flush() {
        const e = this.timeOffset
          , t = this.videoTrack
          , n = this.txtTrack;
        t.samples = this.remainderData || new Uint8Array,
        this.remainderData = null;
        const r = this.extractID3Track(t, this.timeOffset);
        return n.samples = nf(e, t),
        {
            videoTrack: t,
            audioTrack: as(),
            id3Track: r,
            textTrack: as()
        }
    }
    extractID3Track(e, t) {
        const n = this.id3Track;
        if (e.samples.length) {
            const r = ae(e.samples, ["emsg"]);
            r && r.forEach(i => {
                const a = aT(i);
                if (J1.test(a.schemeIdUri)) {
                    const o = $f(a, t);
                    let l = a.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : a.eventDuration / a.timeScale;
                    l <= .001 && (l = Number.POSITIVE_INFINITY);
                    const c = a.payload;
                    n.samples.push({
                        data: c,
                        len: c.byteLength,
                        dts: o,
                        pts: o,
                        type: At.emsg,
                        duration: l
                    })
                } else if (this.config.enableEmsgKLVMetadata && a.schemeIdUri.startsWith("urn:misb:KLV:bin:1910.1")) {
                    const o = $f(a, t);
                    n.samples.push({
                        data: a.payload,
                        len: a.payload.byteLength,
                        dts: o,
                        pts: o,
                        type: At.misbklv,
                        duration: Number.POSITIVE_INFINITY
                    })
                }
            }
            )
        }
        return n
    }
    demuxSampleAes(e, t, n) {
        return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
    }
    destroy() {
        this.config = null,
        this.remainderData = null,
        this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0
    }
}
function $f(s, e) {
    return z(s.presentationTime) ? s.presentationTime / s.timeScale : e + s.presentationTimeDelta / s.timeScale
}
class tL {
    constructor(e, t, n) {
        this.keyData = void 0,
        this.decrypter = void 0,
        this.keyData = n,
        this.decrypter = new yd(t,{
            removePKCS7Padding: !1
        })
    }
    decryptBuffer(e) {
        return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer, ln.cbc)
    }
    decryptAacSample(e, t, n) {
        const r = e[t].unit;
        if (r.length <= 16)
            return;
        const i = r.subarray(16, r.length - r.length % 16)
          , a = i.buffer.slice(i.byteOffset, i.byteOffset + i.length);
        this.decryptBuffer(a).then(o => {
            const l = new Uint8Array(o);
            r.set(l, 16),
            this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, n)
        }
        ).catch(n)
    }
    decryptAacSamples(e, t, n) {
        for (; ; t++) {
            if (t >= e.length) {
                n();
                return
            }
            if (!(e[t].unit.length < 32) && (this.decryptAacSample(e, t, n),
            !this.decrypter.isSync()))
                return
        }
    }
    getAvcEncryptedData(e) {
        const t = Math.floor((e.length - 48) / 160) * 16 + 16
          , n = new Int8Array(t);
        let r = 0;
        for (let i = 32; i < e.length - 16; i += 160,
        r += 16)
            n.set(e.subarray(i, i + 16), r);
        return n
    }
    getAvcDecryptedUnit(e, t) {
        const n = new Uint8Array(t);
        let r = 0;
        for (let i = 32; i < e.length - 16; i += 160,
        r += 16)
            e.set(n.subarray(r, r + 16), i);
        return e
    }
    decryptAvcSample(e, t, n, r, i) {
        const a = s0(i.data)
          , o = this.getAvcEncryptedData(a);
        this.decryptBuffer(o.buffer).then(l => {
            i.data = this.getAvcDecryptedUnit(a, l),
            this.decrypter.isSync() || this.decryptAvcSamples(e, t, n + 1, r)
        }
        ).catch(r)
    }
    decryptAvcSamples(e, t, n, r) {
        if (e instanceof Uint8Array)
            throw new Error("Cannot decrypt samples of type Uint8Array");
        for (; ; t++,
        n = 0) {
            if (t >= e.length) {
                r();
                return
            }
            const i = e[t].units;
            for (; !(n >= i.length); n++) {
                const a = i[n];
                if (!(a.data.length <= 48 || a.type !== 1 && a.type !== 5) && (this.decryptAvcSample(e, t, n, r, a),
                !this.decrypter.isSync()))
                    return
            }
        }
    }
}
class $0 {
    constructor() {
        this.VideoSample = null
    }
    createVideoSample(e, t, n) {
        return {
            key: e,
            frame: !1,
            pts: t,
            dts: n,
            units: [],
            length: 0
        }
    }
    getLastNalUnit(e) {
        var t;
        let n = this.VideoSample, r;
        if ((!n || n.units.length === 0) && (n = e[e.length - 1]),
        (t = n) != null && t.units) {
            const i = n.units;
            r = i[i.length - 1]
        }
        return r
    }
    pushAccessUnit(e, t) {
        if (e.units.length && e.frame) {
            if (e.pts === void 0) {
                const n = t.samples
                  , r = n.length;
                if (r) {
                    const i = n[r - 1];
                    e.pts = i.pts,
                    e.dts = i.dts
                } else {
                    t.dropped++;
                    return
                }
            }
            t.samples.push(e)
        }
    }
    parseNALu(e, t, n) {
        const r = t.byteLength;
        let i = e.naluState || 0;
        const a = i
          , o = [];
        let l = 0, c, u, d, h = -1, f = 0;
        for (i === -1 && (h = 0,
        f = this.getNALuType(t, 0),
        i = 0,
        l = 1); l < r; ) {
            if (c = t[l++],
            !i) {
                i = c ? 0 : 1;
                continue
            }
            if (i === 1) {
                i = c ? 0 : 2;
                continue
            }
            if (!c)
                i = 3;
            else if (c === 1) {
                if (u = l - i - 1,
                h >= 0) {
                    const m = {
                        data: t.subarray(h, u),
                        type: f
                    };
                    o.push(m)
                } else {
                    const m = this.getLastNalUnit(e.samples);
                    m && (a && l <= 4 - a && m.state && (m.data = m.data.subarray(0, m.data.byteLength - a)),
                    u > 0 && (m.data = jt(m.data, t.subarray(0, u)),
                    m.state = 0))
                }
                l < r ? (d = this.getNALuType(t, l),
                h = l,
                f = d,
                i = 0) : i = -1
            } else
                i = 0
        }
        if (h >= 0 && i >= 0) {
            const m = {
                data: t.subarray(h, r),
                type: f,
                state: i
            };
            o.push(m)
        }
        if (o.length === 0) {
            const m = this.getLastNalUnit(e.samples);
            m && (m.data = jt(m.data, t))
        }
        return e.naluState = i,
        o
    }
}
class ri {
    constructor(e) {
        this.data = void 0,
        this.bytesAvailable = void 0,
        this.word = void 0,
        this.bitsAvailable = void 0,
        this.data = e,
        this.bytesAvailable = e.byteLength,
        this.word = 0,
        this.bitsAvailable = 0
    }
    loadWord() {
        const e = this.data
          , t = this.bytesAvailable
          , n = e.byteLength - t
          , r = new Uint8Array(4)
          , i = Math.min(4, t);
        if (i === 0)
            throw new Error("no bytes available");
        r.set(e.subarray(n, n + i)),
        this.word = new DataView(r.buffer).getUint32(0),
        this.bitsAvailable = i * 8,
        this.bytesAvailable -= i
    }
    skipBits(e) {
        let t;
        e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable),
        this.bitsAvailable > e ? (this.word <<= e,
        this.bitsAvailable -= e) : (e -= this.bitsAvailable,
        t = e >> 3,
        e -= t << 3,
        this.bytesAvailable -= t,
        this.loadWord(),
        this.word <<= e,
        this.bitsAvailable -= e)
    }
    readBits(e) {
        let t = Math.min(this.bitsAvailable, e);
        const n = this.word >>> 32 - t;
        if (e > 32 && fe.error("Cannot read more than 32 bits at a time"),
        this.bitsAvailable -= t,
        this.bitsAvailable > 0)
            this.word <<= t;
        else if (this.bytesAvailable > 0)
            this.loadWord();
        else
            throw new Error("no bits available");
        return t = e - t,
        t > 0 && this.bitsAvailable ? n << t | this.readBits(t) : n
    }
    skipLZ() {
        let e;
        for (e = 0; e < this.bitsAvailable; ++e)
            if (this.word & 2147483648 >>> e)
                return this.word <<= e,
                this.bitsAvailable -= e,
                e;
        return this.loadWord(),
        e + this.skipLZ()
    }
    skipUEG() {
        this.skipBits(1 + this.skipLZ())
    }
    skipEG() {
        this.skipBits(1 + this.skipLZ())
    }
    readUEG() {
        const e = this.skipLZ();
        return this.readBits(e + 1) - 1
    }
    readEG() {
        const e = this.readUEG();
        return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1)
    }
    readBoolean() {
        return this.readBits(1) === 1
    }
    readUByte() {
        return this.readBits(8)
    }
    readUShort() {
        return this.readBits(16)
    }
    readUInt() {
        return this.readBits(32)
    }
}
class sL extends $0 {
    parsePES(e, t, n, r) {
        const i = this.parseNALu(e, n.data, r);
        let a = this.VideoSample, o, l = !1;
        n.data = null,
        a && i.length && !e.audFound && (this.pushAccessUnit(a, e),
        a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts)),
        i.forEach(c => {
            var u, d;
            switch (c.type) {
            case 1:
                {
                    let p = !1;
                    o = !0;
                    const x = c.data;
                    if (l && x.length > 4) {
                        const y = this.readSliceType(x);
                        (y === 2 || y === 4 || y === 7 || y === 9) && (p = !0)
                    }
                    if (p) {
                        var h;
                        (h = a) != null && h.frame && !a.key && (this.pushAccessUnit(a, e),
                        a = this.VideoSample = null)
                    }
                    a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts)),
                    a.frame = !0,
                    a.key = p;
                    break
                }
            case 5:
                o = !0,
                (u = a) != null && u.frame && !a.key && (this.pushAccessUnit(a, e),
                a = this.VideoSample = null),
                a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts)),
                a.key = !0,
                a.frame = !0;
                break;
            case 6:
                {
                    o = !0,
                    fd(c.data, 1, n.pts, t.samples);
                    break
                }
            case 7:
                {
                    var f, m;
                    o = !0,
                    l = !0;
                    const p = c.data
                      , x = this.readSPS(p);
                    if (!e.sps || e.width !== x.width || e.height !== x.height || ((f = e.pixelRatio) == null ? void 0 : f[0]) !== x.pixelRatio[0] || ((m = e.pixelRatio) == null ? void 0 : m[1]) !== x.pixelRatio[1]) {
                        e.width = x.width,
                        e.height = x.height,
                        e.pixelRatio = x.pixelRatio,
                        e.sps = [p];
                        const y = p.subarray(1, 4);
                        let v = "avc1.";
                        for (let E = 0; E < 3; E++) {
                            let T = y[E].toString(16);
                            T.length < 2 && (T = "0" + T),
                            v += T
                        }
                        e.codec = v
                    }
                    break
                }
            case 8:
                o = !0,
                e.pps = [c.data];
                break;
            case 9:
                o = !0,
                e.audFound = !0,
                (d = a) != null && d.frame && (this.pushAccessUnit(a, e),
                a = null),
                a || (a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts));
                break;
            case 12:
                o = !0;
                break;
            default:
                o = !1;
                break
            }
            a && o && a.units.push(c)
        }
        ),
        r && a && (this.pushAccessUnit(a, e),
        this.VideoSample = null)
    }
    getNALuType(e, t) {
        return e[t] & 31
    }
    readSliceType(e) {
        const t = new ri(e);
        return t.readUByte(),
        t.readUEG(),
        t.readUEG()
    }
    skipScalingList(e, t) {
        let n = 8, r = 8, i;
        for (let a = 0; a < e; a++)
            r !== 0 && (i = t.readEG(),
            r = (n + i + 256) % 256),
            n = r === 0 ? n : r
    }
    readSPS(e) {
        const t = new ri(e);
        let n = 0, r = 0, i = 0, a = 0, o, l, c;
        const u = t.readUByte.bind(t)
          , d = t.readBits.bind(t)
          , h = t.readUEG.bind(t)
          , f = t.readBoolean.bind(t)
          , m = t.skipBits.bind(t)
          , p = t.skipEG.bind(t)
          , x = t.skipUEG.bind(t)
          , y = this.skipScalingList.bind(this);
        u();
        const v = u();
        if (d(5),
        m(3),
        u(),
        x(),
        v === 100 || v === 110 || v === 122 || v === 244 || v === 44 || v === 83 || v === 86 || v === 118 || v === 128) {
            const A = h();
            if (A === 3 && m(1),
            x(),
            x(),
            m(1),
            f())
                for (l = A !== 3 ? 8 : 12,
                c = 0; c < l; c++)
                    f() && (c < 6 ? y(16, t) : y(64, t))
        }
        x();
        const E = h();
        if (E === 0)
            h();
        else if (E === 1)
            for (m(1),
            p(),
            p(),
            o = h(),
            c = 0; c < o; c++)
                p();
        x(),
        m(1);
        const T = h()
          , L = h()
          , R = d(1);
        R === 0 && m(1),
        m(1),
        f() && (n = h(),
        r = h(),
        i = h(),
        a = h());
        let I = [1, 1];
        if (f() && f())
            switch (u()) {
            case 1:
                I = [1, 1];
                break;
            case 2:
                I = [12, 11];
                break;
            case 3:
                I = [10, 11];
                break;
            case 4:
                I = [16, 11];
                break;
            case 5:
                I = [40, 33];
                break;
            case 6:
                I = [24, 11];
                break;
            case 7:
                I = [20, 11];
                break;
            case 8:
                I = [32, 11];
                break;
            case 9:
                I = [80, 33];
                break;
            case 10:
                I = [18, 11];
                break;
            case 11:
                I = [15, 11];
                break;
            case 12:
                I = [64, 33];
                break;
            case 13:
                I = [160, 99];
                break;
            case 14:
                I = [4, 3];
                break;
            case 15:
                I = [3, 2];
                break;
            case 16:
                I = [2, 1];
                break;
            case 255:
                {
                    I = [u() << 8 | u(), u() << 8 | u()];
                    break
                }
            }
        return {
            width: Math.ceil((T + 1) * 16 - n * 2 - r * 2),
            height: (2 - R) * (L + 1) * 16 - (R ? 2 : 4) * (i + a),
            pixelRatio: I
        }
    }
}
class nL extends $0 {
    constructor(...e) {
        super(...e),
        this.initVPS = null
    }
    parsePES(e, t, n, r) {
        const i = this.parseNALu(e, n.data, r);
        let a = this.VideoSample, o, l = !1;
        n.data = null,
        a && i.length && !e.audFound && (this.pushAccessUnit(a, e),
        a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts)),
        i.forEach(c => {
            var u, d;
            switch (c.type) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
                a || (a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts)),
                a.frame = !0,
                o = !0;
                break;
            case 16:
            case 17:
            case 18:
            case 21:
                if (o = !0,
                l) {
                    var h;
                    (h = a) != null && h.frame && !a.key && (this.pushAccessUnit(a, e),
                    a = this.VideoSample = null)
                }
                a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts)),
                a.key = !0,
                a.frame = !0;
                break;
            case 19:
            case 20:
                o = !0,
                (u = a) != null && u.frame && !a.key && (this.pushAccessUnit(a, e),
                a = this.VideoSample = null),
                a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts)),
                a.key = !0,
                a.frame = !0;
                break;
            case 39:
                o = !0,
                fd(c.data, 2, n.pts, t.samples);
                break;
            case 32:
                o = !0,
                e.vps || (typeof e.params != "object" && (e.params = {}),
                e.params = ye(e.params, this.readVPS(c.data)),
                this.initVPS = c.data),
                e.vps = [c.data];
                break;
            case 33:
                if (o = !0,
                l = !0,
                e.vps !== void 0 && e.vps[0] !== this.initVPS && e.sps !== void 0 && !this.matchSPS(e.sps[0], c.data) && (this.initVPS = e.vps[0],
                e.sps = e.pps = void 0),
                !e.sps) {
                    const f = this.readSPS(c.data);
                    e.width = f.width,
                    e.height = f.height,
                    e.pixelRatio = f.pixelRatio,
                    e.codec = f.codecString,
                    e.sps = [],
                    typeof e.params != "object" && (e.params = {});
                    for (const m in f.params)
                        e.params[m] = f.params[m]
                }
                this.pushParameterSet(e.sps, c.data, e.vps),
                a || (a = this.VideoSample = this.createVideoSample(!0, n.pts, n.dts)),
                a.key = !0;
                break;
            case 34:
                if (o = !0,
                typeof e.params == "object") {
                    if (!e.pps) {
                        e.pps = [];
                        const f = this.readPPS(c.data);
                        for (const m in f)
                            e.params[m] = f[m]
                    }
                    this.pushParameterSet(e.pps, c.data, e.vps)
                }
                break;
            case 35:
                o = !0,
                e.audFound = !0,
                (d = a) != null && d.frame && (this.pushAccessUnit(a, e),
                a = null),
                a || (a = this.VideoSample = this.createVideoSample(!1, n.pts, n.dts));
                break;
            default:
                o = !1;
                break
            }
            a && o && a.units.push(c)
        }
        ),
        r && a && (this.pushAccessUnit(a, e),
        this.VideoSample = null)
    }
    pushParameterSet(e, t, n) {
        (n && n[0] === this.initVPS || !n && !e.length) && e.push(t)
    }
    getNALuType(e, t) {
        return (e[t] & 126) >>> 1
    }
    ebsp2rbsp(e) {
        const t = new Uint8Array(e.byteLength);
        let n = 0;
        for (let r = 0; r < e.byteLength; r++)
            r >= 2 && e[r] === 3 && e[r - 1] === 0 && e[r - 2] === 0 || (t[n] = e[r],
            n++);
        return new Uint8Array(t.buffer,0,n)
    }
    pushAccessUnit(e, t) {
        super.pushAccessUnit(e, t),
        this.initVPS && (this.initVPS = null)
    }
    readVPS(e) {
        const t = new ri(e);
        t.readUByte(),
        t.readUByte(),
        t.readBits(4),
        t.skipBits(2),
        t.readBits(6);
        const n = t.readBits(3)
          , r = t.readBoolean();
        return {
            numTemporalLayers: n + 1,
            temporalIdNested: r
        }
    }
    readSPS(e) {
        const t = new ri(this.ebsp2rbsp(e));
        t.readUByte(),
        t.readUByte(),
        t.readBits(4);
        const n = t.readBits(3);
        t.readBoolean();
        const r = t.readBits(2)
          , i = t.readBoolean()
          , a = t.readBits(5)
          , o = t.readUByte()
          , l = t.readUByte()
          , c = t.readUByte()
          , u = t.readUByte()
          , d = t.readUByte()
          , h = t.readUByte()
          , f = t.readUByte()
          , m = t.readUByte()
          , p = t.readUByte()
          , x = t.readUByte()
          , y = t.readUByte()
          , v = []
          , E = [];
        for (let oe = 0; oe < n; oe++)
            v.push(t.readBoolean()),
            E.push(t.readBoolean());
        if (n > 0)
            for (let oe = n; oe < 8; oe++)
                t.readBits(2);
        for (let oe = 0; oe < n; oe++)
            v[oe] && (t.readUByte(),
            t.readUByte(),
            t.readUByte(),
            t.readUByte(),
            t.readUByte(),
            t.readUByte(),
            t.readUByte(),
            t.readUByte(),
            t.readUByte(),
            t.readUByte(),
            t.readUByte()),
            E[oe] && t.readUByte();
        t.readUEG();
        const T = t.readUEG();
        T == 3 && t.skipBits(1);
        const L = t.readUEG()
          , R = t.readUEG()
          , I = t.readBoolean();
        let A = 0
          , C = 0
          , b = 0
          , O = 0;
        I && (A += t.readUEG(),
        C += t.readUEG(),
        b += t.readUEG(),
        O += t.readUEG());
        const _ = t.readUEG()
          , $ = t.readUEG()
          , K = t.readUEG()
          , W = t.readBoolean();
        for (let oe = W ? 0 : n; oe <= n; oe++)
            t.skipUEG(),
            t.skipUEG(),
            t.skipUEG();
        if (t.skipUEG(),
        t.skipUEG(),
        t.skipUEG(),
        t.skipUEG(),
        t.skipUEG(),
        t.skipUEG(),
        t.readBoolean() && t.readBoolean())
            for (let Be = 0; Be < 4; Be++)
                for (let ht = 0; ht < (Be === 3 ? 2 : 6); ht++)
                    if (!t.readBoolean())
                        t.readUEG();
                    else {
                        const St = Math.min(64, 1 << 4 + (Be << 1));
                        Be > 1 && t.readEG();
                        for (let Fs = 0; Fs < St; Fs++)
                            t.readEG()
                    }
        t.readBoolean(),
        t.readBoolean(),
        t.readBoolean() && (t.readUByte(),
        t.skipUEG(),
        t.skipUEG(),
        t.readBoolean());
        const D = t.readUEG();
        let B = 0;
        for (let oe = 0; oe < D; oe++) {
            let Be = !1;
            if (oe !== 0 && (Be = t.readBoolean()),
            Be) {
                oe === D && t.readUEG(),
                t.readBoolean(),
                t.readUEG();
                let ht = 0;
                for (let xs = 0; xs <= B; xs++) {
                    const St = t.readBoolean();
                    let Fs = !1;
                    St || (Fs = t.readBoolean()),
                    (St || Fs) && ht++
                }
                B = ht
            } else {
                const ht = t.readUEG()
                  , xs = t.readUEG();
                B = ht + xs;
                for (let St = 0; St < ht; St++)
                    t.readUEG(),
                    t.readBoolean();
                for (let St = 0; St < xs; St++)
                    t.readUEG(),
                    t.readBoolean()
            }
        }
        if (t.readBoolean()) {
            const oe = t.readUEG();
            for (let Be = 0; Be < oe; Be++) {
                for (let ht = 0; ht < K + 4; ht++)
                    t.readBits(1);
                t.readBits(1)
            }
        }
        let F = 0
          , j = 1
          , J = 1
          , re = !0
          , Q = 1
          , se = 0;
        t.readBoolean(),
        t.readBoolean();
        let Le = !1;
        if (t.readBoolean()) {
            if (t.readBoolean()) {
                const vs = t.readUByte()
                  , _r = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2]
                  , mn = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];
                vs > 0 && vs < 16 ? (j = _r[vs - 1],
                J = mn[vs - 1]) : vs === 255 && (j = t.readBits(16),
                J = t.readBits(16))
            }
            if (t.readBoolean() && t.readBoolean(),
            t.readBoolean() && (t.readBits(3),
            t.readBoolean(),
            t.readBoolean() && (t.readUByte(),
            t.readUByte(),
            t.readUByte())),
            t.readBoolean() && (t.readUEG(),
            t.readUEG()),
            t.readBoolean(),
            t.readBoolean(),
            t.readBoolean(),
            Le = t.readBoolean(),
            Le && (t.skipUEG(),
            t.skipUEG(),
            t.skipUEG(),
            t.skipUEG()),
            t.readBoolean() && (Q = t.readBits(32),
            se = t.readBits(32),
            t.readBoolean() && t.readUEG(),
            t.readBoolean())) {
                const mn = t.readBoolean()
                  , $i = t.readBoolean();
                let gn = !1;
                (mn || $i) && (gn = t.readBoolean(),
                gn && (t.readUByte(),
                t.readBits(5),
                t.readBoolean(),
                t.readBits(5)),
                t.readBits(4),
                t.readBits(4),
                gn && t.readBits(4),
                t.readBits(5),
                t.readBits(5),
                t.readBits(5));
                for (let Un = 0; Un <= n; Un++) {
                    re = t.readBoolean();
                    const Qo = re || t.readBoolean();
                    let ji = !1;
                    Qo ? t.readEG() : ji = t.readBoolean();
                    const pn = ji ? 1 : t.readUEG() + 1;
                    if (mn)
                        for (let M = 0; M < pn; M++)
                            t.readUEG(),
                            t.readUEG(),
                            gn && (t.readUEG(),
                            t.readUEG()),
                            t.skipBits(1);
                    if ($i)
                        for (let M = 0; M < pn; M++)
                            t.readUEG(),
                            t.readUEG(),
                            gn && (t.readUEG(),
                            t.readUEG()),
                            t.skipBits(1)
                }
            }
            t.readBoolean() && (t.readBoolean(),
            t.readBoolean(),
            t.readBoolean(),
            F = t.readUEG())
        }
        let Ne = L
          , Dt = R;
        if (I) {
            let oe = 1
              , Be = 1;
            T === 1 ? oe = Be = 2 : T == 2 && (oe = 2),
            Ne = L - oe * C - oe * A,
            Dt = R - Be * O - Be * b
        }
        const Oe = r ? ["A", "B", "C"][r] : ""
          , ys = o << 24 | l << 16 | c << 8 | u;
        let Fn = 0;
        for (let oe = 0; oe < 32; oe++)
            Fn = (Fn | (ys >> oe & 1) << 31 - oe) >>> 0;
        let fn = Fn.toString(16);
        return a === 1 && fn === "2" && (fn = "6"),
        {
            codecString: `hvc1.${Oe}${a}.${fn}.${i ? "H" : "L"}${y}.B0`,
            params: {
                general_tier_flag: i,
                general_profile_idc: a,
                general_profile_space: r,
                general_profile_compatibility_flags: [o, l, c, u],
                general_constraint_indicator_flags: [d, h, f, m, p, x],
                general_level_idc: y,
                bit_depth: _ + 8,
                bit_depth_luma_minus8: _,
                bit_depth_chroma_minus8: $,
                min_spatial_segmentation_idc: F,
                chroma_format_idc: T,
                frame_rate: {
                    fixed: re,
                    fps: se / Q
                }
            },
            width: Ne,
            height: Dt,
            pixelRatio: [j, J]
        }
    }
    readPPS(e) {
        const t = new ri(this.ebsp2rbsp(e));
        t.readUByte(),
        t.readUByte(),
        t.skipUEG(),
        t.skipUEG(),
        t.skipBits(2),
        t.skipBits(3),
        t.skipBits(2),
        t.skipUEG(),
        t.skipUEG(),
        t.skipEG(),
        t.skipBits(2),
        t.readBoolean() && t.skipUEG(),
        t.skipEG(),
        t.skipEG(),
        t.skipBits(4);
        const r = t.readBoolean()
          , i = t.readBoolean();
        let a = 1;
        return i && r ? a = 0 : i ? a = 3 : r && (a = 2),
        {
            parallelismType: a
        }
    }
    matchSPS(e, t) {
        return String.fromCharCode.apply(null, e).substr(3) === String.fromCharCode.apply(null, t).substr(3)
    }
}
const We = 188;
class Hs {
    constructor(e, t, n, r) {
        this.logger = void 0,
        this.observer = void 0,
        this.config = void 0,
        this.typeSupported = void 0,
        this.sampleAes = null,
        this.pmtParsed = !1,
        this.audioCodec = void 0,
        this.videoCodec = void 0,
        this._pmtId = -1,
        this._videoTrack = void 0,
        this._audioTrack = void 0,
        this._id3Track = void 0,
        this._txtTrack = void 0,
        this.aacOverFlow = null,
        this.remainderData = null,
        this.videoParser = void 0,
        this.observer = e,
        this.config = t,
        this.typeSupported = n,
        this.logger = r,
        this.videoParser = null
    }
    static probe(e, t) {
        const n = Hs.syncOffset(e);
        return n > 0 && t.warn(`MPEG2-TS detected but first sync word found @ offset ${n}`),
        n !== -1
    }
    static syncOffset(e) {
        const t = e.length;
        let n = Math.min(We * 5, t - We) + 1
          , r = 0;
        for (; r < n; ) {
            let i = !1
              , a = -1
              , o = 0;
            for (let l = r; l < t; l += We)
                if (e[l] === 71 && (t - l === We || e[l + We] === 71)) {
                    if (o++,
                    a === -1 && (a = l,
                    a !== 0 && (n = Math.min(a + We * 99, e.length - We) + 1)),
                    i || (i = su(e, l) === 0),
                    i && o > 1 && (a === 0 && o > 2 || l + We > n))
                        return a
                } else {
                    if (o)
                        return -1;
                    break
                }
            r++
        }
        return -1
    }
    static createTrack(e, t) {
        return {
            container: e === "video" || e === "audio" ? "video/mp2t" : void 0,
            type: e,
            id: qp[e],
            pid: -1,
            inputTimeScale: 9e4,
            sequenceNumber: 0,
            samples: [],
            dropped: 0,
            duration: e === "audio" ? t : void 0
        }
    }
    resetInitSegment(e, t, n, r) {
        this.pmtParsed = !1,
        this._pmtId = -1,
        this._videoTrack = Hs.createTrack("video"),
        this._videoTrack.duration = r,
        this._audioTrack = Hs.createTrack("audio", r),
        this._id3Track = Hs.createTrack("id3"),
        this._txtTrack = Hs.createTrack("text"),
        this._audioTrack.segmentCodec = "aac",
        this.videoParser = null,
        this.aacOverFlow = null,
        this.remainderData = null,
        this.audioCodec = t,
        this.videoCodec = n
    }
    resetTimeStamp() {}
    resetContiguity() {
        const {_audioTrack: e, _videoTrack: t, _id3Track: n} = this;
        e && (e.pesData = null),
        t && (t.pesData = null),
        n && (n.pesData = null),
        this.aacOverFlow = null,
        this.remainderData = null
    }
    demux(e, t, n=!1, r=!1) {
        n || (this.sampleAes = null);
        let i;
        const a = this._videoTrack
          , o = this._audioTrack
          , l = this._id3Track
          , c = this._txtTrack;
        let u = a.pid
          , d = a.pesData
          , h = o.pid
          , f = l.pid
          , m = o.pesData
          , p = l.pesData
          , x = null
          , y = this.pmtParsed
          , v = this._pmtId
          , E = e.length;
        if (this.remainderData && (e = jt(this.remainderData, e),
        E = e.length,
        this.remainderData = null),
        E < We && !r)
            return this.remainderData = e,
            {
                audioTrack: o,
                videoTrack: a,
                id3Track: l,
                textTrack: c
            };
        const T = Math.max(0, Hs.syncOffset(e));
        E -= (E - T) % We,
        E < e.byteLength && !r && (this.remainderData = new Uint8Array(e.buffer,E,e.buffer.byteLength - E));
        let L = 0;
        for (let I = T; I < E; I += We)
            if (e[I] === 71) {
                const A = !!(e[I + 1] & 64)
                  , C = su(e, I)
                  , b = (e[I + 3] & 48) >> 4;
                let O;
                if (b > 1) {
                    if (O = I + 5 + e[I + 4],
                    O === I + We)
                        continue
                } else
                    O = I + 4;
                switch (C) {
                case u:
                    A && (d && (i = Gn(d, this.logger)) && (this.readyVideoParser(a.segmentCodec),
                    this.videoParser !== null && this.videoParser.parsePES(a, c, i, !1)),
                    d = {
                        data: [],
                        size: 0
                    }),
                    d && (d.data.push(e.subarray(O, I + We)),
                    d.size += I + We - O);
                    break;
                case h:
                    if (A) {
                        if (m && (i = Gn(m, this.logger)))
                            switch (o.segmentCodec) {
                            case "aac":
                                this.parseAACPES(o, i);
                                break;
                            case "mp3":
                                this.parseMPEGPES(o, i);
                                break;
                            case "ac3":
                                this.parseAC3PES(o, i);
                                break
                            }
                        m = {
                            data: [],
                            size: 0
                        }
                    }
                    m && (m.data.push(e.subarray(O, I + We)),
                    m.size += I + We - O);
                    break;
                case f:
                    A && (p && (i = Gn(p, this.logger)) && this.parseID3PES(l, i),
                    p = {
                        data: [],
                        size: 0
                    }),
                    p && (p.data.push(e.subarray(O, I + We)),
                    p.size += I + We - O);
                    break;
                case 0:
                    A && (O += e[O] + 1),
                    v = this._pmtId = rL(e, O);
                    break;
                case v:
                    {
                        A && (O += e[O] + 1);
                        const _ = iL(e, O, this.typeSupported, n, this.observer, this.logger);
                        u = _.videoPid,
                        u > 0 && (a.pid = u,
                        a.segmentCodec = _.segmentVideoCodec),
                        h = _.audioPid,
                        h > 0 && (o.pid = h,
                        o.segmentCodec = _.segmentAudioCodec),
                        f = _.id3Pid,
                        f > 0 && (l.pid = f),
                        x !== null && !y && (this.logger.warn(`MPEG-TS PMT found at ${I} after unknown PID '${x}'. Backtracking to sync byte @${T} to parse all TS packets.`),
                        x = null,
                        I = T - 188),
                        y = this.pmtParsed = !0;
                        break
                    }
                case 17:
                case 8191:
                    break;
                default:
                    x = C;
                    break
                }
            } else
                L++;
        L > 0 && nu(this.observer, new Error(`Found ${L} TS packet/s that do not start with 0x47`), void 0, this.logger),
        a.pesData = d,
        o.pesData = m,
        l.pesData = p;
        const R = {
            audioTrack: o,
            videoTrack: a,
            id3Track: l,
            textTrack: c
        };
        return r && this.extractRemainingSamples(R),
        R
    }
    flush() {
        const {remainderData: e} = this;
        this.remainderData = null;
        let t;
        return e ? t = this.demux(e, -1, !1, !0) : t = {
            videoTrack: this._videoTrack,
            audioTrack: this._audioTrack,
            id3Track: this._id3Track,
            textTrack: this._txtTrack
        },
        this.extractRemainingSamples(t),
        this.sampleAes ? this.decrypt(t, this.sampleAes) : t
    }
    extractRemainingSamples(e) {
        const {audioTrack: t, videoTrack: n, id3Track: r, textTrack: i} = e
          , a = n.pesData
          , o = t.pesData
          , l = r.pesData;
        let c;
        if (a && (c = Gn(a, this.logger)) ? (this.readyVideoParser(n.segmentCodec),
        this.videoParser !== null && (this.videoParser.parsePES(n, i, c, !0),
        n.pesData = null)) : n.pesData = a,
        o && (c = Gn(o, this.logger))) {
            switch (t.segmentCodec) {
            case "aac":
                this.parseAACPES(t, c);
                break;
            case "mp3":
                this.parseMPEGPES(t, c);
                break;
            case "ac3":
                this.parseAC3PES(t, c);
                break
            }
            t.pesData = null
        } else
            o != null && o.size && this.logger.log("last AAC PES packet truncated,might overlap between fragments"),
            t.pesData = o;
        l && (c = Gn(l, this.logger)) ? (this.parseID3PES(r, c),
        r.pesData = null) : r.pesData = l
    }
    demuxSampleAes(e, t, n) {
        const r = this.demux(e, n, !0, !this.config.progressive)
          , i = this.sampleAes = new tL(this.observer,this.config,t);
        return this.decrypt(r, i)
    }
    readyVideoParser(e) {
        this.videoParser === null && (e === "avc" ? this.videoParser = new sL : e === "hevc" && (this.videoParser = new nL))
    }
    decrypt(e, t) {
        return new Promise(n => {
            const {audioTrack: r, videoTrack: i} = e;
            r.samples && r.segmentCodec === "aac" ? t.decryptAacSamples(r.samples, 0, () => {
                i.samples ? t.decryptAvcSamples(i.samples, 0, 0, () => {
                    n(e)
                }
                ) : n(e)
            }
            ) : i.samples && t.decryptAvcSamples(i.samples, 0, 0, () => {
                n(e)
            }
            )
        }
        )
    }
    destroy() {
        this.observer && this.observer.removeAllListeners(),
        this.config = this.logger = this.observer = null,
        this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null,
        this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0
    }
    parseAACPES(e, t) {
        let n = 0;
        const r = this.aacOverFlow;
        let i = t.data;
        if (r) {
            this.aacOverFlow = null;
            const d = r.missing
              , h = r.sample.unit.byteLength;
            if (d === -1)
                i = jt(r.sample.unit, i);
            else {
                const f = h - d;
                r.sample.unit.set(i.subarray(0, d), f),
                e.samples.push(r.sample),
                n = r.missing
            }
        }
        let a, o;
        for (a = n,
        o = i.length; a < o - 1 && !Ro(i, a); a++)
            ;
        if (a !== n) {
            let d;
            const h = a < o - 1;
            if (h ? d = `AAC PES did not start with ADTS header,offset:${a}` : d = "No ADTS header found in AAC PES",
            nu(this.observer, new Error(d), h, this.logger),
            !h)
                return
        }
        C0(e, this.observer, i, a, this.audioCodec);
        let l;
        if (t.pts !== void 0)
            l = t.pts;
        else if (r) {
            const d = k0(e.samplerate);
            l = r.sample.pts + d
        } else {
            this.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
            return
        }
        let c = 0, u;
        for (; a < o; )
            if (u = _0(e, i, a, l, c),
            a += u.length,
            u.missing) {
                this.aacOverFlow = u;
                break
            } else
                for (c++; a < o - 1 && !Ro(i, a); a++)
                    ;
    }
    parseMPEGPES(e, t) {
        const n = t.data
          , r = n.length;
        let i = 0
          , a = 0;
        const o = t.pts;
        if (o === void 0) {
            this.logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
            return
        }
        for (; a < r; )
            if (M0(n, a)) {
                const l = N0(e, n, a, o, i);
                if (l)
                    a += l.length,
                    i++;
                else
                    break
            } else
                a++
    }
    parseAC3PES(e, t) {
        {
            const n = t.data
              , r = t.pts;
            if (r === void 0) {
                this.logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
                return
            }
            const i = n.length;
            let a = 0, o = 0, l;
            for (; o < i && (l = B0(e, n, o, r, a++)) > 0; )
                o += l
        }
    }
    parseID3PES(e, t) {
        if (t.pts === void 0) {
            this.logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
            return
        }
        const n = ye({}, t, {
            type: this._videoTrack ? At.emsg : At.audioId3,
            duration: Number.POSITIVE_INFINITY
        });
        e.samples.push(n)
    }
}
function su(s, e) {
    return ((s[e + 1] & 31) << 8) + s[e + 2]
}
function rL(s, e) {
    return (s[e + 10] & 31) << 8 | s[e + 11]
}
function iL(s, e, t, n, r, i) {
    const a = {
        audioPid: -1,
        videoPid: -1,
        id3Pid: -1,
        segmentVideoCodec: "avc",
        segmentAudioCodec: "aac"
    }
      , o = (s[e + 1] & 15) << 8 | s[e + 2]
      , l = e + 3 + o - 4
      , c = (s[e + 10] & 15) << 8 | s[e + 11];
    for (e += 12 + c; e < l; ) {
        const u = su(s, e)
          , d = (s[e + 3] & 15) << 8 | s[e + 4];
        switch (s[e]) {
        case 207:
            if (!n) {
                Fl("ADTS AAC", i);
                break
            }
        case 15:
            a.audioPid === -1 && (a.audioPid = u);
            break;
        case 21:
            a.id3Pid === -1 && (a.id3Pid = u);
            break;
        case 219:
            if (!n) {
                Fl("H.264", i);
                break
            }
        case 27:
            a.videoPid === -1 && (a.videoPid = u);
            break;
        case 3:
        case 4:
            !t.mpeg && !t.mp3 ? i.log("MPEG audio found, not supported in this browser") : a.audioPid === -1 && (a.audioPid = u,
            a.segmentAudioCodec = "mp3");
            break;
        case 193:
            if (!n) {
                Fl("AC-3", i);
                break
            }
        case 129:
            t.ac3 ? a.audioPid === -1 && (a.audioPid = u,
            a.segmentAudioCodec = "ac3") : i.log("AC-3 audio found, not supported in this browser");
            break;
        case 6:
            if (a.audioPid === -1 && d > 0) {
                let h = e + 5
                  , f = d;
                for (; f > 2; ) {
                    switch (s[h]) {
                    case 106:
                        t.ac3 !== !0 ? i.log("AC-3 audio found, not supported in this browser for now") : (a.audioPid = u,
                        a.segmentAudioCodec = "ac3");
                        break
                    }
                    const p = s[h + 1] + 2;
                    h += p,
                    f -= p
                }
            }
            break;
        case 194:
        case 135:
            return nu(r, new Error("Unsupported EC-3 in M2TS found"), void 0, i),
            a;
        case 36:
            a.videoPid === -1 && (a.videoPid = u,
            a.segmentVideoCodec = "hevc",
            i.log("HEVC in M2TS found"));
            break
        }
        e += d + 5
    }
    return a
}
function nu(s, e, t, n) {
    n.warn(`parsing error: ${e.message}`),
    s.emit(S.ERROR, S.ERROR, {
        type: q.MEDIA_ERROR,
        details: N.FRAG_PARSING_ERROR,
        fatal: !1,
        levelRetry: t,
        error: e,
        reason: e.message
    })
}
function Fl(s, e) {
    e.log(`${s} with AES-128-CBC encryption found in unencrypted stream`)
}
function Gn(s, e) {
    let t = 0, n, r, i, a, o;
    const l = s.data;
    if (!s || s.size === 0)
        return null;
    for (; l[0].length < 19 && l.length > 1; )
        l[0] = jt(l[0], l[1]),
        l.splice(1, 1);
    if (n = l[0],
    (n[0] << 16) + (n[1] << 8) + n[2] === 1) {
        if (r = (n[4] << 8) + n[5],
        r && r > s.size - 6)
            return null;
        const u = n[7];
        u & 192 && (a = (n[9] & 14) * 536870912 + (n[10] & 255) * 4194304 + (n[11] & 254) * 16384 + (n[12] & 255) * 128 + (n[13] & 254) / 2,
        u & 64 ? (o = (n[14] & 14) * 536870912 + (n[15] & 255) * 4194304 + (n[16] & 254) * 16384 + (n[17] & 255) * 128 + (n[18] & 254) / 2,
        a - o > 60 * 9e4 && (e.warn(`${Math.round((a - o) / 9e4)}s delta between PTS and DTS, align them`),
        a = o)) : o = a),
        i = n[8];
        let d = i + 9;
        if (s.size <= d)
            return null;
        s.size -= d;
        const h = new Uint8Array(s.size);
        for (let f = 0, m = l.length; f < m; f++) {
            n = l[f];
            let p = n.byteLength;
            if (d)
                if (d > p) {
                    d -= p;
                    continue
                } else
                    n = n.subarray(d),
                    p -= d,
                    d = 0;
            h.set(n, t),
            t += p
        }
        return r && (r -= i + 3),
        {
            data: h,
            pts: a,
            dts: o,
            len: r
        }
    }
    return null
}
class aL {
    static getSilentFrame(e, t) {
        switch (e) {
        case "mp4a.40.2":
            if (t === 1)
                return new Uint8Array([0, 200, 0, 128, 35, 128]);
            if (t === 2)
                return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
            if (t === 3)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
            if (t === 4)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
            if (t === 5)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
            if (t === 6)
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
            break;
        default:
            if (t === 1)
                return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            if (t === 2)
                return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            if (t === 3)
                return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
            break
        }
    }
}
const Bs = Math.pow(2, 32) - 1;
class P {
    static init() {
        P.types = {
            avc1: [],
            avcC: [],
            hvc1: [],
            hvcC: [],
            btrt: [],
            dinf: [],
            dref: [],
            esds: [],
            ftyp: [],
            hdlr: [],
            mdat: [],
            mdhd: [],
            mdia: [],
            mfhd: [],
            minf: [],
            moof: [],
            moov: [],
            mp4a: [],
            ".mp3": [],
            dac3: [],
            "ac-3": [],
            mvex: [],
            mvhd: [],
            pasp: [],
            sdtp: [],
            stbl: [],
            stco: [],
            stsc: [],
            stsd: [],
            stsz: [],
            stts: [],
            tfdt: [],
            tfhd: [],
            traf: [],
            trak: [],
            trun: [],
            trex: [],
            tkhd: [],
            vmhd: [],
            smhd: []
        };
        let e;
        for (e in P.types)
            P.types.hasOwnProperty(e) && (P.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
        const t = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0])
          , n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
        P.HDLR_TYPES = {
            video: t,
            audio: n
        };
        const r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1])
          , i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
        P.STTS = P.STSC = P.STCO = i,
        P.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
        P.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]),
        P.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]),
        P.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
        const a = new Uint8Array([105, 115, 111, 109])
          , o = new Uint8Array([97, 118, 99, 49])
          , l = new Uint8Array([0, 0, 0, 1]);
        P.FTYP = P.box(P.types.ftyp, a, l, a, o),
        P.DINF = P.box(P.types.dinf, P.box(P.types.dref, r))
    }
    static box(e, ...t) {
        let n = 8
          , r = t.length;
        const i = r;
        for (; r--; )
            n += t[r].byteLength;
        const a = new Uint8Array(n);
        for (a[0] = n >> 24 & 255,
        a[1] = n >> 16 & 255,
        a[2] = n >> 8 & 255,
        a[3] = n & 255,
        a.set(e, 4),
        r = 0,
        n = 8; r < i; r++)
            a.set(t[r], n),
            n += t[r].byteLength;
        return a
    }
    static hdlr(e) {
        return P.box(P.types.hdlr, P.HDLR_TYPES[e])
    }
    static mdat(e) {
        return P.box(P.types.mdat, e)
    }
    static mdhd(e, t) {
        t *= e;
        const n = Math.floor(t / (Bs + 1))
          , r = Math.floor(t % (Bs + 1));
        return P.box(P.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, n >> 24, n >> 16 & 255, n >> 8 & 255, n & 255, r >> 24, r >> 16 & 255, r >> 8 & 255, r & 255, 85, 196, 0, 0]))
    }
    static mdia(e) {
        return P.box(P.types.mdia, P.mdhd(e.timescale || 0, e.duration || 0), P.hdlr(e.type), P.minf(e))
    }
    static mfhd(e) {
        return P.box(P.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, e & 255]))
    }
    static minf(e) {
        return e.type === "audio" ? P.box(P.types.minf, P.box(P.types.smhd, P.SMHD), P.DINF, P.stbl(e)) : P.box(P.types.minf, P.box(P.types.vmhd, P.VMHD), P.DINF, P.stbl(e))
    }
    static moof(e, t, n) {
        return P.box(P.types.moof, P.mfhd(e), P.traf(n, t))
    }
    static moov(e) {
        let t = e.length;
        const n = [];
        for (; t--; )
            n[t] = P.trak(e[t]);
        return P.box.apply(null, [P.types.moov, P.mvhd(e[0].timescale || 0, e[0].duration || 0)].concat(n).concat(P.mvex(e)))
    }
    static mvex(e) {
        let t = e.length;
        const n = [];
        for (; t--; )
            n[t] = P.trex(e[t]);
        return P.box.apply(null, [P.types.mvex, ...n])
    }
    static mvhd(e, t) {
        t *= e;
        const n = Math.floor(t / (Bs + 1))
          , r = Math.floor(t % (Bs + 1))
          , i = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, n >> 24, n >> 16 & 255, n >> 8 & 255, n & 255, r >> 24, r >> 16 & 255, r >> 8 & 255, r & 255, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
        return P.box(P.types.mvhd, i)
    }
    static sdtp(e) {
        const t = e.samples || []
          , n = new Uint8Array(4 + t.length);
        let r, i;
        for (r = 0; r < t.length; r++)
            i = t[r].flags,
            n[r + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy;
        return P.box(P.types.sdtp, n)
    }
    static stbl(e) {
        return P.box(P.types.stbl, P.stsd(e), P.box(P.types.stts, P.STTS), P.box(P.types.stsc, P.STSC), P.box(P.types.stsz, P.STSZ), P.box(P.types.stco, P.STCO))
    }
    static avc1(e) {
        let t = [], n = [], r, i, a;
        for (r = 0; r < e.sps.length; r++)
            i = e.sps[r],
            a = i.byteLength,
            t.push(a >>> 8 & 255),
            t.push(a & 255),
            t = t.concat(Array.prototype.slice.call(i));
        for (r = 0; r < e.pps.length; r++)
            i = e.pps[r],
            a = i.byteLength,
            n.push(a >>> 8 & 255),
            n.push(a & 255),
            n = n.concat(Array.prototype.slice.call(i));
        const o = P.box(P.types.avcC, new Uint8Array([1, t[3], t[4], t[5], 255, 224 | e.sps.length].concat(t).concat([e.pps.length]).concat(n)))
          , l = e.width
          , c = e.height
          , u = e.pixelRatio[0]
          , d = e.pixelRatio[1];
        return P.box(P.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, l & 255, c >> 8 & 255, c & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, P.box(P.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), P.box(P.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, u & 255, d >> 24, d >> 16 & 255, d >> 8 & 255, d & 255])))
    }
    static esds(e) {
        const t = e.config;
        return new Uint8Array([0, 0, 0, 0, 3, 25, 0, 1, 0, 4, 17, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, ...t, 6, 1, 2])
    }
    static audioStsd(e) {
        const t = e.samplerate || 0;
        return new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount || 0, 0, 16, 0, 0, 0, 0, t >> 8 & 255, t & 255, 0, 0])
    }
    static mp4a(e) {
        return P.box(P.types.mp4a, P.audioStsd(e), P.box(P.types.esds, P.esds(e)))
    }
    static mp3(e) {
        return P.box(P.types[".mp3"], P.audioStsd(e))
    }
    static ac3(e) {
        return P.box(P.types["ac-3"], P.audioStsd(e), P.box(P.types.dac3, e.config))
    }
    static stsd(e) {
        const {segmentCodec: t} = e;
        if (e.type === "audio") {
            if (t === "aac")
                return P.box(P.types.stsd, P.STSD, P.mp4a(e));
            if (t === "ac3" && e.config)
                return P.box(P.types.stsd, P.STSD, P.ac3(e));
            if (t === "mp3" && e.codec === "mp3")
                return P.box(P.types.stsd, P.STSD, P.mp3(e))
        } else if (e.pps && e.sps) {
            if (t === "avc")
                return P.box(P.types.stsd, P.STSD, P.avc1(e));
            if (t === "hevc" && e.vps)
                return P.box(P.types.stsd, P.STSD, P.hvc1(e))
        } else
            throw new Error("video track missing pps or sps");
        throw new Error(`unsupported ${e.type} segment codec (${t}/${e.codec})`)
    }
    static tkhd(e) {
        const t = e.id
          , n = (e.duration || 0) * (e.timescale || 0)
          , r = e.width || 0
          , i = e.height || 0
          , a = Math.floor(n / (Bs + 1))
          , o = Math.floor(n % (Bs + 1));
        return P.box(P.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, t & 255, 0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, a & 255, o >> 24, o >> 16 & 255, o >> 8 & 255, o & 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, r >> 8 & 255, r & 255, 0, 0, i >> 8 & 255, i & 255, 0, 0]))
    }
    static traf(e, t) {
        const n = P.sdtp(e)
          , r = e.id
          , i = Math.floor(t / (Bs + 1))
          , a = Math.floor(t % (Bs + 1));
        return P.box(P.types.traf, P.box(P.types.tfhd, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, r & 255])), P.box(P.types.tfdt, new Uint8Array([1, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, i & 255, a >> 24, a >> 16 & 255, a >> 8 & 255, a & 255])), P.trun(e, n.length + 16 + 20 + 8 + 16 + 8 + 8), n)
    }
    static trak(e) {
        return e.duration = e.duration || 4294967295,
        P.box(P.types.trak, P.tkhd(e), P.mdia(e))
    }
    static trex(e) {
        const t = e.id;
        return P.box(P.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, t & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
    }
    static trun(e, t) {
        const n = e.samples || []
          , r = n.length
          , i = 12 + 16 * r
          , a = new Uint8Array(i);
        let o, l, c, u, d, h;
        for (t += 8 + i,
        a.set([e.type === "video" ? 1 : 0, 0, 15, 1, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, r & 255, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t & 255], 0),
        o = 0; o < r; o++)
            l = n[o],
            c = l.duration,
            u = l.size,
            d = l.flags,
            h = l.cts,
            a.set([c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, c & 255, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, u & 255, d.isLeading << 2 | d.dependsOn, d.isDependedOn << 6 | d.hasRedundancy << 4 | d.paddingValue << 1 | d.isNonSync, d.degradPrio & 61440, d.degradPrio & 15, h >>> 24 & 255, h >>> 16 & 255, h >>> 8 & 255, h & 255], 12 + 16 * o);
        return P.box(P.types.trun, a)
    }
    static initSegment(e) {
        P.types || P.init();
        const t = P.moov(e);
        return jt(P.FTYP, t)
    }
    static hvc1(e) {
        const t = e.params
          , n = [e.vps, e.sps, e.pps]
          , r = 4
          , i = new Uint8Array([1, t.general_profile_space << 6 | (t.general_tier_flag ? 32 : 0) | t.general_profile_idc, t.general_profile_compatibility_flags[0], t.general_profile_compatibility_flags[1], t.general_profile_compatibility_flags[2], t.general_profile_compatibility_flags[3], t.general_constraint_indicator_flags[0], t.general_constraint_indicator_flags[1], t.general_constraint_indicator_flags[2], t.general_constraint_indicator_flags[3], t.general_constraint_indicator_flags[4], t.general_constraint_indicator_flags[5], t.general_level_idc, 240 | t.min_spatial_segmentation_idc >> 8, 255 & t.min_spatial_segmentation_idc, 252 | t.parallelismType, 252 | t.chroma_format_idc, 248 | t.bit_depth_luma_minus8, 248 | t.bit_depth_chroma_minus8, 0, parseInt(t.frame_rate.fps), r - 1 | t.temporal_id_nested << 2 | t.num_temporal_layers << 3 | (t.frame_rate.fixed ? 64 : 0), n.length]);
        let a = i.length;
        for (let m = 0; m < n.length; m += 1) {
            a += 3;
            for (let p = 0; p < n[m].length; p += 1)
                a += 2 + n[m][p].length
        }
        const o = new Uint8Array(a);
        o.set(i, 0),
        a = i.length;
        const l = n.length - 1;
        for (let m = 0; m < n.length; m += 1) {
            o.set(new Uint8Array([32 + m | (m === l ? 128 : 0), 0, n[m].length]), a),
            a += 3;
            for (let p = 0; p < n[m].length; p += 1)
                o.set(new Uint8Array([n[m][p].length >> 8, n[m][p].length & 255]), a),
                a += 2,
                o.set(n[m][p], a),
                a += n[m][p].length
        }
        const c = P.box(P.types.hvcC, o)
          , u = e.width
          , d = e.height
          , h = e.pixelRatio[0]
          , f = e.pixelRatio[1];
        return P.box(P.types.hvc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, u >> 8 & 255, u & 255, d >> 8 & 255, d & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), c, P.box(P.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), P.box(P.types.pasp, new Uint8Array([h >> 24, h >> 16 & 255, h >> 8 & 255, h & 255, f >> 24, f >> 16 & 255, f >> 8 & 255, f & 255])))
    }
}
P.types = void 0;
P.HDLR_TYPES = void 0;
P.STTS = void 0;
P.STSC = void 0;
P.STCO = void 0;
P.STSZ = void 0;
P.VMHD = void 0;
P.SMHD = void 0;
P.STSD = void 0;
P.FTYP = void 0;
P.DINF = void 0;
const j0 = 9e4;
function wd(s, e, t=1, n=!1) {
    const r = s * e * t;
    return n ? Math.round(r) : r
}
function oL(s, e, t=1, n=!1) {
    return wd(s, e, 1 / t, n)
}
function Gr(s, e=!1) {
    return wd(s, 1e3, 1 / j0, e)
}
function lL(s, e=1) {
    return wd(s, j0, 1 / e)
}
const cL = 10 * 1e3
  , uL = 1024
  , dL = 1152
  , hL = 1536;
let Vn = null
  , Ul = null;
function jf(s, e, t, n) {
    return {
        duration: e,
        size: t,
        cts: n,
        flags: {
            isLeading: 0,
            isDependedOn: 0,
            hasRedundancy: 0,
            degradPrio: 0,
            dependsOn: s ? 2 : 1,
            isNonSync: s ? 0 : 1
        }
    }
}
class Ba extends Gt {
    constructor(e, t, n, r) {
        if (super("mp4-remuxer", r),
        this.observer = void 0,
        this.config = void 0,
        this.typeSupported = void 0,
        this.ISGenerated = !1,
        this._initPTS = null,
        this._initDTS = null,
        this.nextVideoTs = null,
        this.nextAudioTs = null,
        this.videoSampleDuration = null,
        this.isAudioContiguous = !1,
        this.isVideoContiguous = !1,
        this.videoTrackConfig = void 0,
        this.observer = e,
        this.config = t,
        this.typeSupported = n,
        this.ISGenerated = !1,
        Vn === null) {
            const a = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
            Vn = a ? parseInt(a[1]) : 0
        }
        if (Ul === null) {
            const i = navigator.userAgent.match(/Safari\/(\d+)/i);
            Ul = i ? parseInt(i[1]) : 0
        }
    }
    destroy() {
        this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null
    }
    resetTimeStamp(e) {
        this.log("initPTS & initDTS reset"),
        this._initPTS = this._initDTS = e
    }
    resetNextTimestamp() {
        this.log("reset next timestamp"),
        this.isVideoContiguous = !1,
        this.isAudioContiguous = !1
    }
    resetInitSegment() {
        this.log("ISGenerated flag reset"),
        this.ISGenerated = !1,
        this.videoTrackConfig = void 0
    }
    getVideoStartPts(e) {
        let t = !1;
        const n = e[0].pts
          , r = e.reduce( (i, a) => {
            let o = a.pts
              , l = o - i;
            return l < -4294967296 && (t = !0,
            o = Pt(o, n),
            l = o - i),
            l > 0 ? i : o
        }
        , n);
        return t && this.debug("PTS rollover detected"),
        r
    }
    remux(e, t, n, r, i, a, o, l) {
        let c, u, d, h, f, m, p = i, x = i;
        const y = e.pid > -1
          , v = t.pid > -1
          , E = t.samples.length
          , T = e.samples.length > 0
          , L = o && E > 0 || E > 1;
        if ((!y || T) && (!v || L) || this.ISGenerated || o) {
            if (this.ISGenerated) {
                var I, A, C, b;
                const K = this.videoTrackConfig;
                (K && (t.width !== K.width || t.height !== K.height || ((I = t.pixelRatio) == null ? void 0 : I[0]) !== ((A = K.pixelRatio) == null ? void 0 : A[0]) || ((C = t.pixelRatio) == null ? void 0 : C[1]) !== ((b = K.pixelRatio) == null ? void 0 : b[1])) || !K && L || this.nextAudioTs === null && T) && this.resetInitSegment()
            }
            this.ISGenerated || (d = this.generateIS(e, t, i, a));
            const O = this.isVideoContiguous;
            let _ = -1, $;
            if (L && (_ = fL(t.samples),
            !O && this.config.forceKeyFrameOnDiscontinuity))
                if (m = !0,
                _ > 0) {
                    this.warn(`Dropped ${_} out of ${E} video samples due to a missing keyframe`);
                    const K = this.getVideoStartPts(t.samples);
                    t.samples = t.samples.slice(_),
                    t.dropped += _,
                    x += (t.samples[0].pts - K) / t.inputTimeScale,
                    $ = x
                } else
                    _ === -1 && (this.warn(`No keyframe found out of ${E} video samples`),
                    m = !1);
            if (this.ISGenerated) {
                if (T && L) {
                    const K = this.getVideoStartPts(t.samples)
                      , G = (Pt(e.samples[0].pts, K) - K) / t.inputTimeScale;
                    p += Math.max(0, G),
                    x += Math.max(0, -G)
                }
                if (T) {
                    if (e.samplerate || (this.warn("regenerate InitSegment as audio detected"),
                    d = this.generateIS(e, t, i, a)),
                    u = this.remuxAudio(e, p, this.isAudioContiguous, a, v || L || l === X.AUDIO ? x : void 0),
                    L) {
                        const K = u ? u.endPTS - u.startPTS : 0;
                        t.inputTimeScale || (this.warn("regenerate InitSegment as video detected"),
                        d = this.generateIS(e, t, i, a)),
                        c = this.remuxVideo(t, x, O, K)
                    }
                } else
                    L && (c = this.remuxVideo(t, x, O, 0));
                c && (c.firstKeyFrame = _,
                c.independent = _ !== -1,
                c.firstKeyFramePTS = $)
            }
        }
        return this.ISGenerated && this._initPTS && this._initDTS && (n.samples.length && (f = G0(n, i, this._initPTS, this._initDTS)),
        r.samples.length && (h = V0(r, i, this._initPTS))),
        {
            audio: u,
            video: c,
            initSegment: d,
            independent: m,
            text: h,
            id3: f
        }
    }
    generateIS(e, t, n, r) {
        const i = e.samples
          , a = t.samples
          , o = this.typeSupported
          , l = {}
          , c = this._initPTS;
        let u = !c || r, d = "audio/mp4", h, f, m, p = -1;
        if (u && (h = f = 1 / 0),
        e.config && i.length) {
            switch (e.timescale = e.samplerate,
            e.segmentCodec) {
            case "mp3":
                o.mpeg ? (d = "audio/mpeg",
                e.codec = "") : o.mp3 && (e.codec = "mp3");
                break;
            case "ac3":
                e.codec = "ac-3";
                break
            }
            l.audio = {
                id: "audio",
                container: d,
                codec: e.codec,
                initSegment: e.segmentCodec === "mp3" && o.mpeg ? new Uint8Array(0) : P.initSegment([e]),
                metadata: {
                    channelCount: e.channelCount
                }
            },
            u && (p = e.id,
            m = e.inputTimeScale,
            !c || m !== c.timescale ? h = f = i[0].pts - Math.round(m * n) : u = !1)
        }
        if (t.sps && t.pps && a.length) {
            if (t.timescale = t.inputTimeScale,
            l.video = {
                id: "main",
                container: "video/mp4",
                codec: t.codec,
                initSegment: P.initSegment([t]),
                metadata: {
                    width: t.width,
                    height: t.height
                }
            },
            u)
                if (p = t.id,
                m = t.inputTimeScale,
                !c || m !== c.timescale) {
                    const x = this.getVideoStartPts(a)
                      , y = Math.round(m * n);
                    f = Math.min(f, Pt(a[0].dts, x) - y),
                    h = Math.min(h, x - y)
                } else
                    u = !1;
            this.videoTrackConfig = {
                width: t.width,
                height: t.height,
                pixelRatio: t.pixelRatio
            }
        }
        if (Object.keys(l).length)
            return this.ISGenerated = !0,
            u ? (c && this.warn(`Timestamps at playlist time: ${r ? "" : "~"}${n} ${h / m} != initPTS: ${c.baseTime / c.timescale} (${c.baseTime}/${c.timescale}) trackId: ${c.trackId}`),
            this.log(`Found initPTS at playlist time: ${n} offset: ${h / m} (${h}/${m}) trackId: ${p}`),
            this._initPTS = {
                baseTime: h,
                timescale: m,
                trackId: p
            },
            this._initDTS = {
                baseTime: f,
                timescale: m,
                trackId: p
            }) : h = m = void 0,
            {
                tracks: l,
                initPTS: h,
                timescale: m,
                trackId: p
            }
    }
    remuxVideo(e, t, n, r) {
        const i = e.inputTimeScale
          , a = e.samples
          , o = []
          , l = a.length
          , c = this._initPTS
          , u = c.baseTime * i / c.timescale;
        let d = this.nextVideoTs, h = 8, f = this.videoSampleDuration, m, p, x = Number.POSITIVE_INFINITY, y = Number.NEGATIVE_INFINITY, v = !1;
        if (!n || d === null) {
            const F = u + t * i
              , j = a[0].pts - Pt(a[0].dts, a[0].pts);
            Vn && d !== null && Math.abs(F - j - (d + u)) < 15e3 ? n = !0 : d = F - j - u
        }
        const E = d + u;
        for (let F = 0; F < l; F++) {
            const j = a[F];
            j.pts = Pt(j.pts, E),
            j.dts = Pt(j.dts, E),
            j.dts < a[F > 0 ? F - 1 : F].dts && (v = !0)
        }
        v && a.sort(function(F, j) {
            const J = F.dts - j.dts
              , re = F.pts - j.pts;
            return J || re
        }),
        m = a[0].dts,
        p = a[a.length - 1].dts;
        const T = p - m
          , L = T ? Math.round(T / (l - 1)) : f || e.inputTimeScale / 30;
        if (n) {
            const F = m - E
              , j = F > L
              , J = F < -1;
            if ((j || J) && (j ? this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${Gr(F, !0)} ms (${F}dts) hole between fragments detected at ${t.toFixed(3)}`) : this.warn(`${(e.segmentCodec || "").toUpperCase()}: ${Gr(-F, !0)} ms (${F}dts) overlapping between fragments detected at ${t.toFixed(3)}`),
            !J || E >= a[0].pts || Vn)) {
                m = E;
                const re = a[0].pts - F;
                if (j)
                    a[0].dts = m,
                    a[0].pts = re;
                else {
                    let Q = !0;
                    for (let se = 0; se < a.length && !(a[se].dts > re && Q); se++) {
                        const Le = a[se].pts;
                        if (a[se].dts -= F,
                        a[se].pts -= F,
                        se < a.length - 1) {
                            const ke = a[se + 1].pts
                              , Ne = a[se].pts
                              , Dt = ke <= Ne
                              , Oe = ke <= Le;
                            Q = Dt == Oe
                        }
                    }
                }
                this.log(`Video: Initial PTS/DTS adjusted: ${Gr(re, !0)}/${Gr(m, !0)}, delta: ${Gr(F, !0)} ms`)
            }
        }
        m = Math.max(0, m);
        let R = 0
          , I = 0
          , A = m;
        for (let F = 0; F < l; F++) {
            const j = a[F]
              , J = j.units
              , re = J.length;
            let Q = 0;
            for (let se = 0; se < re; se++)
                Q += J[se].data.length;
            I += Q,
            R += re,
            j.length = Q,
            j.dts < A ? (j.dts = A,
            A += L / 4 | 0 || 1) : A = j.dts,
            x = Math.min(j.pts, x),
            y = Math.max(j.pts, y)
        }
        p = a[l - 1].dts;
        const C = I + 4 * R + 8;
        let b;
        try {
            b = new Uint8Array(C)
        } catch (F) {
            this.observer.emit(S.ERROR, S.ERROR, {
                type: q.MUX_ERROR,
                details: N.REMUX_ALLOC_ERROR,
                fatal: !1,
                error: F,
                bytes: C,
                reason: `fail allocating video mdat ${C}`
            });
            return
        }
        const O = new DataView(b.buffer);
        O.setUint32(0, C),
        b.set(P.types.mdat, 4);
        let _ = !1
          , $ = Number.POSITIVE_INFINITY
          , K = Number.POSITIVE_INFINITY
          , W = Number.NEGATIVE_INFINITY
          , G = Number.NEGATIVE_INFINITY;
        for (let F = 0; F < l; F++) {
            const j = a[F]
              , J = j.units;
            let re = 0;
            for (let Le = 0, ke = J.length; Le < ke; Le++) {
                const Ne = J[Le]
                  , Dt = Ne.data
                  , Oe = Ne.data.byteLength;
                O.setUint32(h, Oe),
                h += 4,
                b.set(Dt, h),
                h += Oe,
                re += 4 + Oe
            }
            let Q;
            if (F < l - 1)
                f = a[F + 1].dts - j.dts,
                Q = a[F + 1].pts - j.pts;
            else {
                const Le = this.config
                  , ke = F > 0 ? j.dts - a[F - 1].dts : L;
                if (Q = F > 0 ? j.pts - a[F - 1].pts : L,
                Le.stretchShortVideoTrack && this.nextAudioTs !== null) {
                    const Ne = Math.floor(Le.maxBufferHole * i)
                      , Dt = (r ? x + r * i : this.nextAudioTs + u) - j.pts;
                    Dt > Ne ? (f = Dt - ke,
                    f < 0 ? f = ke : _ = !0,
                    this.log(`It is approximately ${Dt / 90} ms to the next segment; using duration ${f / 90} ms for the last video frame.`)) : f = ke
                } else
                    f = ke
            }
            const se = Math.round(j.pts - j.dts);
            $ = Math.min($, f),
            W = Math.max(W, f),
            K = Math.min(K, Q),
            G = Math.max(G, Q),
            o.push(jf(j.key, f, re, se))
        }
        if (o.length) {
            if (Vn) {
                if (Vn < 70) {
                    const F = o[0].flags;
                    F.dependsOn = 2,
                    F.isNonSync = 0
                }
            } else if (Ul && G - K < W - $ && L / W < .025 && o[0].cts === 0) {
                this.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                let F = m;
                for (let j = 0, J = o.length; j < J; j++) {
                    const re = F + o[j].duration
                      , Q = F + o[j].cts;
                    if (j < J - 1) {
                        const se = re + o[j + 1].cts;
                        o[j].duration = se - Q
                    } else
                        o[j].duration = j ? o[j - 1].duration : L;
                    o[j].cts = 0,
                    F = re
                }
            }
        }
        f = _ || !f ? L : f;
        const V = p + f;
        this.nextVideoTs = d = V - u,
        this.videoSampleDuration = f,
        this.isVideoContiguous = !0;
        const k = {
            data1: P.moof(e.sequenceNumber++, m, ye(e, {
                samples: o
            })),
            data2: b,
            startPTS: (x - u) / i,
            endPTS: (y + f - u) / i,
            startDTS: (m - u) / i,
            endDTS: d / i,
            type: "video",
            hasAudio: !1,
            hasVideo: !0,
            nb: o.length,
            dropped: e.dropped
        };
        return e.samples = [],
        e.dropped = 0,
        k
    }
    getSamplesPerFrame(e) {
        switch (e.segmentCodec) {
        case "mp3":
            return dL;
        case "ac3":
            return hL;
        default:
            return uL
        }
    }
    remuxAudio(e, t, n, r, i) {
        const a = e.inputTimeScale
          , o = e.samplerate ? e.samplerate : a
          , l = a / o
          , c = this.getSamplesPerFrame(e)
          , u = c * l
          , d = this._initPTS
          , h = e.segmentCodec === "mp3" && this.typeSupported.mpeg
          , f = []
          , m = i !== void 0;
        let p = e.samples
          , x = h ? 0 : 8
          , y = this.nextAudioTs || -1;
        const v = d.baseTime * a / d.timescale
          , E = v + t * a;
        if (this.isAudioContiguous = n = n || p.length && y > 0 && (r && Math.abs(E - (y + v)) < 9e3 || Math.abs(Pt(p[0].pts, E) - (y + v)) < 20 * u),
        p.forEach(function(G) {
            G.pts = Pt(G.pts, E)
        }),
        !n || y < 0) {
            if (p = p.filter(G => G.pts >= 0),
            !p.length)
                return;
            i === 0 ? y = 0 : r && !m ? y = Math.max(0, E - v) : y = p[0].pts - v
        }
        if (e.segmentCodec === "aac") {
            const G = this.config.maxAudioFramesDrift;
            for (let V = 0, D = y + v; V < p.length; V++) {
                const B = p[V]
                  , k = B.pts
                  , F = k - D
                  , j = Math.abs(1e3 * F / a);
                if (F <= -G * u && m)
                    V === 0 && (this.warn(`Audio frame @ ${(k / a).toFixed(3)}s overlaps marker by ${Math.round(1e3 * F / a)} ms.`),
                    this.nextAudioTs = y = k - v,
                    D = k);
                else if (F >= G * u && j < cL && m) {
                    let J = Math.round(F / u);
                    for (D = k - J * u; D < 0 && J && u; )
                        J--,
                        D += u;
                    V === 0 && (this.nextAudioTs = y = D - v),
                    this.warn(`Injecting ${J} audio frames @ ${((D - v) / a).toFixed(3)}s due to ${Math.round(1e3 * F / a)} ms gap.`);
                    for (let re = 0; re < J; re++) {
                        let Q = aL.getSilentFrame(e.parsedCodec || e.manifestCodec || e.codec, e.channelCount);
                        Q || (this.log("Unable to get silent frame for given audio codec; duplicating last frame instead."),
                        Q = B.unit.subarray()),
                        p.splice(V, 0, {
                            unit: Q,
                            pts: D
                        }),
                        D += u,
                        V++
                    }
                }
                B.pts = D,
                D += u
            }
        }
        let T = null, L = null, R, I = 0, A = p.length;
        for (; A--; )
            I += p[A].unit.byteLength;
        for (let G = 0, V = p.length; G < V; G++) {
            const D = p[G]
              , B = D.unit;
            let k = D.pts;
            if (L !== null) {
                const j = f[G - 1];
                j.duration = Math.round((k - L) / l)
            } else if (n && e.segmentCodec === "aac" && (k = y + v),
            T = k,
            I > 0) {
                I += x;
                try {
                    R = new Uint8Array(I)
                } catch (j) {
                    this.observer.emit(S.ERROR, S.ERROR, {
                        type: q.MUX_ERROR,
                        details: N.REMUX_ALLOC_ERROR,
                        fatal: !1,
                        error: j,
                        bytes: I,
                        reason: `fail allocating audio mdat ${I}`
                    });
                    return
                }
                h || (new DataView(R.buffer).setUint32(0, I),
                R.set(P.types.mdat, 4))
            } else
                return;
            R.set(B, x);
            const F = B.byteLength;
            x += F,
            f.push(jf(!0, c, F, 0)),
            L = k
        }
        const C = f.length;
        if (!C)
            return;
        const b = f[f.length - 1];
        y = L - v,
        this.nextAudioTs = y + l * b.duration;
        const O = h ? new Uint8Array(0) : P.moof(e.sequenceNumber++, T / l, ye({}, e, {
            samples: f
        }));
        e.samples = [];
        const _ = (T - v) / a
          , $ = y / a
          , W = {
            data1: O,
            data2: R,
            startPTS: _,
            endPTS: $,
            startDTS: _,
            endDTS: $,
            type: "audio",
            hasAudio: !0,
            hasVideo: !1,
            nb: C
        };
        return this.isAudioContiguous = !0,
        W
    }
}
function Pt(s, e) {
    let t;
    if (e === null)
        return s;
    for (e < s ? t = -8589934592 : t = 8589934592; Math.abs(s - e) > 4294967296; )
        s += t;
    return s
}
function fL(s) {
    for (let e = 0; e < s.length; e++)
        if (s[e].key)
            return e;
    return -1
}
function G0(s, e, t, n) {
    const r = s.samples.length;
    if (!r)
        return;
    const i = s.inputTimeScale;
    for (let o = 0; o < r; o++) {
        const l = s.samples[o];
        l.pts = Pt(l.pts - t.baseTime * i / t.timescale, e * i) / i,
        l.dts = Pt(l.dts - n.baseTime * i / n.timescale, e * i) / i
    }
    const a = s.samples;
    return s.samples = [],
    {
        samples: a
    }
}
function V0(s, e, t) {
    const n = s.samples.length;
    if (!n)
        return;
    const r = s.inputTimeScale;
    for (let a = 0; a < n; a++) {
        const o = s.samples[a];
        o.pts = Pt(o.pts - t.baseTime * r / t.timescale, e * r) / r
    }
    s.samples.sort( (a, o) => a.pts - o.pts);
    const i = s.samples;
    return s.samples = [],
    {
        samples: i
    }
}
class mL extends Gt {
    constructor(e, t, n, r) {
        super("passthrough-remuxer", r),
        this.emitInitSegment = !1,
        this.audioCodec = void 0,
        this.videoCodec = void 0,
        this.initData = void 0,
        this.initPTS = null,
        this.initTracks = void 0,
        this.lastEndTime = null,
        this.isVideoContiguous = !1
    }
    destroy() {}
    resetTimeStamp(e) {
        this.lastEndTime = null;
        const t = this.initPTS;
        t && e && t.baseTime === e.baseTime && t.timescale === e.timescale || (this.initPTS = e)
    }
    resetNextTimestamp() {
        this.isVideoContiguous = !1,
        this.lastEndTime = null
    }
    resetInitSegment(e, t, n, r) {
        this.audioCodec = t,
        this.videoCodec = n,
        this.generateInitSegment(e, r),
        this.emitInitSegment = !0
    }
    generateInitSegment(e, t) {
        let {audioCodec: n, videoCodec: r} = this;
        if (!(e != null && e.byteLength)) {
            this.initTracks = void 0,
            this.initData = void 0;
            return
        }
        const {audio: i, video: a} = this.initData = e0(e);
        if (t)
            sT(e, t);
        else {
            const l = i || a;
            l != null && l.encrypted && this.warn(`Init segment with encrypted track with has no key ("${l.codec}")!`)
        }
        i && (n = Gf(i, xe.AUDIO, this)),
        a && (r = Gf(a, xe.VIDEO, this));
        const o = {};
        i && a ? o.audiovideo = {
            container: "video/mp4",
            codec: n + "," + r,
            supplemental: a.supplemental,
            encrypted: a.encrypted,
            initSegment: e,
            id: "main"
        } : i ? o.audio = {
            container: "audio/mp4",
            codec: n,
            encrypted: i.encrypted,
            initSegment: e,
            id: "audio"
        } : a ? o.video = {
            container: "video/mp4",
            codec: r,
            supplemental: a.supplemental,
            encrypted: a.encrypted,
            initSegment: e,
            id: "main"
        } : this.warn("initSegment does not contain moov or trak boxes."),
        this.initTracks = o
    }
    remux(e, t, n, r, i, a) {
        var o, l;
        let {initPTS: c, lastEndTime: u} = this;
        const d = {
            audio: void 0,
            video: void 0,
            text: r,
            id3: n,
            initSegment: void 0
        };
        z(u) || (u = this.lastEndTime = i || 0);
        const h = t.samples;
        if (!h.length)
            return d;
        const f = {
            initPTS: void 0,
            timescale: void 0,
            trackId: void 0
        };
        let m = this.initData;
        if ((o = m) != null && o.length || (this.generateInitSegment(h),
        m = this.initData),
        !((l = m) != null && l.length))
            return this.warn("Failed to generate initSegment."),
            d;
        this.emitInitSegment && (f.tracks = this.initTracks,
        this.emitInitSegment = !1);
        const p = nT(h, m, this)
          , x = m.audio ? p[m.audio.id] : null
          , y = m.video ? p[m.video.id] : null
          , v = ma(y, 1 / 0)
          , E = ma(x, 1 / 0)
          , T = ma(y, 0, !0)
          , L = ma(x, 0, !0);
        let R = i
          , I = 0;
        const A = x && (!y || !c && E < v || c && c.trackId === m.audio.id)
          , C = A ? x : y;
        if (C) {
            const D = C.timescale
              , B = C.start - i * D
              , k = A ? m.audio.id : m.video.id;
            R = C.start / D,
            I = A ? L - E : T - v,
            (a || !c) && (gL(c, R, i, I) || D !== c.timescale) && (c && this.warn(`Timestamps at playlist time: ${a ? "" : "~"}${i} ${B / D} != initPTS: ${c.baseTime / c.timescale} (${c.baseTime}/${c.timescale}) trackId: ${c.trackId}`),
            this.log(`Found initPTS at playlist time: ${i} offset: ${R - i} (${B}/${D}) trackId: ${k}`),
            c = null,
            f.initPTS = B,
            f.timescale = D,
            f.trackId = k)
        } else
            this.warn(`No audio or video samples found for initPTS at playlist time: ${i}`);
        c ? (f.initPTS = c.baseTime,
        f.timescale = c.timescale,
        f.trackId = c.trackId) : ((!f.timescale || f.trackId === void 0 || f.initPTS === void 0) && (this.warn("Could not set initPTS"),
        f.initPTS = R,
        f.timescale = 1,
        f.trackId = -1),
        this.initPTS = c = {
            baseTime: f.initPTS,
            timescale: f.timescale,
            trackId: f.trackId
        });
        const b = R - c.baseTime / c.timescale
          , O = b + I;
        I > 0 ? this.lastEndTime = O : (this.warn("Duration parsed from mp4 should be greater than zero"),
        this.resetNextTimestamp());
        const _ = !!m.audio
          , $ = !!m.video;
        let K = "";
        _ && (K += "audio"),
        $ && (K += "video");
        const W = (m.audio ? m.audio.encrypted : !1) || (m.video ? m.video.encrypted : !1)
          , G = {
            data1: h,
            startPTS: b,
            startDTS: b,
            endPTS: O,
            endDTS: O,
            type: K,
            hasAudio: _,
            hasVideo: $,
            nb: 1,
            dropped: 0,
            encrypted: W
        };
        d.audio = _ && !$ ? G : void 0,
        d.video = $ ? G : void 0;
        const V = y == null ? void 0 : y.sampleCount;
        if (V) {
            const D = y.keyFrameIndex
              , B = D !== -1;
            G.nb = V,
            G.dropped = D === 0 || this.isVideoContiguous ? 0 : B ? D : V,
            G.independent = B,
            G.firstKeyFrame = D,
            B && y.keyFrameStart && (G.firstKeyFramePTS = (y.keyFrameStart - c.baseTime) / c.timescale),
            this.isVideoContiguous || (d.independent = B),
            this.isVideoContiguous || (this.isVideoContiguous = B),
            G.dropped && this.warn(`fmp4 does not start with IDR: firstIDR ${D}/${V} dropped: ${G.dropped} start: ${G.firstKeyFramePTS || "NA"}`)
        }
        return d.initSegment = f,
        d.id3 = G0(n, i, c, c),
        r.samples.length && (d.text = V0(r, i, c)),
        d
    }
}
function ma(s, e, t=!1) {
    return (s == null ? void 0 : s.start) !== void 0 ? (s.start + (t ? s.duration : 0)) / s.timescale : e
}
function gL(s, e, t, n) {
    if (s === null)
        return !0;
    const r = Math.max(n, 1)
      , i = e - s.baseTime / s.timescale;
    return Math.abs(i - t) > r
}
function Gf(s, e, t) {
    const n = s.codec;
    return n && n.length > 4 ? n : e === xe.AUDIO ? n === "ec-3" || n === "ac-3" || n === "alac" ? n : n === "fLaC" || n === "Opus" ? Eo(n, !1) : (t.warn(`Unhandled audio codec "${n}" in mp4 MAP`),
    n || "mp4a") : (t.warn(`Unhandled video codec "${n}" in mp4 MAP`),
    n || "avc1")
}
let Is;
try {
    Is = self.performance.now.bind(self.performance)
} catch {
    Is = Date.now
}
const $a = [{
    demux: eL,
    remux: mL
}, {
    demux: Hs,
    remux: Ba
}, {
    demux: Z1,
    remux: Ba
}, {
    demux: Q1,
    remux: Ba
}];
$a.splice(2, 0, {
    demux: q1,
    remux: Ba
});
class Vf {
    constructor(e, t, n, r, i, a) {
        this.asyncResult = !1,
        this.logger = void 0,
        this.observer = void 0,
        this.typeSupported = void 0,
        this.config = void 0,
        this.id = void 0,
        this.demuxer = void 0,
        this.remuxer = void 0,
        this.decrypter = void 0,
        this.probe = void 0,
        this.decryptionPromise = null,
        this.transmuxConfig = void 0,
        this.currentTransmuxState = void 0,
        this.observer = e,
        this.typeSupported = t,
        this.config = n,
        this.id = i,
        this.logger = a
    }
    configure(e) {
        this.transmuxConfig = e,
        this.decrypter && this.decrypter.reset()
    }
    push(e, t, n, r) {
        const i = n.transmuxing;
        i.executeStart = Is();
        let a = new Uint8Array(e);
        const {currentTransmuxState: o, transmuxConfig: l} = this;
        r && (this.currentTransmuxState = r);
        const {contiguous: c, discontinuity: u, trackSwitch: d, accurateTimeOffset: h, timeOffset: f, initSegmentChange: m} = r || o
          , {audioCodec: p, videoCodec: x, defaultInitPts: y, duration: v, initSegmentData: E} = l
          , T = pL(a, t);
        if (T && fr(T.method)) {
            const A = this.getDecrypter()
              , C = vd(T.method);
            if (A.isSync()) {
                let b = A.softwareDecrypt(a, T.key.buffer, T.iv.buffer, C);
                if (n.part > -1) {
                    const _ = A.flush();
                    b = _ && _.buffer
                }
                if (!b)
                    return i.executeEnd = Is(),
                    Bl(n);
                a = new Uint8Array(b)
            } else
                return this.asyncResult = !0,
                this.decryptionPromise = A.webCryptoDecrypt(a, T.key.buffer, T.iv.buffer, C).then(b => {
                    const O = this.push(b, null, n);
                    return this.decryptionPromise = null,
                    O
                }
                ),
                this.decryptionPromise
        }
        const L = this.needsProbing(u, d);
        if (L) {
            const A = this.configureTransmuxer(a);
            if (A)
                return this.logger.warn(`[transmuxer] ${A.message}`),
                this.observer.emit(S.ERROR, S.ERROR, {
                    type: q.MEDIA_ERROR,
                    details: N.FRAG_PARSING_ERROR,
                    fatal: !1,
                    error: A,
                    reason: A.message
                }),
                i.executeEnd = Is(),
                Bl(n)
        }
        (u || d || m || L) && this.resetInitSegment(E, p, x, v, t),
        (u || m || L) && this.resetInitialTimestamp(y),
        c || this.resetContiguity();
        const R = this.transmux(a, T, f, h, n);
        this.asyncResult = Ci(R);
        const I = this.currentTransmuxState;
        return I.contiguous = !0,
        I.discontinuity = !1,
        I.trackSwitch = !1,
        i.executeEnd = Is(),
        R
    }
    flush(e) {
        const t = e.transmuxing;
        t.executeStart = Is();
        const {decrypter: n, currentTransmuxState: r, decryptionPromise: i} = this;
        if (i)
            return this.asyncResult = !0,
            i.then( () => this.flush(e));
        const a = []
          , {timeOffset: o} = r;
        if (n) {
            const d = n.flush();
            d && a.push(this.push(d.buffer, null, e))
        }
        const {demuxer: l, remuxer: c} = this;
        if (!l || !c) {
            t.executeEnd = Is();
            const d = [Bl(e)];
            return this.asyncResult ? Promise.resolve(d) : d
        }
        const u = l.flush(o);
        return Ci(u) ? (this.asyncResult = !0,
        u.then(d => (this.flushRemux(a, d, e),
        a))) : (this.flushRemux(a, u, e),
        this.asyncResult ? Promise.resolve(a) : a)
    }
    flushRemux(e, t, n) {
        const {audioTrack: r, videoTrack: i, id3Track: a, textTrack: o} = t
          , {accurateTimeOffset: l, timeOffset: c} = this.currentTransmuxState;
        this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${n.sn}${n.part > -1 ? " part: " + n.part : ""} of ${this.id === X.MAIN ? "level" : "track"} ${n.level}`);
        const u = this.remuxer.remux(r, i, a, o, c, l, !0, this.id);
        e.push({
            remuxResult: u,
            chunkMeta: n
        }),
        n.transmuxing.executeEnd = Is()
    }
    resetInitialTimestamp(e) {
        const {demuxer: t, remuxer: n} = this;
        !t || !n || (t.resetTimeStamp(e),
        n.resetTimeStamp(e))
    }
    resetContiguity() {
        const {demuxer: e, remuxer: t} = this;
        !e || !t || (e.resetContiguity(),
        t.resetNextTimestamp())
    }
    resetInitSegment(e, t, n, r, i) {
        const {demuxer: a, remuxer: o} = this;
        !a || !o || (a.resetInitSegment(e, t, n, r),
        o.resetInitSegment(e, t, n, i))
    }
    destroy() {
        this.demuxer && (this.demuxer.destroy(),
        this.demuxer = void 0),
        this.remuxer && (this.remuxer.destroy(),
        this.remuxer = void 0)
    }
    transmux(e, t, n, r, i) {
        let a;
        return t && t.method === "SAMPLE-AES" ? a = this.transmuxSampleAes(e, t, n, r, i) : a = this.transmuxUnencrypted(e, n, r, i),
        a
    }
    transmuxUnencrypted(e, t, n, r) {
        const {audioTrack: i, videoTrack: a, id3Track: o, textTrack: l} = this.demuxer.demux(e, t, !1, !this.config.progressive);
        return {
            remuxResult: this.remuxer.remux(i, a, o, l, t, n, !1, this.id),
            chunkMeta: r
        }
    }
    transmuxSampleAes(e, t, n, r, i) {
        return this.demuxer.demuxSampleAes(e, t, n).then(a => ({
            remuxResult: this.remuxer.remux(a.audioTrack, a.videoTrack, a.id3Track, a.textTrack, n, r, !1, this.id),
            chunkMeta: i
        }))
    }
    configureTransmuxer(e) {
        const {config: t, observer: n, typeSupported: r} = this;
        let i;
        for (let d = 0, h = $a.length; d < h; d++) {
            var a;
            if ((a = $a[d].demux) != null && a.probe(e, this.logger)) {
                i = $a[d];
                break
            }
        }
        if (!i)
            return new Error("Failed to find demuxer by probing fragment data");
        const o = this.demuxer
          , l = this.remuxer
          , c = i.remux
          , u = i.demux;
        (!l || !(l instanceof c)) && (this.remuxer = new c(n,t,r,this.logger)),
        (!o || !(o instanceof u)) && (this.demuxer = new u(n,t,r,this.logger),
        this.probe = u.probe)
    }
    needsProbing(e, t) {
        return !this.demuxer || !this.remuxer || e || t
    }
    getDecrypter() {
        let e = this.decrypter;
        return e || (e = this.decrypter = new yd(this.config)),
        e
    }
}
function pL(s, e) {
    let t = null;
    return s.byteLength > 0 && (e == null ? void 0 : e.key) != null && e.iv !== null && e.method != null && (t = e),
    t
}
const Bl = s => ({
    remuxResult: {},
    chunkMeta: s
});
function Ci(s) {
    return "then"in s && s.then instanceof Function
}
class yL {
    constructor(e, t, n, r, i) {
        this.audioCodec = void 0,
        this.videoCodec = void 0,
        this.initSegmentData = void 0,
        this.duration = void 0,
        this.defaultInitPts = void 0,
        this.audioCodec = e,
        this.videoCodec = t,
        this.initSegmentData = n,
        this.duration = r,
        this.defaultInitPts = i || null
    }
}
class xL {
    constructor(e, t, n, r, i, a) {
        this.discontinuity = void 0,
        this.contiguous = void 0,
        this.accurateTimeOffset = void 0,
        this.trackSwitch = void 0,
        this.timeOffset = void 0,
        this.initSegmentChange = void 0,
        this.discontinuity = e,
        this.contiguous = t,
        this.accurateTimeOffset = n,
        this.trackSwitch = r,
        this.timeOffset = i,
        this.initSegmentChange = a
    }
}
let Hf = 0;
class H0 {
    constructor(e, t, n, r) {
        this.error = null,
        this.hls = void 0,
        this.id = void 0,
        this.instanceNo = Hf++,
        this.observer = void 0,
        this.frag = null,
        this.part = null,
        this.useWorker = void 0,
        this.workerContext = null,
        this.transmuxer = null,
        this.onTransmuxComplete = void 0,
        this.onFlush = void 0,
        this.onWorkerMessage = l => {
            const c = l.data
              , u = this.hls;
            if (!(!u || !(c != null && c.event) || c.instanceNo !== this.instanceNo))
                switch (c.event) {
                case "init":
                    {
                        var d;
                        const h = (d = this.workerContext) == null ? void 0 : d.objectURL;
                        h && self.URL.revokeObjectURL(h);
                        break
                    }
                case "transmuxComplete":
                    {
                        this.handleTransmuxComplete(c.data);
                        break
                    }
                case "flush":
                    {
                        this.onFlush(c.data);
                        break
                    }
                case "workerLog":
                    {
                        u.logger[c.data.logType] && u.logger[c.data.logType](c.data.message);
                        break
                    }
                default:
                    {
                        c.data = c.data || {},
                        c.data.frag = this.frag,
                        c.data.part = this.part,
                        c.data.id = this.id,
                        u.trigger(c.event, c.data);
                        break
                    }
                }
        }
        ,
        this.onWorkerError = l => {
            if (!this.hls)
                return;
            const c = new Error(`${l.message}  (${l.filename}:${l.lineno})`);
            this.hls.config.enableWorker = !1,
            this.hls.logger.warn(`Error in "${this.id}" Web Worker, fallback to inline`),
            this.hls.trigger(S.ERROR, {
                type: q.OTHER_ERROR,
                details: N.INTERNAL_EXCEPTION,
                fatal: !1,
                event: "demuxerWorker",
                error: c
            })
        }
        ;
        const i = e.config;
        this.hls = e,
        this.id = t,
        this.useWorker = !!i.enableWorker,
        this.onTransmuxComplete = n,
        this.onFlush = r;
        const a = (l, c) => {
            c = c || {},
            c.frag = this.frag || void 0,
            l === S.ERROR && (c = c,
            c.parent = this.id,
            c.part = this.part,
            this.error = c.error),
            this.hls.trigger(l, c)
        }
        ;
        this.observer = new Td,
        this.observer.on(S.FRAG_DECRYPTED, a),
        this.observer.on(S.ERROR, a);
        const o = of(i.preferManagedMediaSource);
        if (this.useWorker && typeof Worker < "u") {
            const l = this.hls.logger;
            if (i.workerPath || T1()) {
                try {
                    i.workerPath ? (l.log(`loading Web Worker ${i.workerPath} for "${t}"`),
                    this.workerContext = I1(i.workerPath)) : (l.log(`injecting Web Worker for "${t}"`),
                    this.workerContext = L1());
                    const {worker: u} = this.workerContext;
                    u.addEventListener("message", this.onWorkerMessage),
                    u.addEventListener("error", this.onWorkerError),
                    u.postMessage({
                        instanceNo: this.instanceNo,
                        cmd: "init",
                        typeSupported: o,
                        id: t,
                        config: Te(i)
                    })
                } catch (u) {
                    l.warn(`Error setting up "${t}" Web Worker, fallback to inline`, u),
                    this.terminateWorker(),
                    this.error = null,
                    this.transmuxer = new Vf(this.observer,o,i,"",t,e.logger)
                }
                return
            }
        }
        this.transmuxer = new Vf(this.observer,o,i,"",t,e.logger)
    }
    reset() {
        if (this.frag = null,
        this.part = null,
        this.workerContext) {
            const e = this.instanceNo;
            this.instanceNo = Hf++;
            const t = this.hls.config
              , n = of(t.preferManagedMediaSource);
            this.workerContext.worker.postMessage({
                instanceNo: this.instanceNo,
                cmd: "reset",
                resetNo: e,
                typeSupported: n,
                id: this.id,
                config: Te(t)
            })
        }
    }
    terminateWorker() {
        if (this.workerContext) {
            const {worker: e} = this.workerContext;
            this.workerContext = null,
            e.removeEventListener("message", this.onWorkerMessage),
            e.removeEventListener("error", this.onWorkerError),
            A1(this.hls.config.workerPath)
        }
    }
    destroy() {
        if (this.workerContext)
            this.terminateWorker(),
            this.onWorkerMessage = this.onWorkerError = null;
        else {
            const t = this.transmuxer;
            t && (t.destroy(),
            this.transmuxer = null)
        }
        const e = this.observer;
        e && e.removeAllListeners(),
        this.frag = null,
        this.part = null,
        this.observer = null,
        this.hls = null
    }
    push(e, t, n, r, i, a, o, l, c, u) {
        var d, h;
        c.transmuxing.start = self.performance.now();
        const {instanceNo: f, transmuxer: m} = this
          , p = a ? a.start : i.start
          , x = i.decryptdata
          , y = this.frag
          , v = !(y && i.cc === y.cc)
          , E = !(y && c.level === y.level)
          , T = y ? c.sn - y.sn : -1
          , L = this.part ? c.part - this.part.index : -1
          , R = T === 0 && c.id > 1 && c.id === (y == null ? void 0 : y.stats.chunkCount)
          , I = !E && (T === 1 || T === 0 && (L === 1 || R && L <= 0))
          , A = self.performance.now();
        (E || T || i.stats.parsing.start === 0) && (i.stats.parsing.start = A),
        a && (L || !I) && (a.stats.parsing.start = A);
        const C = !(y && ((d = i.initSegment) == null ? void 0 : d.url) === ((h = y.initSegment) == null ? void 0 : h.url))
          , b = new xL(v,I,l,E,p,C);
        if (!I || v || C) {
            this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${i.type} sn: ${c.sn}${c.part > -1 ? " part: " + c.part : ""} ${this.id === X.MAIN ? "level" : "track"}: ${c.level} id: ${c.id}
        discontinuity: ${v}
        trackSwitch: ${E}
        contiguous: ${I}
        accurateTimeOffset: ${l}
        timeOffset: ${p}
        initSegmentChange: ${C}`);
            const O = new yL(n,r,t,o,u);
            this.configureTransmuxer(O)
        }
        if (this.frag = i,
        this.part = a,
        this.workerContext)
            this.workerContext.worker.postMessage({
                instanceNo: f,
                cmd: "demux",
                data: e,
                decryptdata: x,
                chunkMeta: c,
                state: b
            }, e instanceof ArrayBuffer ? [e] : []);
        else if (m) {
            const O = m.push(e, x, c, b);
            Ci(O) ? O.then(_ => {
                this.handleTransmuxComplete(_)
            }
            ).catch(_ => {
                this.transmuxerError(_, c, "transmuxer-interface push error")
            }
            ) : this.handleTransmuxComplete(O)
        }
    }
    flush(e) {
        e.transmuxing.start = self.performance.now();
        const {instanceNo: t, transmuxer: n} = this;
        if (this.workerContext)
            this.workerContext.worker.postMessage({
                instanceNo: t,
                cmd: "flush",
                chunkMeta: e
            });
        else if (n) {
            const r = n.flush(e);
            Ci(r) ? r.then(i => {
                this.handleFlushResult(i, e)
            }
            ).catch(i => {
                this.transmuxerError(i, e, "transmuxer-interface flush error")
            }
            ) : this.handleFlushResult(r, e)
        }
    }
    transmuxerError(e, t, n) {
        this.hls && (this.error = e,
        this.hls.trigger(S.ERROR, {
            type: q.MEDIA_ERROR,
            details: N.FRAG_PARSING_ERROR,
            chunkMeta: t,
            frag: this.frag || void 0,
            part: this.part || void 0,
            fatal: !1,
            error: e,
            err: e,
            reason: n
        }))
    }
    handleFlushResult(e, t) {
        e.forEach(n => {
            this.handleTransmuxComplete(n)
        }
        ),
        this.onFlush(t)
    }
    configureTransmuxer(e) {
        const {instanceNo: t, transmuxer: n} = this;
        this.workerContext ? this.workerContext.worker.postMessage({
            instanceNo: t,
            cmd: "configure",
            config: e
        }) : n && n.configure(e)
    }
    handleTransmuxComplete(e) {
        e.chunkMeta.transmuxing.end = self.performance.now(),
        this.onTransmuxComplete(e)
    }
}
const Kf = 100;
class vL extends Sd {
    constructor(e, t, n) {
        super(e, t, n, "audio-stream-controller", X.AUDIO),
        this.mainAnchor = null,
        this.mainFragLoading = null,
        this.audioOnly = !1,
        this.bufferedTrack = null,
        this.switchingTrack = null,
        this.trackId = -1,
        this.waitingData = null,
        this.mainDetails = null,
        this.flushing = !1,
        this.bufferFlushed = !1,
        this.cachedTrackLoadedData = null,
        this.registerListeners()
    }
    onHandlerDestroying() {
        this.unregisterListeners(),
        super.onHandlerDestroying(),
        this.resetItem()
    }
    resetItem() {
        this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null
    }
    registerListeners() {
        super.registerListeners();
        const {hls: e} = this;
        e.on(S.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(S.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
        e.on(S.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.on(S.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.on(S.BUFFER_RESET, this.onBufferReset, this),
        e.on(S.BUFFER_CREATED, this.onBufferCreated, this),
        e.on(S.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.on(S.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.on(S.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.on(S.FRAG_LOADING, this.onFragLoading, this),
        e.on(S.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e && (super.unregisterListeners(),
        e.off(S.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(S.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this),
        e.off(S.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.off(S.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.off(S.BUFFER_RESET, this.onBufferReset, this),
        e.off(S.BUFFER_CREATED, this.onBufferCreated, this),
        e.off(S.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.off(S.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.off(S.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.off(S.FRAG_LOADING, this.onFragLoading, this),
        e.off(S.FRAG_BUFFERED, this.onFragBuffered, this))
    }
    onInitPtsFound(e, {frag: t, id: n, initPTS: r, timescale: i, trackId: a}) {
        if (n === X.MAIN) {
            const o = t.cc
              , l = this.fragCurrent;
            if (this.initPTS[o] = {
                baseTime: r,
                timescale: i,
                trackId: a
            },
            this.log(`InitPTS for cc: ${o} found from main: ${r / i} (${r}/${i}) trackId: ${a}`),
            this.mainAnchor = t,
            this.state === U.WAITING_INIT_PTS) {
                const c = this.waitingData;
                (!c && !this.loadingParts || c && c.frag.cc !== o) && this.syncWithAnchor(t, c == null ? void 0 : c.frag)
            } else
                !this.hls.hasEnoughToStart && l && l.cc !== o ? (l.abortRequests(),
                this.syncWithAnchor(t, l)) : this.state === U.IDLE && this.tick()
        }
    }
    getLoadPosition() {
        return !this.startFragRequested && this.nextLoadPosition >= 0 ? this.nextLoadPosition : super.getLoadPosition()
    }
    syncWithAnchor(e, t) {
        var n;
        const r = ((n = this.mainFragLoading) == null ? void 0 : n.frag) || null;
        if (t && (r == null ? void 0 : r.cc) === t.cc)
            return;
        const i = (r || e).cc
          , a = this.getLevelDetails()
          , o = this.getLoadPosition()
          , l = u0(a, i, o);
        l && (this.log(`Syncing with main frag at ${l.start} cc ${l.cc}`),
        this.startFragRequested = !1,
        this.nextLoadPosition = l.start,
        this.resetLoadingState(),
        this.state === U.IDLE && this.doTickIdle())
    }
    startLoad(e, t) {
        if (!this.levels) {
            this.startPosition = e,
            this.state = U.STOPPED;
            return
        }
        const n = this.lastCurrentTime;
        this.stopLoad(),
        this.setInterval(Kf),
        n > 0 && e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${n.toFixed(3)}`),
        e = n,
        this.state = U.IDLE) : this.state = U.WAITING_TRACK,
        this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset,
        this.startPosition = t ? -1 : e,
        this.tick()
    }
    doTick() {
        switch (this.state) {
        case U.IDLE:
            this.doTickIdle();
            break;
        case U.WAITING_TRACK:
            {
                const {levels: e, trackId: t} = this
                  , n = e == null ? void 0 : e[t]
                  , r = n == null ? void 0 : n.details;
                if (r && !this.waitForLive(n)) {
                    if (this.waitForCdnTuneIn(r))
                        break;
                    this.state = U.WAITING_INIT_PTS
                }
                break
            }
        case U.FRAG_LOADING_WAITING_RETRY:
            {
                this.checkRetryDate();
                break
            }
        case U.WAITING_INIT_PTS:
            {
                const e = this.waitingData;
                if (e) {
                    const {frag: t, part: n, cache: r, complete: i} = e
                      , a = this.mainAnchor;
                    if (this.initPTS[t.cc] !== void 0) {
                        this.waitingData = null,
                        this.state = U.FRAG_LOADING;
                        const o = r.flush().buffer
                          , l = {
                            frag: t,
                            part: n,
                            payload: o,
                            networkDetails: null
                        };
                        this._handleFragmentLoadProgress(l),
                        i && super._handleFragmentLoadComplete(l)
                    } else
                        a && a.cc !== e.frag.cc && this.syncWithAnchor(a, e.frag)
                } else
                    this.state = U.IDLE
            }
        }
        this.onTickEnd()
    }
    resetLoadingState() {
        const e = this.waitingData;
        e && (this.fragmentTracker.removeFragment(e.frag),
        this.waitingData = null),
        super.resetLoadingState()
    }
    onTickEnd() {
        const {media: e} = this;
        e != null && e.readyState && (this.lastCurrentTime = e.currentTime)
    }
    doTickIdle() {
        var e;
        const {hls: t, levels: n, media: r, trackId: i} = this
          , a = t.config;
        if (!this.buffering || !r && !this.primaryPrefetch && (this.startFragRequested || !a.startFragPrefetch) || !(n != null && n[i]))
            return;
        const o = n[i]
          , l = o.details;
        if (!l || this.waitForLive(o) || this.waitForCdnTuneIn(l)) {
            this.state = U.WAITING_TRACK,
            this.startFragRequested = !1;
            return
        }
        const c = this.mediaBuffer ? this.mediaBuffer : this.media;
        this.bufferFlushed && c && (this.bufferFlushed = !1,
        this.afterBufferFlushed(c, xe.AUDIO, X.AUDIO));
        const u = this.getFwdBufferInfo(c, X.AUDIO);
        if (u === null)
            return;
        if (!this.switchingTrack && this._streamEnded(u, l)) {
            t.trigger(S.BUFFER_EOS, {
                type: "audio"
            }),
            this.state = U.ENDED;
            return
        }
        const d = u.len
          , h = t.maxBufferLength
          , f = l.fragments
          , m = f[0].start
          , p = this.getLoadPosition()
          , x = this.flushing ? p : u.end;
        if (this.switchingTrack && r) {
            const E = p;
            l.PTSKnown && E < m && (u.end > m || u.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"),
            r.currentTime = m + .05)
        }
        if (d >= h && !this.switchingTrack && x < f[f.length - 1].start)
            return;
        let y = this.getNextFragment(x, l);
        if (y && this.isLoopLoading(y, x) && (y = this.getNextFragmentLoopLoading(y, l, u, X.MAIN, h)),
        !y) {
            this.bufferFlushed = !0;
            return
        }
        let v = ((e = this.mainFragLoading) == null ? void 0 : e.frag) || null;
        if (!this.audioOnly && this.startFragRequested && v && Fe(y) && !y.endList && (!l.live || !this.loadingParts && x < this.hls.liveSyncPosition) && (this.fragmentTracker.getState(v) === Ve.OK && (this.mainFragLoading = v = null),
        v && Fe(v))) {
            if (y.start > v.end) {
                const T = this.fragmentTracker.getFragAtPos(x, X.MAIN);
                T && T.end > v.end && (v = T,
                this.mainFragLoading = {
                    frag: T,
                    targetBufferTime: null
                })
            }
            if (y.start > v.end)
                return
        }
        this.loadFragment(y, o, x)
    }
    onMediaDetaching(e, t) {
        this.bufferFlushed = this.flushing = !1,
        super.onMediaDetaching(e, t)
    }
    onAudioTracksUpdated(e, {audioTracks: t}) {
        this.resetTransmuxer(),
        this.levels = t.map(n => new bi(n))
    }
    onAudioTrackSwitching(e, t) {
        const n = !!t.url;
        this.trackId = t.id;
        const {fragCurrent: r} = this;
        r && (r.abortRequests(),
        this.removeUnbufferedFrags(r.start)),
        this.resetLoadingState(),
        n ? (this.switchingTrack = t,
        this.flushAudioIfNeeded(t),
        this.state !== U.STOPPED && (this.setInterval(Kf),
        this.state = U.IDLE,
        this.tick())) : (this.resetTransmuxer(),
        this.switchingTrack = null,
        this.bufferedTrack = t,
        this.clearInterval())
    }
    onManifestLoading() {
        super.onManifestLoading(),
        this.bufferFlushed = this.flushing = this.audioOnly = !1,
        this.resetItem(),
        this.trackId = -1
    }
    onLevelLoaded(e, t) {
        this.mainDetails = t.details;
        const n = this.cachedTrackLoadedData;
        n && (this.cachedTrackLoadedData = null,
        this.onAudioTrackLoaded(S.AUDIO_TRACK_LOADED, n))
    }
    onAudioTrackLoaded(e, t) {
        var n;
        const {levels: r} = this
          , {details: i, id: a, groupId: o, track: l} = t;
        if (!r) {
            this.warn(`Audio tracks reset while loading track ${a} "${l.name}" of "${o}"`);
            return
        }
        const c = this.mainDetails;
        if (!c || i.endCC > c.endCC || c.expired) {
            this.cachedTrackLoadedData = t,
            this.state !== U.STOPPED && (this.state = U.WAITING_TRACK);
            return
        }
        this.cachedTrackLoadedData = null,
        this.log(`Audio track ${a} "${l.name}" of "${o}" loaded [${i.startSN},${i.endSN}]${i.lastPartSn ? `[part-${i.lastPartSn}-${i.lastPartIndex}]` : ""},duration:${i.totalduration}`);
        const u = r[a];
        let d = 0;
        if (i.live || (n = u.details) != null && n.live) {
            if (this.checkLiveUpdate(i),
            i.deltaUpdateFailed)
                return;
            if (u.details) {
                var h;
                d = this.alignPlaylists(i, u.details, (h = this.levelLastLoaded) == null ? void 0 : h.details)
            }
            i.alignedSliding || (I0(i, c),
            i.alignedSliding || bo(i, c),
            d = i.fragmentStart)
        }
        u.details = i,
        this.levelLastLoaded = u,
        this.startFragRequested || this.setStartPosition(c, d),
        this.hls.trigger(S.AUDIO_TRACK_UPDATED, {
            details: i,
            id: a,
            groupId: t.groupId
        }),
        this.state === U.WAITING_TRACK && !this.waitForCdnTuneIn(i) && (this.state = U.IDLE),
        this.tick()
    }
    _handleFragmentLoadProgress(e) {
        var t;
        const n = e.frag
          , {part: r, payload: i} = e
          , {config: a, trackId: o, levels: l} = this;
        if (!l) {
            this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
            return
        }
        const c = l[o];
        if (!c) {
            this.warn("Audio track is undefined on fragment load progress");
            return
        }
        const u = c.details;
        if (!u) {
            this.warn("Audio track details undefined on fragment load progress"),
            this.removeUnbufferedFrags(n.start);
            return
        }
        const d = a.defaultAudioCodec || c.audioCodec || "mp4a.40.2";
        let h = this.transmuxer;
        h || (h = this.transmuxer = new H0(this.hls,X.AUDIO,this._handleTransmuxComplete.bind(this),this._handleTransmuxerFlush.bind(this)));
        const f = this.initPTS[n.cc]
          , m = (t = n.initSegment) == null ? void 0 : t.data;
        if (f !== void 0) {
            const x = r ? r.index : -1
              , y = x !== -1
              , v = new xd(n.level,n.sn,n.stats.chunkCount,i.byteLength,x,y);
            h.push(i, m, d, "", n, r, u.totalduration, !1, v, f)
        } else {
            this.log(`Unknown video PTS for cc ${n.cc}, waiting for video PTS before demuxing audio frag ${n.sn} of [${u.startSN} ,${u.endSN}],track ${o}`);
            const {cache: p} = this.waitingData = this.waitingData || {
                frag: n,
                part: r,
                cache: new A0,
                complete: !1
            };
            p.push(new Uint8Array(i)),
            this.state !== U.STOPPED && (this.state = U.WAITING_INIT_PTS)
        }
    }
    _handleFragmentLoadComplete(e) {
        if (this.waitingData) {
            this.waitingData.complete = !0;
            return
        }
        super._handleFragmentLoadComplete(e)
    }
    onBufferReset() {
        this.mediaBuffer = null
    }
    onBufferCreated(e, t) {
        this.bufferFlushed = this.flushing = !1;
        const n = t.tracks.audio;
        n && (this.mediaBuffer = n.buffer || null)
    }
    onFragLoading(e, t) {
        !this.audioOnly && t.frag.type === X.MAIN && Fe(t.frag) && (this.mainFragLoading = t,
        this.state === U.IDLE && this.tick())
    }
    onFragBuffered(e, t) {
        const {frag: n, part: r} = t;
        if (n.type !== X.AUDIO) {
            !this.audioOnly && n.type === X.MAIN && !n.elementaryStreams.video && !n.elementaryStreams.audiovideo && (this.audioOnly = !0,
            this.mainFragLoading = null);
            return
        }
        if (this.fragContextChanged(n)) {
            this.warn(`Fragment ${n.sn}${r ? " p: " + r.index : ""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
            return
        }
        if (Fe(n)) {
            this.fragPrevious = n;
            const i = this.switchingTrack;
            i && (this.bufferedTrack = i,
            this.switchingTrack = null,
            this.hls.trigger(S.AUDIO_TRACK_SWITCHED, pe({}, i)))
        }
        this.fragBufferedComplete(n, r),
        this.media && this.tick()
    }
    onError(e, t) {
        var n;
        if (t.fatal) {
            this.state = U.ERROR;
            return
        }
        switch (t.details) {
        case N.FRAG_GAP:
        case N.FRAG_PARSING_ERROR:
        case N.FRAG_DECRYPT_ERROR:
        case N.FRAG_LOAD_ERROR:
        case N.FRAG_LOAD_TIMEOUT:
        case N.KEY_LOAD_ERROR:
        case N.KEY_LOAD_TIMEOUT:
            this.onFragmentOrKeyLoadError(X.AUDIO, t);
            break;
        case N.AUDIO_TRACK_LOAD_ERROR:
        case N.AUDIO_TRACK_LOAD_TIMEOUT:
        case N.LEVEL_PARSING_ERROR:
            !t.levelRetry && this.state === U.WAITING_TRACK && ((n = t.context) == null ? void 0 : n.type) === le.AUDIO_TRACK && (this.state = U.IDLE);
            break;
        case N.BUFFER_ADD_CODEC_ERROR:
        case N.BUFFER_APPEND_ERROR:
            if (t.parent !== "audio")
                return;
            this.reduceLengthAndFlushBuffer(t) || this.resetLoadingState();
            break;
        case N.BUFFER_FULL_ERROR:
            if (t.parent !== "audio")
                return;
            this.reduceLengthAndFlushBuffer(t) && (this.bufferedTrack = null,
            super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"));
            break;
        case N.INTERNAL_EXCEPTION:
            this.recoverWorkerError(t);
            break
        }
    }
    onBufferFlushing(e, {type: t}) {
        t !== xe.VIDEO && (this.flushing = !0)
    }
    onBufferFlushed(e, {type: t}) {
        if (t !== xe.VIDEO) {
            this.flushing = !1,
            this.bufferFlushed = !0,
            this.state === U.ENDED && (this.state = U.IDLE);
            const n = this.mediaBuffer || this.media;
            n && (this.afterBufferFlushed(n, t, X.AUDIO),
            this.tick())
        }
    }
    _handleTransmuxComplete(e) {
        var t;
        const n = "audio"
          , {hls: r} = this
          , {remuxResult: i, chunkMeta: a} = e
          , o = this.getCurrentContext(a);
        if (!o) {
            this.resetWhenMissingContext(a);
            return
        }
        const {frag: l, part: c, level: u} = o
          , {details: d} = u
          , {audio: h, text: f, id3: m, initSegment: p} = i;
        if (this.fragContextChanged(l) || !d) {
            this.fragmentTracker.removeFragment(l);
            return
        }
        if (this.state = U.PARSING,
        this.switchingTrack && h && this.completeAudioSwitch(this.switchingTrack),
        p != null && p.tracks) {
            const x = l.initSegment || l;
            if (this.unhandledEncryptionError(p, l))
                return;
            this._bufferInitSegment(u, p.tracks, x, a),
            r.trigger(S.FRAG_PARSING_INIT_SEGMENT, {
                frag: x,
                id: n,
                tracks: p.tracks
            })
        }
        if (h) {
            const {startPTS: x, endPTS: y, startDTS: v, endDTS: E} = h;
            c && (c.elementaryStreams[xe.AUDIO] = {
                startPTS: x,
                endPTS: y,
                startDTS: v,
                endDTS: E
            }),
            l.setElementaryStreamInfo(xe.AUDIO, x, y, v, E),
            this.bufferFragmentData(h, l, c, a)
        }
        if (m != null && (t = m.samples) != null && t.length) {
            const x = ye({
                id: n,
                frag: l,
                details: d
            }, m);
            r.trigger(S.FRAG_PARSING_METADATA, x)
        }
        if (f) {
            const x = ye({
                id: n,
                frag: l,
                details: d
            }, f);
            r.trigger(S.FRAG_PARSING_USERDATA, x)
        }
    }
    _bufferInitSegment(e, t, n, r) {
        if (this.state !== U.PARSING || (t.video && delete t.video,
        t.audiovideo && delete t.audiovideo,
        !t.audio))
            return;
        const i = t.audio;
        i.id = X.AUDIO;
        const a = e.audioCodec;
        this.log(`Init audio buffer, container:${i.container}, codecs[level/parsed]=[${a}/${i.codec}]`),
        a && a.split(",").length === 1 && (i.levelCodec = a),
        this.hls.trigger(S.BUFFER_CODECS, t);
        const o = i.initSegment;
        if (o != null && o.byteLength) {
            const l = {
                type: "audio",
                frag: n,
                part: null,
                chunkMeta: r,
                parent: n.type,
                data: o
            };
            this.hls.trigger(S.BUFFER_APPENDING, l)
        }
        this.tickImmediate()
    }
    loadFragment(e, t, n) {
        const r = this.fragmentTracker.getState(e);
        if (this.switchingTrack || r === Ve.NOT_LOADED || r === Ve.PARTIAL) {
            var i;
            if (!Fe(e))
                this._loadInitSegment(e, t);
            else if ((i = t.details) != null && i.live && !this.initPTS[e.cc]) {
                this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`),
                this.state = U.WAITING_INIT_PTS;
                const a = this.mainDetails;
                a && a.fragmentStart !== t.details.fragmentStart && bo(t.details, a)
            } else
                super.loadFragment(e, t, n)
        } else
            this.clearTrackerIfNeeded(e)
    }
    flushAudioIfNeeded(e) {
        if (this.media && this.bufferedTrack) {
            const {name: t, lang: n, assocLang: r, characteristics: i, audioCodec: a, channels: o} = this.bufferedTrack;
            Rn({
                name: t,
                lang: n,
                assocLang: r,
                characteristics: i,
                audioCodec: a,
                channels: o
            }, e, Sn) || (To(e.url, this.hls) ? (this.log("Switching audio track : flushing all audio"),
            super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio"),
            this.bufferedTrack = null) : this.bufferedTrack = e)
        }
    }
    completeAudioSwitch(e) {
        const {hls: t} = this;
        this.flushAudioIfNeeded(e),
        this.bufferedTrack = e,
        this.switchingTrack = null,
        t.trigger(S.AUDIO_TRACK_SWITCHED, pe({}, e))
    }
}
class Cd extends Gt {
    constructor(e, t) {
        super(t, e.logger),
        this.hls = void 0,
        this.canLoad = !1,
        this.timer = -1,
        this.hls = e
    }
    destroy() {
        this.clearTimer(),
        this.hls = this.log = this.warn = null
    }
    clearTimer() {
        this.timer !== -1 && (self.clearTimeout(this.timer),
        this.timer = -1)
    }
    startLoad() {
        this.canLoad = !0,
        this.loadPlaylist()
    }
    stopLoad() {
        this.canLoad = !1,
        this.clearTimer()
    }
    switchParams(e, t, n) {
        const r = t == null ? void 0 : t.renditionReports;
        if (r) {
            let i = -1;
            for (let a = 0; a < r.length; a++) {
                const o = r[a];
                let l;
                try {
                    l = new self.URL(o.URI,t.url).href
                } catch (c) {
                    this.warn(`Could not construct new URL for Rendition Report: ${c}`),
                    l = o.URI || ""
                }
                if (l === e) {
                    i = a;
                    break
                } else
                    l === e.substring(0, l.length) && (i = a)
            }
            if (i !== -1) {
                const a = r[i]
                  , o = parseInt(a["LAST-MSN"]) || t.lastPartSn;
                let l = parseInt(a["LAST-PART"]) || t.lastPartIndex;
                if (this.hls.config.lowLatencyMode) {
                    const u = Math.min(t.age - t.partTarget, t.targetduration);
                    l >= 0 && u > t.partTarget && (l += 1)
                }
                const c = n && lf(n);
                return new cf(o,l >= 0 ? l : void 0,c)
            }
        }
    }
    loadPlaylist(e) {
        this.clearTimer()
    }
    loadingPlaylist(e, t) {
        this.clearTimer()
    }
    shouldLoadPlaylist(e) {
        return this.canLoad && !!e && !!e.url && (!e.details || e.details.live)
    }
    getUrlWithDirectives(e, t) {
        if (t)
            try {
                return t.addDirectives(e)
            } catch (n) {
                this.warn(`Could not construct new URL with HLS Delivery Directives: ${n}`)
            }
        return e
    }
    playlistLoaded(e, t, n) {
        const {details: r, stats: i} = t
          , a = self.performance.now()
          , o = i.loading.first ? Math.max(0, a - i.loading.first) : 0;
        r.advancedDateTime = Date.now() - o;
        const l = this.hls.config.timelineOffset;
        if (l !== r.appliedTimelineOffset) {
            const u = Math.max(l || 0, 0);
            r.appliedTimelineOffset = u,
            r.fragments.forEach(d => {
                d.setStart(d.playlistOffset + u)
            }
            )
        }
        if (r.live || n != null && n.live) {
            const u = "levelInfo"in t ? t.levelInfo : t.track;
            if (r.reloaded(n),
            n && r.fragments.length > 0) {
                d1(n, r, this);
                const v = r.playlistParsingError;
                if (v) {
                    this.warn(v);
                    const E = this.hls;
                    if (!E.config.ignorePlaylistParsingErrors) {
                        var c;
                        const {networkDetails: T} = t;
                        E.trigger(S.ERROR, {
                            type: q.NETWORK_ERROR,
                            details: N.LEVEL_PARSING_ERROR,
                            fatal: !1,
                            url: r.url,
                            error: v,
                            reason: v.message,
                            level: t.level || void 0,
                            parent: (c = r.fragments[0]) == null ? void 0 : c.type,
                            networkDetails: T,
                            stats: i
                        });
                        return
                    }
                    r.playlistParsingError = null
                }
            }
            r.requestScheduled === -1 && (r.requestScheduled = i.loading.start);
            const d = this.hls.mainForwardBufferInfo
              , h = d ? d.end - d.len : 0
              , f = (r.edge - h) * 1e3
              , m = v0(r, f);
            if (r.requestScheduled + m < a ? r.requestScheduled = a : r.requestScheduled += m,
            this.log(`live playlist ${e} ${r.advanced ? "REFRESHED " + r.lastPartSn + "-" + r.lastPartIndex : r.updated ? "UPDATED" : "MISSED"}`),
            !this.canLoad || !r.live)
                return;
            let p, x, y;
            if (r.canBlockReload && r.endSN && r.advanced) {
                const v = this.hls.config.lowLatencyMode
                  , E = r.lastPartSn
                  , T = r.endSN
                  , L = r.lastPartIndex
                  , R = L !== -1
                  , I = E === T;
                R ? I ? (x = T + 1,
                y = v ? 0 : L) : (x = E,
                y = v ? L + 1 : r.maxPartIndex) : x = T + 1;
                const A = r.age
                  , C = A + r.ageHeader;
                let b = Math.min(C - r.partTarget, r.targetduration * 1.5);
                if (b > 0) {
                    if (C > r.targetduration * 3)
                        this.log(`Playlist last advanced ${A.toFixed(2)}s ago. Omitting segment and part directives.`),
                        x = void 0,
                        y = void 0;
                    else if (n != null && n.tuneInGoal && C - r.partTarget > n.tuneInGoal)
                        this.warn(`CDN Tune-in goal increased from: ${n.tuneInGoal} to: ${b} with playlist age: ${r.age}`),
                        b = 0;
                    else {
                        const O = Math.floor(b / r.targetduration);
                        if (x += O,
                        y !== void 0) {
                            const _ = Math.round(b % r.targetduration / r.partTarget);
                            y += _
                        }
                        this.log(`CDN Tune-in age: ${r.ageHeader}s last advanced ${A.toFixed(2)}s goal: ${b} skip sn ${O} to part ${y}`)
                    }
                    r.tuneInGoal = b
                }
                if (p = this.getDeliveryDirectives(r, t.deliveryDirectives, x, y),
                v || !I) {
                    r.requestScheduled = a,
                    this.loadingPlaylist(u, p);
                    return
                }
            } else
                (r.canBlockReload || r.canSkipUntil) && (p = this.getDeliveryDirectives(r, t.deliveryDirectives, x, y));
            p && x !== void 0 && r.canBlockReload && (r.requestScheduled = i.loading.first + Math.max(m - o * 2, m / 2)),
            this.scheduleLoading(u, p, r)
        } else
            this.clearTimer()
    }
    scheduleLoading(e, t, n) {
        const r = n || e.details;
        if (!r) {
            this.loadingPlaylist(e, t);
            return
        }
        const i = self.performance.now()
          , a = r.requestScheduled;
        if (i >= a) {
            this.loadingPlaylist(e, t);
            return
        }
        const o = a - i;
        this.log(`reload live playlist ${e.name || e.bitrate + "bps"} in ${Math.round(o)} ms`),
        this.clearTimer(),
        this.timer = self.setTimeout( () => this.loadingPlaylist(e, t), o)
    }
    getDeliveryDirectives(e, t, n, r) {
        let i = lf(e);
        return t != null && t.skip && e.deltaUpdateFailed && (n = t.msn,
        r = t.part,
        i = Fa.No),
        new cf(n,r,i)
    }
    checkRetry(e) {
        const t = e.details
          , n = Lo(e)
          , r = e.errorAction
          , {action: i, retryCount: a=0, retryConfig: o} = r || {}
          , l = !!r && !!o && (i === qe.RetryRequest || !r.resolved && i === qe.SendAlternateToPenaltyBox);
        if (l) {
            var c;
            if (a >= o.maxNumRetry)
                return !1;
            if (n && (c = e.context) != null && c.deliveryDirectives)
                this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${t}" without delivery-directives`),
                this.loadPlaylist();
            else {
                const u = pd(o, a);
                this.clearTimer(),
                this.timer = self.setTimeout( () => this.loadPlaylist(), u),
                this.warn(`Retrying playlist loading ${a + 1}/${o.maxNumRetry} after "${t}" in ${u}ms`)
            }
            e.levelRetry = !0,
            r.resolved = !0
        }
        return l
    }
}
function K0(s, e) {
    if (s.length !== e.length)
        return !1;
    for (let t = 0; t < s.length; t++)
        if (!ki(s[t].attrs, e[t].attrs))
            return !1;
    return !0
}
function ki(s, e, t) {
    const n = s["STABLE-RENDITION-ID"];
    return n && !t ? n === e["STABLE-RENDITION-ID"] : !(t || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some(r => s[r] !== e[r])
}
function ru(s, e) {
    return e.label.toLowerCase() === s.name.toLowerCase() && (!e.language || e.language.toLowerCase() === (s.lang || "").toLowerCase())
}
class EL extends Cd {
    constructor(e) {
        super(e, "audio-track-controller"),
        this.tracks = [],
        this.groupIds = null,
        this.tracksInGroup = [],
        this.trackId = -1,
        this.currentTrack = null,
        this.selectDefaultTrack = !0,
        this.registerListeners()
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(S.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(S.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.on(S.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.on(S.ERROR, this.onError, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(S.LEVEL_LOADING, this.onLevelLoading, this),
        e.off(S.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.off(S.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this),
        e.off(S.ERROR, this.onError, this)
    }
    destroy() {
        this.unregisterListeners(),
        this.tracks.length = 0,
        this.tracksInGroup.length = 0,
        this.currentTrack = null,
        super.destroy()
    }
    onManifestLoading() {
        this.tracks = [],
        this.tracksInGroup = [],
        this.groupIds = null,
        this.currentTrack = null,
        this.trackId = -1,
        this.selectDefaultTrack = !0
    }
    onManifestParsed(e, t) {
        this.tracks = t.audioTracks || []
    }
    onAudioTrackLoaded(e, t) {
        const {id: n, groupId: r, details: i} = t
          , a = this.tracksInGroup[n];
        if (!a || a.groupId !== r) {
            this.warn(`Audio track with id:${n} and group:${r} not found in active group ${a == null ? void 0 : a.groupId}`);
            return
        }
        const o = a.details;
        a.details = t.details,
        this.log(`Audio track ${n} "${a.name}" lang:${a.lang} group:${r} loaded [${i.startSN}-${i.endSN}]`),
        n === this.trackId && this.playlistLoaded(n, t, o)
    }
    onLevelLoading(e, t) {
        this.switchLevel(t.level)
    }
    onLevelSwitching(e, t) {
        this.switchLevel(t.level)
    }
    switchLevel(e) {
        const t = this.hls.levels[e];
        if (!t)
            return;
        const n = t.audioGroups || null
          , r = this.groupIds;
        let i = this.currentTrack;
        if (!n || (r == null ? void 0 : r.length) !== (n == null ? void 0 : n.length) || n != null && n.some(o => (r == null ? void 0 : r.indexOf(o)) === -1)) {
            this.groupIds = n,
            this.trackId = -1,
            this.currentTrack = null;
            const o = this.tracks.filter(h => !n || n.indexOf(h.groupId) !== -1);
            if (o.length)
                this.selectDefaultTrack && !o.some(h => h.default) && (this.selectDefaultTrack = !1),
                o.forEach( (h, f) => {
                    h.id = f
                }
                );
            else if (!i && !this.tracksInGroup.length)
                return;
            this.tracksInGroup = o;
            const l = this.hls.config.audioPreference;
            if (!i && l) {
                const h = ls(l, o, Sn);
                if (h > -1)
                    i = o[h];
                else {
                    const f = ls(l, this.tracks);
                    i = this.tracks[f]
                }
            }
            let c = this.findTrackId(i);
            c === -1 && i && (c = this.findTrackId(null));
            const u = {
                audioTracks: o
            };
            this.log(`Updating audio tracks, ${o.length} track(s) found in group(s): ${n == null ? void 0 : n.join(",")}`),
            this.hls.trigger(S.AUDIO_TRACKS_UPDATED, u);
            const d = this.trackId;
            if (c !== -1 && d === -1)
                this.setAudioTrack(c);
            else if (o.length && d === -1) {
                var a;
                const h = new Error(`No audio track selected for current audio group-ID(s): ${(a = this.groupIds) == null ? void 0 : a.join(",")} track count: ${o.length}`);
                this.warn(h.message),
                this.hls.trigger(S.ERROR, {
                    type: q.MEDIA_ERROR,
                    details: N.AUDIO_TRACK_LOAD_ERROR,
                    fatal: !0,
                    error: h
                })
            }
        }
    }
    onError(e, t) {
        t.fatal || !t.context || t.context.type === le.AUDIO_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t)
    }
    get allAudioTracks() {
        return this.tracks
    }
    get audioTracks() {
        return this.tracksInGroup
    }
    get audioTrack() {
        return this.trackId
    }
    set audioTrack(e) {
        this.selectDefaultTrack = !1,
        this.setAudioTrack(e)
    }
    setAudioOption(e) {
        const t = this.hls;
        if (t.config.audioPreference = e,
        e) {
            const n = this.allAudioTracks;
            if (this.selectDefaultTrack = !1,
            n.length) {
                const r = this.currentTrack;
                if (r && Rn(e, r, Sn))
                    return r;
                const i = ls(e, this.tracksInGroup, Sn);
                if (i > -1) {
                    const a = this.tracksInGroup[i];
                    return this.setAudioTrack(i),
                    a
                } else if (r) {
                    let a = t.loadLevel;
                    a === -1 && (a = t.firstAutoLevel);
                    const o = kT(e, t.levels, n, a, Sn);
                    if (o === -1)
                        return null;
                    t.nextLoadLevel = o
                }
                if (e.channels || e.audioCodec) {
                    const a = ls(e, n);
                    if (a > -1)
                        return n[a]
                }
            }
        }
        return null
    }
    setAudioTrack(e) {
        const t = this.tracksInGroup;
        if (e < 0 || e >= t.length) {
            this.warn(`Invalid audio track id: ${e}`);
            return
        }
        this.selectDefaultTrack = !1;
        const n = this.currentTrack
          , r = t[e]
          , i = r.details && !r.details.live;
        if (e === this.trackId && r === n && i || (this.log(`Switching to audio-track ${e} "${r.name}" lang:${r.lang} group:${r.groupId} channels:${r.channels}`),
        this.trackId = e,
        this.currentTrack = r,
        this.hls.trigger(S.AUDIO_TRACK_SWITCHING, pe({}, r)),
        i))
            return;
        const a = this.switchParams(r.url, n == null ? void 0 : n.details, r.details);
        this.loadPlaylist(a)
    }
    findTrackId(e) {
        const t = this.tracksInGroup;
        for (let n = 0; n < t.length; n++) {
            const r = t[n];
            if (!(this.selectDefaultTrack && !r.default) && (!e || Rn(e, r, Sn)))
                return n
        }
        if (e) {
            const {name: n, lang: r, assocLang: i, characteristics: a, audioCodec: o, channels: l} = e;
            for (let c = 0; c < t.length; c++) {
                const u = t[c];
                if (Rn({
                    name: n,
                    lang: r,
                    assocLang: i,
                    characteristics: a,
                    audioCodec: o,
                    channels: l
                }, u, Sn))
                    return c
            }
            for (let c = 0; c < t.length; c++) {
                const u = t[c];
                if (ki(e.attrs, u.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
                    return c
            }
            for (let c = 0; c < t.length; c++) {
                const u = t[c];
                if (ki(e.attrs, u.attrs, ["LANGUAGE"]))
                    return c
            }
        }
        return -1
    }
    loadPlaylist(e) {
        super.loadPlaylist();
        const t = this.currentTrack;
        this.shouldLoadPlaylist(t) && To(t.url, this.hls) && this.scheduleLoading(t, e)
    }
    loadingPlaylist(e, t) {
        super.loadingPlaylist(e, t);
        const n = e.id
          , r = e.groupId
          , i = this.getUrlWithDirectives(e.url, t)
          , a = e.details
          , o = a == null ? void 0 : a.age;
        this.log(`Loading audio-track ${n} "${e.name}" lang:${e.lang} group:${r}${(t == null ? void 0 : t.msn) !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${i}`),
        this.hls.trigger(S.AUDIO_TRACK_LOADING, {
            url: i,
            id: n,
            groupId: r,
            deliveryDirectives: t || null,
            track: e
        })
    }
}
class SL {
    constructor(e) {
        this.tracks = void 0,
        this.queues = {
            video: [],
            audio: [],
            audiovideo: []
        },
        this.tracks = e
    }
    destroy() {
        this.tracks = this.queues = null
    }
    append(e, t, n) {
        if (this.queues === null || this.tracks === null)
            return;
        const r = this.queues[t];
        r.push(e),
        r.length === 1 && !n && this.executeNext(t)
    }
    appendBlocker(e) {
        return new Promise(t => {
            const n = {
                label: "async-blocker",
                execute: t,
                onStart: () => {}
                ,
                onComplete: () => {}
                ,
                onError: () => {}
            };
            this.append(n, e)
        }
        )
    }
    prependBlocker(e) {
        return new Promise(t => {
            if (this.queues) {
                const n = {
                    label: "async-blocker-prepend",
                    execute: t,
                    onStart: () => {}
                    ,
                    onComplete: () => {}
                    ,
                    onError: () => {}
                };
                this.queues[e].unshift(n)
            }
        }
        )
    }
    removeBlockers() {
        this.queues !== null && [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach(e => {
            var t;
            const n = (t = e[0]) == null ? void 0 : t.label;
            (n === "async-blocker" || n === "async-blocker-prepend") && (e[0].execute(),
            e.splice(0, 1))
        }
        )
    }
    unblockAudio(e) {
        if (this.queues === null)
            return;
        this.queues.audio[0] === e && this.shiftAndExecuteNext("audio")
    }
    executeNext(e) {
        if (this.queues === null || this.tracks === null)
            return;
        const t = this.queues[e];
        if (t.length) {
            const r = t[0];
            try {
                r.execute()
            } catch (i) {
                var n;
                if (r.onError(i),
                this.queues === null || this.tracks === null)
                    return;
                const a = (n = this.tracks[e]) == null ? void 0 : n.buffer;
                a != null && a.updating || this.shiftAndExecuteNext(e)
            }
        }
    }
    shiftAndExecuteNext(e) {
        this.queues !== null && (this.queues[e].shift(),
        this.executeNext(e))
    }
    current(e) {
        var t;
        return ((t = this.queues) == null ? void 0 : t[e][0]) || null
    }
    toString() {
        const {queues: e, tracks: t} = this;
        return e === null || t === null ? "<destroyed>" : `
${this.list("video")}
${this.list("audio")}
${this.list("audiovideo")}}`
    }
    list(e) {
        var t, n;
        return (t = this.queues) != null && t[e] || (n = this.tracks) != null && n[e] ? `${e}: (${this.listSbInfo(e)}) ${this.listOps(e)}` : ""
    }
    listSbInfo(e) {
        var t;
        const n = (t = this.tracks) == null ? void 0 : t[e]
          , r = n == null ? void 0 : n.buffer;
        return r ? `SourceBuffer${r.updating ? " updating" : ""}${n.ended ? " ended" : ""}${n.ending ? " ending" : ""}` : "none"
    }
    listOps(e) {
        var t;
        return ((t = this.queues) == null ? void 0 : t[e].map(n => n.label).join(", ")) || ""
    }
}
const Wf = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/
  , W0 = "HlsJsTrackRemovedError";
class TL extends Error {
    constructor(e) {
        super(e),
        this.name = W0
    }
}
class LL extends Gt {
    constructor(e, t) {
        super("buffer-controller", e.logger),
        this.hls = void 0,
        this.fragmentTracker = void 0,
        this.details = null,
        this._objectUrl = null,
        this.operationQueue = null,
        this.bufferCodecEventsTotal = 0,
        this.media = null,
        this.mediaSource = null,
        this.lastMpegAudioChunk = null,
        this.blockedAudioAppend = null,
        this.lastVideoAppendEnd = 0,
        this.appendSource = void 0,
        this.transferData = void 0,
        this.overrides = void 0,
        this.appendErrors = {
            audio: 0,
            video: 0,
            audiovideo: 0
        },
        this.tracks = {},
        this.sourceBuffers = [[null, null], [null, null]],
        this._onEndStreaming = n => {
            var r;
            this.hls && ((r = this.mediaSource) == null ? void 0 : r.readyState) === "open" && this.hls.pauseBuffering()
        }
        ,
        this._onStartStreaming = n => {
            this.hls && this.hls.resumeBuffering()
        }
        ,
        this._onMediaSourceOpen = n => {
            const {media: r, mediaSource: i} = this;
            n && this.log("Media source opened"),
            !(!r || !i) && (i.removeEventListener("sourceopen", this._onMediaSourceOpen),
            r.removeEventListener("emptied", this._onMediaEmptied),
            this.updateDuration(),
            this.hls.trigger(S.MEDIA_ATTACHED, {
                media: r,
                mediaSource: i
            }),
            this.mediaSource !== null && this.checkPendingTracks())
        }
        ,
        this._onMediaSourceClose = () => {
            this.log("Media source closed")
        }
        ,
        this._onMediaSourceEnded = () => {
            this.log("Media source ended")
        }
        ,
        this._onMediaEmptied = () => {
            const {mediaSrc: n, _objectUrl: r} = this;
            n !== r && this.error(`Media element src was set while attaching MediaSource (${r} > ${n})`)
        }
        ,
        this.hls = e,
        this.fragmentTracker = t,
        this.appendSource = WS(on(e.config.preferManagedMediaSource)),
        this.initTracks(),
        this.registerListeners()
    }
    hasSourceTypes() {
        return Object.keys(this.tracks).length > 0
    }
    destroy() {
        this.unregisterListeners(),
        this.details = null,
        this.lastMpegAudioChunk = this.blockedAudioAppend = null,
        this.transferData = this.overrides = void 0,
        this.operationQueue && (this.operationQueue.destroy(),
        this.operationQueue = null),
        this.hls = this.fragmentTracker = null,
        this._onMediaSourceOpen = this._onMediaSourceClose = null,
        this._onMediaSourceEnded = null,
        this._onStartStreaming = this._onEndStreaming = null
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(S.BUFFER_RESET, this.onBufferReset, this),
        e.on(S.BUFFER_APPENDING, this.onBufferAppending, this),
        e.on(S.BUFFER_CODECS, this.onBufferCodecs, this),
        e.on(S.BUFFER_EOS, this.onBufferEos, this),
        e.on(S.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.on(S.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.on(S.FRAG_PARSED, this.onFragParsed, this),
        e.on(S.FRAG_CHANGED, this.onFragChanged, this),
        e.on(S.ERROR, this.onError, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e.off(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(S.BUFFER_RESET, this.onBufferReset, this),
        e.off(S.BUFFER_APPENDING, this.onBufferAppending, this),
        e.off(S.BUFFER_CODECS, this.onBufferCodecs, this),
        e.off(S.BUFFER_EOS, this.onBufferEos, this),
        e.off(S.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.off(S.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.off(S.FRAG_PARSED, this.onFragParsed, this),
        e.off(S.FRAG_CHANGED, this.onFragChanged, this),
        e.off(S.ERROR, this.onError, this)
    }
    transferMedia() {
        const {media: e, mediaSource: t} = this;
        if (!e)
            return null;
        const n = {};
        if (this.operationQueue) {
            const i = this.isUpdating();
            i || this.operationQueue.removeBlockers();
            const a = this.isQueued();
            (i || a) && this.warn(`Transfering MediaSource with${a ? " operations in queue" : ""}${i ? " updating SourceBuffer(s)" : ""} ${this.operationQueue}`),
            this.operationQueue.destroy()
        }
        const r = this.transferData;
        return !this.sourceBufferCount && r && r.mediaSource === t ? ye(n, r.tracks) : this.sourceBuffers.forEach(i => {
            const [a] = i;
            a && (n[a] = ye({}, this.tracks[a]),
            this.removeBuffer(a)),
            i[0] = i[1] = null
        }
        ),
        {
            media: e,
            mediaSource: t,
            tracks: n
        }
    }
    initTracks() {
        const e = {};
        this.sourceBuffers = [[null, null], [null, null]],
        this.tracks = e,
        this.resetQueue(),
        this.resetAppendErrors(),
        this.lastMpegAudioChunk = this.blockedAudioAppend = null,
        this.lastVideoAppendEnd = 0
    }
    onManifestLoading() {
        this.bufferCodecEventsTotal = 0,
        this.details = null
    }
    onManifestParsed(e, t) {
        var n;
        let r = 2;
        (t.audio && !t.video || !t.altAudio) && (r = 1),
        this.bufferCodecEventsTotal = r,
        this.log(`${r} bufferCodec event(s) expected.`),
        (n = this.transferData) != null && n.mediaSource && this.sourceBufferCount && r && this.bufferCreated()
    }
    onMediaAttaching(e, t) {
        const n = this.media = t.media;
        this.transferData = this.overrides = void 0;
        const r = on(this.appendSource);
        if (r) {
            const i = !!t.mediaSource;
            (i || t.overrides) && (this.transferData = t,
            this.overrides = t.overrides);
            const a = this.mediaSource = t.mediaSource || new r;
            if (this.assignMediaSource(a),
            i)
                this._objectUrl = n.src,
                this.attachTransferred();
            else {
                const o = this._objectUrl = self.URL.createObjectURL(a);
                if (this.appendSource)
                    try {
                        n.removeAttribute("src");
                        const l = self.ManagedMediaSource;
                        n.disableRemotePlayback = n.disableRemotePlayback || l && a instanceof l,
                        zf(n),
                        IL(n, o),
                        n.load()
                    } catch {
                        n.src = o
                    }
                else
                    n.src = o
            }
            n.addEventListener("emptied", this._onMediaEmptied)
        }
    }
    assignMediaSource(e) {
        var t, n;
        this.log(`${((t = this.transferData) == null ? void 0 : t.mediaSource) === e ? "transferred" : "created"} media source: ${(n = e.constructor) == null ? void 0 : n.name}`),
        e.addEventListener("sourceopen", this._onMediaSourceOpen),
        e.addEventListener("sourceended", this._onMediaSourceEnded),
        e.addEventListener("sourceclose", this._onMediaSourceClose),
        this.appendSource && (e.addEventListener("startstreaming", this._onStartStreaming),
        e.addEventListener("endstreaming", this._onEndStreaming))
    }
    attachTransferred() {
        const e = this.media
          , t = this.transferData;
        if (!t || !e)
            return;
        const n = this.tracks
          , r = t.tracks
          , i = r ? Object.keys(r) : null
          , a = i ? i.length : 0
          , o = () => {
            Promise.resolve().then( () => {
                this.media && this.mediaSourceOpenOrEnded && this._onMediaSourceOpen()
            }
            )
        }
        ;
        if (r && i && a) {
            if (!this.tracksReady) {
                this.hls.config.startFragPrefetch = !0,
                this.log("attachTransferred: waiting for SourceBuffer track info");
                return
            }
            if (this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})
required tracks: ${Te(n, (l, c) => l === "initSegment" ? void 0 : c)};
transfer tracks: ${Te(r, (l, c) => l === "initSegment" ? void 0 : c)}}`),
            !zp(r, n)) {
                t.mediaSource = null,
                t.tracks = void 0;
                const l = e.currentTime
                  , c = this.details
                  , u = Math.max(l, (c == null ? void 0 : c.fragments[0].start) || 0);
                if (u - l > 1) {
                    this.log(`attachTransferred: waiting for playback to reach new tracks start time ${l} -> ${u}`);
                    return
                }
                this.warn(`attachTransferred: resetting MediaSource for incompatible tracks ("${Object.keys(r)}"->"${Object.keys(n)}") start time: ${u} currentTime: ${l}`),
                this.onMediaDetaching(S.MEDIA_DETACHING, {}),
                this.onMediaAttaching(S.MEDIA_ATTACHING, t),
                e.currentTime = u;
                return
            }
            this.transferData = void 0,
            i.forEach(l => {
                const c = l
                  , u = r[c];
                if (u) {
                    const d = u.buffer;
                    if (d) {
                        const h = this.fragmentTracker
                          , f = u.id;
                        if (h.hasFragments(f) || h.hasParts(f)) {
                            const x = ie.getBuffered(d);
                            h.detectEvictedFragments(c, x, f, null, !0)
                        }
                        const m = $l(c)
                          , p = [c, d];
                        this.sourceBuffers[m] = p,
                        d.updating && this.operationQueue && this.operationQueue.prependBlocker(c),
                        this.trackSourceBuffer(c, u)
                    }
                }
            }
            ),
            o(),
            this.bufferCreated()
        } else
            this.log("attachTransferred: MediaSource w/o SourceBuffers"),
            o()
    }
    get mediaSourceOpenOrEnded() {
        var e;
        const t = (e = this.mediaSource) == null ? void 0 : e.readyState;
        return t === "open" || t === "ended"
    }
    onMediaDetaching(e, t) {
        const n = !!t.transferMedia;
        this.transferData = this.overrides = void 0;
        const {media: r, mediaSource: i, _objectUrl: a} = this;
        if (i) {
            if (this.log(`media source ${n ? "transferring" : "detaching"}`),
            n)
                this.sourceBuffers.forEach( ([o]) => {
                    o && this.removeBuffer(o)
                }
                ),
                this.resetQueue();
            else {
                if (this.mediaSourceOpenOrEnded) {
                    const o = i.readyState === "open";
                    try {
                        const l = i.sourceBuffers;
                        for (let c = l.length; c--; )
                            o && l[c].abort(),
                            i.removeSourceBuffer(l[c]);
                        o && i.endOfStream()
                    } catch (l) {
                        this.warn(`onMediaDetaching: ${l.message} while calling endOfStream`)
                    }
                }
                this.sourceBufferCount && this.onBufferReset()
            }
            i.removeEventListener("sourceopen", this._onMediaSourceOpen),
            i.removeEventListener("sourceended", this._onMediaSourceEnded),
            i.removeEventListener("sourceclose", this._onMediaSourceClose),
            this.appendSource && (i.removeEventListener("startstreaming", this._onStartStreaming),
            i.removeEventListener("endstreaming", this._onEndStreaming)),
            this.mediaSource = null,
            this._objectUrl = null
        }
        r && (r.removeEventListener("emptied", this._onMediaEmptied),
        n || (a && self.URL.revokeObjectURL(a),
        this.mediaSrc === a ? (r.removeAttribute("src"),
        this.appendSource && zf(r),
        r.load()) : this.warn("media|source.src was changed by a third party - skip cleanup")),
        this.media = null),
        this.hls.trigger(S.MEDIA_DETACHED, t)
    }
    onBufferReset() {
        this.sourceBuffers.forEach( ([e]) => {
            e && this.resetBuffer(e)
        }
        ),
        this.initTracks()
    }
    resetBuffer(e) {
        var t;
        const n = (t = this.tracks[e]) == null ? void 0 : t.buffer;
        if (this.removeBuffer(e),
        n)
            try {
                var r;
                (r = this.mediaSource) != null && r.sourceBuffers.length && this.mediaSource.removeSourceBuffer(n)
            } catch (i) {
                this.warn(`onBufferReset ${e}`, i)
            }
        delete this.tracks[e]
    }
    removeBuffer(e) {
        this.removeBufferListeners(e),
        this.sourceBuffers[$l(e)] = [null, null];
        const t = this.tracks[e];
        t && (t.buffer = void 0)
    }
    resetQueue() {
        this.operationQueue && this.operationQueue.destroy(),
        this.operationQueue = new SL(this.tracks)
    }
    onBufferCodecs(e, t) {
        const n = this.tracks
          , r = Object.keys(t);
        this.log(`BUFFER_CODECS: "${r}" (current SB count ${this.sourceBufferCount})`);
        const i = "audiovideo"in t && (n.audio || n.video) || n.audiovideo && ("audio"in t || "video"in t)
          , a = !i && this.sourceBufferCount && this.media && r.some(o => !n[o]);
        if (i || a) {
            this.warn(`Unsupported transition between "${Object.keys(n)}" and "${r}" SourceBuffers`);
            return
        }
        r.forEach(o => {
            var l, c;
            const u = t[o]
              , {id: d, codec: h, levelCodec: f, container: m, metadata: p, supplemental: x} = u;
            let y = n[o];
            const v = (l = this.transferData) == null || (l = l.tracks) == null ? void 0 : l[o]
              , E = v != null && v.buffer ? v : y
              , T = (E == null ? void 0 : E.pendingCodec) || (E == null ? void 0 : E.codec)
              , L = E == null ? void 0 : E.levelCodec;
            y || (y = n[o] = {
                buffer: void 0,
                listeners: [],
                codec: h,
                supplemental: x,
                container: m,
                levelCodec: f,
                metadata: p,
                id: d
            });
            const R = Ma(T, L)
              , I = R == null ? void 0 : R.replace(Wf, "$1");
            let A = Ma(h, f);
            const C = (c = A) == null ? void 0 : c.replace(Wf, "$1");
            A && R && I !== C && (o.slice(0, 5) === "audio" && (A = Eo(A, this.appendSource)),
            this.log(`switching codec ${T} to ${A}`),
            A !== (y.pendingCodec || y.codec) && (y.pendingCodec = A),
            y.container = m,
            this.appendChangeType(o, m, A))
        }
        ),
        (this.tracksReady || this.sourceBufferCount) && (t.tracks = this.sourceBufferTracks),
        !this.sourceBufferCount && this.mediaSourceOpenOrEnded && this.checkPendingTracks()
    }
    get sourceBufferTracks() {
        return Object.keys(this.tracks).reduce( (e, t) => {
            const n = this.tracks[t];
            return e[t] = {
                id: n.id,
                container: n.container,
                codec: n.codec,
                levelCodec: n.levelCodec
            },
            e
        }
        , {})
    }
    appendChangeType(e, t, n) {
        const r = `${t};codecs=${n}`
          , i = {
            label: `change-type=${r}`,
            execute: () => {
                const a = this.tracks[e];
                if (a) {
                    const o = a.buffer;
                    o != null && o.changeType && (this.log(`changing ${e} sourceBuffer type to ${r}`),
                    o.changeType(r),
                    a.codec = n,
                    a.container = t)
                }
                this.shiftAndExecuteNext(e)
            }
            ,
            onStart: () => {}
            ,
            onComplete: () => {}
            ,
            onError: a => {
                this.warn(`Failed to change ${e} SourceBuffer type`, a)
            }
        };
        this.append(i, e, this.isPending(this.tracks[e]))
    }
    blockAudio(e) {
        var t;
        const n = e.start
          , r = n + e.duration * .05;
        if (((t = this.fragmentTracker.getAppendedFrag(n, X.MAIN)) == null ? void 0 : t.gap) === !0)
            return;
        const a = {
            label: "block-audio",
            execute: () => {
                var o;
                const l = this.tracks.video;
                (this.lastVideoAppendEnd > r || l != null && l.buffer && ie.isBuffered(l.buffer, r) || ((o = this.fragmentTracker.getAppendedFrag(r, X.MAIN)) == null ? void 0 : o.gap) === !0) && (this.blockedAudioAppend = null,
                this.shiftAndExecuteNext("audio"))
            }
            ,
            onStart: () => {}
            ,
            onComplete: () => {}
            ,
            onError: o => {
                this.warn("Error executing block-audio operation", o)
            }
        };
        this.blockedAudioAppend = {
            op: a,
            frag: e
        },
        this.append(a, "audio", !0)
    }
    unblockAudio() {
        const {blockedAudioAppend: e, operationQueue: t} = this;
        e && t && (this.blockedAudioAppend = null,
        t.unblockAudio(e.op))
    }
    onBufferAppending(e, t) {
        const {tracks: n} = this
          , {data: r, type: i, parent: a, frag: o, part: l, chunkMeta: c, offset: u} = t
          , d = c.buffering[i]
          , {sn: h, cc: f} = o
          , m = self.performance.now();
        d.start = m;
        const p = o.stats.buffering
          , x = l ? l.stats.buffering : null;
        p.start === 0 && (p.start = m),
        x && x.start === 0 && (x.start = m);
        const y = n.audio;
        let v = !1;
        i === "audio" && (y == null ? void 0 : y.container) === "audio/mpeg" && (v = !this.lastMpegAudioChunk || c.id === 1 || this.lastMpegAudioChunk.sn !== c.sn,
        this.lastMpegAudioChunk = c);
        const E = n.video
          , T = E == null ? void 0 : E.buffer;
        if (T && h !== "initSegment") {
            const I = l || o
              , A = this.blockedAudioAppend;
            if (i === "audio" && a !== "main" && !this.blockedAudioAppend && !(E.ending || E.ended)) {
                const b = I.start + I.duration * .05
                  , O = T.buffered
                  , _ = this.currentOp("video");
                !O.length && !_ ? this.blockAudio(I) : !_ && !ie.isBuffered(T, b) && this.lastVideoAppendEnd < b && this.blockAudio(I)
            } else if (i === "video") {
                const C = I.end;
                if (A) {
                    const b = A.frag.start;
                    (C > b || C < this.lastVideoAppendEnd || ie.isBuffered(T, b)) && this.unblockAudio()
                }
                this.lastVideoAppendEnd = C
            }
        }
        const L = (l || o).start
          , R = {
            label: `append-${i}`,
            execute: () => {
                var I;
                d.executeStart = self.performance.now();
                const A = (I = this.tracks[i]) == null ? void 0 : I.buffer;
                A && (v ? this.updateTimestampOffset(A, L, .1, i, h, f) : u !== void 0 && z(u) && this.updateTimestampOffset(A, u, 1e-6, i, h, f)),
                this.appendExecutor(r, i)
            }
            ,
            onStart: () => {}
            ,
            onComplete: () => {
                const I = self.performance.now();
                d.executeEnd = d.end = I,
                p.first === 0 && (p.first = I),
                x && x.first === 0 && (x.first = I);
                const A = {};
                this.sourceBuffers.forEach( ([C,b]) => {
                    C && (A[C] = ie.getBuffered(b))
                }
                ),
                this.appendErrors[i] = 0,
                i === "audio" || i === "video" ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0,
                this.appendErrors.video = 0),
                this.hls.trigger(S.BUFFER_APPENDED, {
                    type: i,
                    frag: o,
                    part: l,
                    chunkMeta: c,
                    parent: o.type,
                    timeRanges: A
                })
            }
            ,
            onError: I => {
                var A;
                const C = {
                    type: q.MEDIA_ERROR,
                    parent: o.type,
                    details: N.BUFFER_APPEND_ERROR,
                    sourceBufferName: i,
                    frag: o,
                    part: l,
                    chunkMeta: c,
                    error: I,
                    err: I,
                    fatal: !1
                }
                  , b = (A = this.media) == null ? void 0 : A.error;
                if (I.code === DOMException.QUOTA_EXCEEDED_ERR || I.name == "QuotaExceededError" || "quota"in I)
                    C.details = N.BUFFER_FULL_ERROR;
                else if (I.code === DOMException.INVALID_STATE_ERR && this.mediaSourceOpenOrEnded && !b)
                    C.errorAction = hr(!0);
                else if (I.name === W0 && this.sourceBufferCount === 0)
                    C.errorAction = hr(!0);
                else {
                    const O = ++this.appendErrors[i];
                    this.warn(`Failed ${O}/${this.hls.config.appendErrorMaxRetry} times to append segment in "${i}" sourceBuffer (${b || "no media error"})`),
                    (O >= this.hls.config.appendErrorMaxRetry || b) && (C.fatal = !0)
                }
                this.hls.trigger(S.ERROR, C)
            }
        };
        this.append(R, i, this.isPending(this.tracks[i]))
    }
    getFlushOp(e, t, n) {
        return this.log(`queuing "${e}" remove ${t}-${n}`),
        {
            label: "remove",
            execute: () => {
                this.removeExecutor(e, t, n)
            }
            ,
            onStart: () => {}
            ,
            onComplete: () => {
                this.hls.trigger(S.BUFFER_FLUSHED, {
                    type: e
                })
            }
            ,
            onError: r => {
                this.warn(`Failed to remove ${t}-${n} from "${e}" SourceBuffer`, r)
            }
        }
    }
    onBufferFlushing(e, t) {
        const {type: n, startOffset: r, endOffset: i} = t;
        n ? this.append(this.getFlushOp(n, r, i), n) : this.sourceBuffers.forEach( ([a]) => {
            a && this.append(this.getFlushOp(a, r, i), a)
        }
        )
    }
    onFragParsed(e, t) {
        const {frag: n, part: r} = t
          , i = []
          , a = r ? r.elementaryStreams : n.elementaryStreams;
        a[xe.AUDIOVIDEO] ? i.push("audiovideo") : (a[xe.AUDIO] && i.push("audio"),
        a[xe.VIDEO] && i.push("video"));
        const o = () => {
            const l = self.performance.now();
            n.stats.buffering.end = l,
            r && (r.stats.buffering.end = l);
            const c = r ? r.stats : n.stats;
            this.hls.trigger(S.FRAG_BUFFERED, {
                frag: n,
                part: r,
                stats: c,
                id: n.type
            })
        }
        ;
        i.length === 0 && this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${n.type} level: ${n.level} sn: ${n.sn}`),
        this.blockBuffers(o, i).catch(l => {
            this.warn(`Fragment buffered callback ${l}`),
            this.stepOperationQueue(this.sourceBufferTypes)
        }
        )
    }
    onFragChanged(e, t) {
        this.trimBuffers()
    }
    get bufferedToEnd() {
        return this.sourceBufferCount > 0 && !this.sourceBuffers.some( ([e]) => {
            if (e) {
                const t = this.tracks[e];
                if (t)
                    return !t.ended || t.ending
            }
            return !1
        }
        )
    }
    onBufferEos(e, t) {
        var n;
        this.sourceBuffers.forEach( ([a]) => {
            if (a) {
                const o = this.tracks[a];
                (!t.type || t.type === a) && (o.ending = !0,
                o.ended || (o.ended = !0,
                this.log(`${a} buffer reached EOS`)))
            }
        }
        );
        const r = ((n = this.overrides) == null ? void 0 : n.endOfStream) !== !1;
        this.sourceBufferCount > 0 && !this.sourceBuffers.some( ([a]) => {
            var o;
            return a && !((o = this.tracks[a]) != null && o.ended)
        }
        ) ? r ? (this.log("Queueing EOS"),
        this.blockUntilOpen( () => {
            this.tracksEnded();
            const {mediaSource: a} = this;
            if (!a || a.readyState !== "open") {
                a && this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${a.readyState}`);
                return
            }
            this.log("Calling mediaSource.endOfStream()"),
            a.endOfStream(),
            this.hls.trigger(S.BUFFERED_TO_END, void 0)
        }
        )) : (this.tracksEnded(),
        this.hls.trigger(S.BUFFERED_TO_END, void 0)) : t.type === "video" && this.unblockAudio()
    }
    tracksEnded() {
        this.sourceBuffers.forEach( ([e]) => {
            if (e !== null) {
                const t = this.tracks[e];
                t && (t.ending = !1)
            }
        }
        )
    }
    onLevelUpdated(e, {details: t}) {
        t.fragments.length && (this.details = t,
        this.updateDuration())
    }
    updateDuration() {
        this.blockUntilOpen( () => {
            const e = this.getDurationAndRange();
            e && this.updateMediaSource(e)
        }
        )
    }
    onError(e, t) {
        if (t.details === N.BUFFER_APPEND_ERROR && t.frag) {
            var n;
            const r = (n = t.errorAction) == null ? void 0 : n.nextAutoLevel;
            z(r) && r !== t.frag.level && this.resetAppendErrors()
        }
    }
    resetAppendErrors() {
        this.appendErrors = {
            audio: 0,
            video: 0,
            audiovideo: 0
        }
    }
    trimBuffers() {
        const {hls: e, details: t, media: n} = this;
        if (!n || t === null || !this.sourceBufferCount)
            return;
        const r = e.config
          , i = n.currentTime
          , a = t.levelTargetDuration
          , o = t.live && r.liveBackBufferLength !== null ? r.liveBackBufferLength : r.backBufferLength;
        if (z(o) && o >= 0) {
            const c = Math.max(o, a)
              , u = Math.floor(i / a) * a - c;
            this.flushBackBuffer(i, a, u)
        }
        const l = r.frontBufferFlushThreshold;
        if (z(l) && l > 0) {
            const c = Math.max(r.maxBufferLength, l)
              , u = Math.max(c, a)
              , d = Math.floor(i / a) * a + u;
            this.flushFrontBuffer(i, a, d)
        }
    }
    flushBackBuffer(e, t, n) {
        this.sourceBuffers.forEach( ([r,i]) => {
            if (i) {
                const o = ie.getBuffered(i);
                if (o.length > 0 && n > o.start(0)) {
                    var a;
                    this.hls.trigger(S.BACK_BUFFER_REACHED, {
                        bufferEnd: n
                    });
                    const l = this.tracks[r];
                    if ((a = this.details) != null && a.live)
                        this.hls.trigger(S.LIVE_BACK_BUFFER_REACHED, {
                            bufferEnd: n
                        });
                    else if (l != null && l.ended) {
                        this.log(`Cannot flush ${r} back buffer while SourceBuffer is in ended state`);
                        return
                    }
                    this.hls.trigger(S.BUFFER_FLUSHING, {
                        startOffset: 0,
                        endOffset: n,
                        type: r
                    })
                }
            }
        }
        )
    }
    flushFrontBuffer(e, t, n) {
        this.sourceBuffers.forEach( ([r,i]) => {
            if (i) {
                const a = ie.getBuffered(i)
                  , o = a.length;
                if (o < 2)
                    return;
                const l = a.start(o - 1)
                  , c = a.end(o - 1);
                if (n > l || e >= l && e <= c)
                    return;
                this.hls.trigger(S.BUFFER_FLUSHING, {
                    startOffset: l,
                    endOffset: 1 / 0,
                    type: r
                })
            }
        }
        )
    }
    getDurationAndRange() {
        var e;
        const {details: t, mediaSource: n} = this;
        if (!t || !this.media || (n == null ? void 0 : n.readyState) !== "open")
            return null;
        const r = t.edge;
        if (t.live && this.hls.config.liveDurationInfinity) {
            if (t.fragments.length && n.setLiveSeekableRange) {
                const c = Math.max(0, t.fragmentStart)
                  , u = Math.max(c, r);
                return {
                    duration: 1 / 0,
                    start: c,
                    end: u
                }
            }
            return {
                duration: 1 / 0
            }
        }
        const i = (e = this.overrides) == null ? void 0 : e.duration;
        if (i)
            return z(i) ? {
                duration: i
            } : null;
        const a = this.media.duration
          , o = z(n.duration) ? n.duration : 0;
        return r > o && r > a || !z(a) ? {
            duration: r
        } : null
    }
    updateMediaSource({duration: e, start: t, end: n}) {
        const r = this.mediaSource;
        !this.media || !r || r.readyState !== "open" || (r.duration !== e && (z(e) && this.log(`Updating MediaSource duration to ${e.toFixed(3)}`),
        r.duration = e),
        t !== void 0 && n !== void 0 && (this.log(`MediaSource duration is set to ${r.duration}. Setting seekable range to ${t}-${n}.`),
        r.setLiveSeekableRange(t, n)))
    }
    get tracksReady() {
        const e = this.pendingTrackCount;
        return e > 0 && (e >= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo))
    }
    checkPendingTracks() {
        const {bufferCodecEventsTotal: e, pendingTrackCount: t, tracks: n} = this;
        if (this.log(`checkPendingTracks (pending: ${t} codec events expected: ${e}) ${Te(n)}`),
        this.tracksReady) {
            var r;
            const i = (r = this.transferData) == null ? void 0 : r.tracks;
            i && Object.keys(i).length ? this.attachTransferred() : this.createSourceBuffers()
        }
    }
    bufferCreated() {
        if (this.sourceBufferCount) {
            const e = {};
            this.sourceBuffers.forEach( ([t,n]) => {
                if (t) {
                    const r = this.tracks[t];
                    e[t] = {
                        buffer: n,
                        container: r.container,
                        codec: r.codec,
                        supplemental: r.supplemental,
                        levelCodec: r.levelCodec,
                        id: r.id,
                        metadata: r.metadata
                    }
                }
            }
            ),
            this.hls.trigger(S.BUFFER_CREATED, {
                tracks: e
            }),
            this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`),
            this.sourceBuffers.forEach( ([t]) => {
                this.executeNext(t)
            }
            )
        } else {
            const e = new Error("could not create source buffer for media codec(s)");
            this.hls.trigger(S.ERROR, {
                type: q.MEDIA_ERROR,
                details: N.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                fatal: !0,
                error: e,
                reason: e.message
            })
        }
    }
    createSourceBuffers() {
        const {tracks: e, sourceBuffers: t, mediaSource: n} = this;
        if (!n)
            throw new Error("createSourceBuffers called when mediaSource was null");
        for (const i in e) {
            const a = i
              , o = e[a];
            if (this.isPending(o)) {
                const l = this.getTrackCodec(o, a)
                  , c = `${o.container};codecs=${l}`;
                o.codec = l,
                this.log(`creating sourceBuffer(${c})${this.currentOp(a) ? " Queued" : ""} ${Te(o)}`);
                try {
                    const u = n.addSourceBuffer(c)
                      , d = $l(a)
                      , h = [a, u];
                    t[d] = h,
                    o.buffer = u
                } catch (u) {
                    var r;
                    this.error(`error while trying to add sourceBuffer: ${u.message}`),
                    this.shiftAndExecuteNext(a),
                    (r = this.operationQueue) == null || r.removeBlockers(),
                    delete this.tracks[a],
                    this.hls.trigger(S.ERROR, {
                        type: q.MEDIA_ERROR,
                        details: N.BUFFER_ADD_CODEC_ERROR,
                        fatal: !1,
                        error: u,
                        sourceBufferName: a,
                        mimeType: c,
                        parent: o.id
                    });
                    return
                }
                this.trackSourceBuffer(a, o)
            }
        }
        this.bufferCreated()
    }
    getTrackCodec(e, t) {
        const n = e.supplemental;
        let r = e.codec;
        n && (t === "video" || t === "audiovideo") && Yc(n, "video") && (r = dT(r, n));
        const i = Ma(r, e.levelCodec);
        return i ? t.slice(0, 5) === "audio" ? Eo(i, this.appendSource) : i : ""
    }
    trackSourceBuffer(e, t) {
        const n = t.buffer;
        if (!n)
            return;
        const r = this.getTrackCodec(t, e);
        this.tracks[e] = {
            buffer: n,
            codec: r,
            container: t.container,
            levelCodec: t.levelCodec,
            supplemental: t.supplemental,
            metadata: t.metadata,
            id: t.id,
            listeners: []
        },
        this.removeBufferListeners(e),
        this.addBufferListener(e, "updatestart", this.onSBUpdateStart),
        this.addBufferListener(e, "updateend", this.onSBUpdateEnd),
        this.addBufferListener(e, "error", this.onSBUpdateError),
        this.appendSource && this.addBufferListener(e, "bufferedchange", (i, a) => {
            const o = a.removedRanges;
            o != null && o.length && this.hls.trigger(S.BUFFER_FLUSHED, {
                type: i
            })
        }
        )
    }
    get mediaSrc() {
        var e, t;
        const n = ((e = this.media) == null || (t = e.querySelector) == null ? void 0 : t.call(e, "source")) || this.media;
        return n == null ? void 0 : n.src
    }
    onSBUpdateStart(e) {
        const t = this.currentOp(e);
        t && t.onStart()
    }
    onSBUpdateEnd(e) {
        var t;
        if (((t = this.mediaSource) == null ? void 0 : t.readyState) === "closed") {
            this.resetBuffer(e);
            return
        }
        const n = this.currentOp(e);
        n && (n.onComplete(),
        this.shiftAndExecuteNext(e))
    }
    onSBUpdateError(e, t) {
        var n;
        const r = new Error(`${e} SourceBuffer error. MediaSource readyState: ${(n = this.mediaSource) == null ? void 0 : n.readyState}`);
        this.error(`${r}`, t),
        this.hls.trigger(S.ERROR, {
            type: q.MEDIA_ERROR,
            details: N.BUFFER_APPENDING_ERROR,
            sourceBufferName: e,
            error: r,
            fatal: !1
        });
        const i = this.currentOp(e);
        i && i.onError(r)
    }
    updateTimestampOffset(e, t, n, r, i, a) {
        const o = t - e.timestampOffset;
        Math.abs(o) >= n && (this.log(`Updating ${r} SourceBuffer timestampOffset to ${t} (sn: ${i} cc: ${a})`),
        e.timestampOffset = t)
    }
    removeExecutor(e, t, n) {
        const {media: r, mediaSource: i} = this
          , a = this.tracks[e]
          , o = a == null ? void 0 : a.buffer;
        if (!r || !i || !o) {
            this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`),
            this.shiftAndExecuteNext(e);
            return
        }
        const l = z(r.duration) ? r.duration : 1 / 0
          , c = z(i.duration) ? i.duration : 1 / 0
          , u = Math.max(0, t)
          , d = Math.min(n, l, c);
        d > u && (!a.ending || a.ended) ? (a.ended = !1,
        this.log(`Removing [${u},${d}] from the ${e} SourceBuffer`),
        o.remove(u, d)) : this.shiftAndExecuteNext(e)
    }
    appendExecutor(e, t) {
        const n = this.tracks[t]
          , r = n == null ? void 0 : n.buffer;
        if (!r)
            throw new TL(`Attempting to append to the ${t} SourceBuffer, but it does not exist`);
        n.ending = !1,
        n.ended = !1,
        r.appendBuffer(e)
    }
    blockUntilOpen(e) {
        if (this.isUpdating() || this.isQueued())
            this.blockBuffers(e).catch(t => {
                this.warn(`SourceBuffer blocked callback ${t}`),
                this.stepOperationQueue(this.sourceBufferTypes)
            }
            );
        else
            try {
                e()
            } catch (t) {
                this.warn(`Callback run without blocking ${this.operationQueue} ${t}`)
            }
    }
    isUpdating() {
        return this.sourceBuffers.some( ([e,t]) => e && t.updating)
    }
    isQueued() {
        return this.sourceBuffers.some( ([e]) => e && !!this.currentOp(e))
    }
    isPending(e) {
        return !!e && !e.buffer
    }
    blockBuffers(e, t=this.sourceBufferTypes) {
        if (!t.length)
            return this.log("Blocking operation requested, but no SourceBuffers exist"),
            Promise.resolve().then(e);
        const {operationQueue: n} = this
          , r = t.map(a => this.appendBlocker(a));
        return t.length > 1 && !!this.blockedAudioAppend && this.unblockAudio(),
        Promise.all(r).then(a => {
            n === this.operationQueue && (e(),
            this.stepOperationQueue(this.sourceBufferTypes))
        }
        )
    }
    stepOperationQueue(e) {
        e.forEach(t => {
            var n;
            const r = (n = this.tracks[t]) == null ? void 0 : n.buffer;
            !r || r.updating || this.shiftAndExecuteNext(t)
        }
        )
    }
    append(e, t, n) {
        this.operationQueue && this.operationQueue.append(e, t, n)
    }
    appendBlocker(e) {
        if (this.operationQueue)
            return this.operationQueue.appendBlocker(e)
    }
    currentOp(e) {
        return this.operationQueue ? this.operationQueue.current(e) : null
    }
    executeNext(e) {
        e && this.operationQueue && this.operationQueue.executeNext(e)
    }
    shiftAndExecuteNext(e) {
        this.operationQueue && this.operationQueue.shiftAndExecuteNext(e)
    }
    get pendingTrackCount() {
        return Object.keys(this.tracks).reduce( (e, t) => e + (this.isPending(this.tracks[t]) ? 1 : 0), 0)
    }
    get sourceBufferCount() {
        return this.sourceBuffers.reduce( (e, [t]) => e + (t ? 1 : 0), 0)
    }
    get sourceBufferTypes() {
        return this.sourceBuffers.map( ([e]) => e).filter(e => !!e)
    }
    addBufferListener(e, t, n) {
        const r = this.tracks[e];
        if (!r)
            return;
        const i = r.buffer;
        if (!i)
            return;
        const a = n.bind(this, e);
        r.listeners.push({
            event: t,
            listener: a
        }),
        i.addEventListener(t, a)
    }
    removeBufferListeners(e) {
        const t = this.tracks[e];
        if (!t)
            return;
        const n = t.buffer;
        n && (t.listeners.forEach(r => {
            n.removeEventListener(r.event, r.listener)
        }
        ),
        t.listeners.length = 0)
    }
}
function zf(s) {
    const e = s.querySelectorAll("source");
    [].slice.call(e).forEach(t => {
        s.removeChild(t)
    }
    )
}
function IL(s, e) {
    const t = self.document.createElement("source");
    t.type = "video/mp4",
    t.src = e,
    s.appendChild(t)
}
function $l(s) {
    return s === "audio" ? 1 : 0
}
class kd {
    constructor(e) {
        this.hls = void 0,
        this.autoLevelCapping = void 0,
        this.firstLevel = void 0,
        this.media = void 0,
        this.restrictedLevels = void 0,
        this.timer = void 0,
        this.clientRect = void 0,
        this.streamController = void 0,
        this.hls = e,
        this.autoLevelCapping = Number.POSITIVE_INFINITY,
        this.firstLevel = -1,
        this.media = null,
        this.restrictedLevels = [],
        this.timer = void 0,
        this.clientRect = null,
        this.registerListeners()
    }
    setStreamController(e) {
        this.streamController = e
    }
    destroy() {
        this.hls && this.unregisterListener(),
        this.timer && this.stopCapping(),
        this.media = null,
        this.clientRect = null,
        this.hls = this.streamController = null
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(S.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
        e.on(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(S.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(S.BUFFER_CODECS, this.onBufferCodecs, this),
        e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this)
    }
    unregisterListener() {
        const {hls: e} = this;
        e.off(S.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this),
        e.off(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(S.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(S.BUFFER_CODECS, this.onBufferCodecs, this),
        e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this)
    }
    onFpsDropLevelCapping(e, t) {
        const n = this.hls.levels[t.droppedLevel];
        this.isLevelAllowed(n) && this.restrictedLevels.push({
            bitrate: n.bitrate,
            height: n.height,
            width: n.width
        })
    }
    onMediaAttaching(e, t) {
        this.media = t.media instanceof HTMLVideoElement ? t.media : null,
        this.clientRect = null,
        this.timer && this.hls.levels.length && this.detectPlayerSize()
    }
    onManifestParsed(e, t) {
        const n = this.hls;
        this.restrictedLevels = [],
        this.firstLevel = t.firstLevel,
        n.config.capLevelToPlayerSize && t.video && this.startCapping()
    }
    onLevelsUpdated(e, t) {
        this.timer && z(this.autoLevelCapping) && this.detectPlayerSize()
    }
    onBufferCodecs(e, t) {
        this.hls.config.capLevelToPlayerSize && t.video && this.startCapping()
    }
    onMediaDetaching() {
        this.stopCapping(),
        this.media = null
    }
    detectPlayerSize() {
        if (this.media) {
            if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
                this.clientRect = null;
                return
            }
            const e = this.hls.levels;
            if (e.length) {
                const t = this.hls
                  , n = this.getMaxLevel(e.length - 1);
                n !== this.autoLevelCapping && t.logger.log(`Setting autoLevelCapping to ${n}: ${e[n].height}p@${e[n].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`),
                t.autoLevelCapping = n,
                t.autoLevelEnabled && t.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(),
                this.autoLevelCapping = t.autoLevelCapping
            }
        }
    }
    getMaxLevel(e) {
        const t = this.hls.levels;
        if (!t.length)
            return -1;
        const n = t.filter( (r, i) => this.isLevelAllowed(r) && i <= e);
        return this.clientRect = null,
        kd.getMaxLevelByMediaSize(n, this.mediaWidth, this.mediaHeight)
    }
    startCapping() {
        this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY,
        self.clearInterval(this.timer),
        this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3),
        this.detectPlayerSize())
    }
    stopCapping() {
        this.restrictedLevels = [],
        this.firstLevel = -1,
        this.autoLevelCapping = Number.POSITIVE_INFINITY,
        this.timer && (self.clearInterval(this.timer),
        this.timer = void 0)
    }
    getDimensions() {
        if (this.clientRect)
            return this.clientRect;
        const e = this.media
          , t = {
            width: 0,
            height: 0
        };
        if (e) {
            const n = e.getBoundingClientRect();
            t.width = n.width,
            t.height = n.height,
            !t.width && !t.height && (t.width = n.right - n.left || e.width || 0,
            t.height = n.bottom - n.top || e.height || 0)
        }
        return this.clientRect = t,
        t
    }
    get mediaWidth() {
        return this.getDimensions().width * this.contentScaleFactor
    }
    get mediaHeight() {
        return this.getDimensions().height * this.contentScaleFactor
    }
    get contentScaleFactor() {
        let e = 1;
        if (!this.hls.config.ignoreDevicePixelRatio)
            try {
                e = self.devicePixelRatio
            } catch {}
        return Math.min(e, this.hls.config.maxDevicePixelRatio)
    }
    isLevelAllowed(e) {
        return !this.restrictedLevels.some(n => e.bitrate === n.bitrate && e.width === n.width && e.height === n.height)
    }
    static getMaxLevelByMediaSize(e, t, n) {
        if (!(e != null && e.length))
            return -1;
        const r = (o, l) => l ? o.width !== l.width || o.height !== l.height : !0;
        let i = e.length - 1;
        const a = Math.max(t, n);
        for (let o = 0; o < e.length; o += 1) {
            const l = e[o];
            if ((l.width >= a || l.height >= a) && r(l, e[o + 1])) {
                i = o;
                break
            }
        }
        return i
    }
}
const AL = {
    MANIFEST: "m",
    AUDIO: "a",
    VIDEO: "v",
    MUXED: "av",
    INIT: "i",
    CAPTION: "c",
    TIMED_TEXT: "tt",
    KEY: "k",
    OTHER: "o"
}
  , ft = AL
  , bL = {
    HLS: "h"
}
  , RL = bL;
class fs {
    constructor(e, t) {
        Array.isArray(e) && (e = e.map(n => n instanceof fs ? n : new fs(n))),
        this.value = e,
        this.params = t
    }
}
const wL = "Dict";
function CL(s) {
    return Array.isArray(s) ? JSON.stringify(s) : s instanceof Map ? "Map{}" : s instanceof Set ? "Set{}" : typeof s == "object" ? JSON.stringify(s) : String(s)
}
function kL(s, e, t, n) {
    return new Error(`failed to ${s} "${CL(e)}" as ${t}`,{
        cause: n
    })
}
function ms(s, e, t) {
    return kL("serialize", s, e, t)
}
class z0 {
    constructor(e) {
        this.description = e
    }
}
const Yf = "Bare Item"
  , _L = "Boolean";
function DL(s) {
    if (typeof s != "boolean")
        throw ms(s, _L);
    return s ? "?1" : "?0"
}
function PL(s) {
    return btoa(String.fromCharCode(...s))
}
const NL = "Byte Sequence";
function OL(s) {
    if (ArrayBuffer.isView(s) === !1)
        throw ms(s, NL);
    return `:${PL(s)}:`
}
const ML = "Integer";
function FL(s) {
    return s < -999999999999999 || 999999999999999 < s
}
function Y0(s) {
    if (FL(s))
        throw ms(s, ML);
    return s.toString()
}
function UL(s) {
    return `@${Y0(s.getTime() / 1e3)}`
}
function X0(s, e) {
    if (s < 0)
        return -X0(-s, e);
    const t = Math.pow(10, e);
    if (Math.abs(s * t % 1 - .5) < Number.EPSILON) {
        const r = Math.floor(s * t);
        return (r % 2 === 0 ? r : r + 1) / t
    } else
        return Math.round(s * t) / t
}
const BL = "Decimal";
function $L(s) {
    const e = X0(s, 3);
    if (Math.floor(Math.abs(e)).toString().length > 12)
        throw ms(s, BL);
    const t = e.toString();
    return t.includes(".") ? t : `${t}.0`
}
const jL = "String"
  , GL = /[\x00-\x1f\x7f]+/;
function VL(s) {
    if (GL.test(s))
        throw ms(s, jL);
    return `"${s.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`
}
function HL(s) {
    return s.description || s.toString().slice(7, -1)
}
const KL = "Token";
function Xf(s) {
    const e = HL(s);
    if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(e) === !1)
        throw ms(e, KL);
    return e
}
function iu(s) {
    switch (typeof s) {
    case "number":
        if (!z(s))
            throw ms(s, Yf);
        return Number.isInteger(s) ? Y0(s) : $L(s);
    case "string":
        return VL(s);
    case "symbol":
        return Xf(s);
    case "boolean":
        return DL(s);
    case "object":
        if (s instanceof Date)
            return UL(s);
        if (s instanceof Uint8Array)
            return OL(s);
        if (s instanceof z0)
            return Xf(s);
    default:
        throw ms(s, Yf)
    }
}
const WL = "Key";
function au(s) {
    if (/^[a-z*][a-z0-9\-_.*]*$/.test(s) === !1)
        throw ms(s, WL);
    return s
}
function _d(s) {
    return s == null ? "" : Object.entries(s).map( ([e,t]) => t === !0 ? `;${au(e)}` : `;${au(e)}=${iu(t)}`).join("")
}
function Z0(s) {
    return s instanceof fs ? `${iu(s.value)}${_d(s.params)}` : iu(s)
}
function zL(s) {
    return `(${s.value.map(Z0).join(" ")})${_d(s.params)}`
}
function YL(s, e={
    whitespace: !0
}) {
    if (typeof s != "object" || s == null)
        throw ms(s, wL);
    const t = s instanceof Map ? s.entries() : Object.entries(s)
      , n = e != null && e.whitespace ? " " : "";
    return Array.from(t).map( ([r,i]) => {
        i instanceof fs || (i = new fs(i));
        let a = au(r);
        return i.value === !0 ? a += _d(i.params) : (a += "=",
        Array.isArray(i.value) ? a += zL(i) : a += Z0(i)),
        a
    }
    ).join(`,${n}`)
}
function q0(s, e) {
    return YL(s, e)
}
const ns = "CMCD-Object"
  , _e = "CMCD-Request"
  , yn = "CMCD-Session"
  , $s = "CMCD-Status"
  , XL = {
    br: ns,
    ab: ns,
    d: ns,
    ot: ns,
    tb: ns,
    tpb: ns,
    lb: ns,
    tab: ns,
    lab: ns,
    url: ns,
    pb: _e,
    bl: _e,
    tbl: _e,
    dl: _e,
    ltc: _e,
    mtp: _e,
    nor: _e,
    nrr: _e,
    rc: _e,
    sn: _e,
    sta: _e,
    su: _e,
    ttfb: _e,
    ttfbb: _e,
    ttlb: _e,
    cmsdd: _e,
    cmsds: _e,
    smrt: _e,
    df: _e,
    cs: _e,
    ts: _e,
    cid: yn,
    pr: yn,
    sf: yn,
    sid: yn,
    st: yn,
    v: yn,
    msd: yn,
    bs: $s,
    bsd: $s,
    cdn: $s,
    rtp: $s,
    bg: $s,
    pt: $s,
    ec: $s,
    e: $s
}
  , ZL = {
    REQUEST: _e
};
function qL(s) {
    return Object.keys(s).reduce( (e, t) => {
        var n;
        return (n = s[t]) === null || n === void 0 || n.forEach(r => e[r] = t),
        e
    }
    , {})
}
function QL(s, e) {
    const t = {};
    if (!s)
        return t;
    const n = Object.keys(s)
      , r = e ? qL(e) : {};
    return n.reduce( (i, a) => {
        var o;
        const l = XL[a] || r[a] || ZL.REQUEST
          , c = (o = i[l]) !== null && o !== void 0 ? o : i[l] = {};
        return c[a] = s[a],
        i
    }
    , t)
}
function JL(s) {
    return ["ot", "sf", "st", "e", "sta"].includes(s)
}
function eI(s) {
    return typeof s == "number" ? z(s) : s != null && s !== "" && s !== !1
}
const Q0 = "event";
function tI(s, e) {
    const t = new URL(s)
      , n = new URL(e);
    if (t.origin !== n.origin)
        return s;
    const r = t.pathname.split("/").slice(1)
      , i = n.pathname.split("/").slice(1, -1);
    for (; r[0] === i[0]; )
        r.shift(),
        i.shift();
    for (; i.length; )
        i.shift(),
        r.unshift("..");
    return r.join("/") + t.search + t.hash
}
const ja = s => Math.round(s)
  , ou = (s, e) => Array.isArray(s) ? s.map(t => ou(t, e)) : s instanceof fs && typeof s.value == "string" ? new fs(ou(s.value, e),s.params) : (e.baseUrl && (s = tI(s, e.baseUrl)),
e.version === 1 ? encodeURIComponent(s) : s)
  , ga = s => ja(s / 100) * 100
  , sI = (s, e) => {
    let t = s;
    return e.version >= 2 && (s instanceof fs && typeof s.value == "string" ? t = new fs([s]) : typeof s == "string" && (t = [s])),
    ou(t, e)
}
  , nI = {
    br: ja,
    d: ja,
    bl: ga,
    dl: ga,
    mtp: ga,
    nor: sI,
    rtp: ga,
    tb: ja
}
  , J0 = "request"
  , ey = "response"
  , Dd = ["ab", "bg", "bl", "br", "bs", "bsd", "cdn", "cid", "cs", "df", "ec", "lab", "lb", "ltc", "msd", "mtp", "pb", "pr", "pt", "sf", "sid", "sn", "st", "sta", "tab", "tb", "tbl", "tpb", "ts", "v"]
  , rI = ["e"]
  , iI = /^[a-zA-Z0-9-.]+-[a-zA-Z0-9-.]+$/;
function qo(s) {
    return iI.test(s)
}
function aI(s) {
    return Dd.includes(s) || rI.includes(s) || qo(s)
}
const ty = ["d", "dl", "nor", "ot", "rtp", "su"];
function oI(s) {
    return Dd.includes(s) || ty.includes(s) || qo(s)
}
const lI = ["cmsdd", "cmsds", "rc", "smrt", "ttfb", "ttfbb", "ttlb", "url"];
function cI(s) {
    return Dd.includes(s) || ty.includes(s) || lI.includes(s) || qo(s)
}
const uI = ["bl", "br", "bs", "cid", "d", "dl", "mtp", "nor", "nrr", "ot", "pr", "rtp", "sf", "sid", "st", "su", "tb", "v"];
function dI(s) {
    return uI.includes(s) || qo(s)
}
const hI = {
    [ey]: cI,
    [Q0]: aI,
    [J0]: oI
};
function sy(s, e={}) {
    const t = {};
    if (s == null || typeof s != "object")
        return t;
    const n = e.version || s.v || 1
      , r = e.reportingMode || J0
      , i = n === 1 ? dI : hI[r];
    let a = Object.keys(s).filter(i);
    const o = e.filter;
    typeof o == "function" && (a = a.filter(o));
    const l = r === ey || r === Q0;
    l && !a.includes("ts") && a.push("ts"),
    n > 1 && !a.includes("v") && a.push("v");
    const c = ye({}, nI, e.formatters)
      , u = {
        version: n,
        reportingMode: r,
        baseUrl: e.baseUrl
    };
    return a.sort().forEach(d => {
        let h = s[d];
        const f = c[d];
        if (typeof f == "function" && (h = f(h, u)),
        d === "v") {
            if (n === 1)
                return;
            h = n
        }
        d == "pr" && h === 1 || (l && d === "ts" && !z(h) && (h = Date.now()),
        eI(h) && (JL(d) && typeof h == "string" && (h = new z0(h)),
        t[d] = h))
    }
    ),
    t
}
function fI(s, e={}) {
    const t = {};
    if (!s)
        return t;
    const n = sy(s, e)
      , r = QL(n, e == null ? void 0 : e.customHeaderMap);
    return Object.entries(r).reduce( (i, [a,o]) => {
        const l = q0(o, {
            whitespace: !1
        });
        return l && (i[a] = l),
        i
    }
    , t)
}
function mI(s, e, t) {
    return ye(s, fI(e, t))
}
const gI = "CMCD";
function pI(s, e={}) {
    return s ? q0(sy(s, e), {
        whitespace: !1
    }) : ""
}
function yI(s, e={}) {
    if (!s)
        return "";
    const t = pI(s, e);
    return encodeURIComponent(t)
}
function xI(s, e={}) {
    if (!s)
        return "";
    const t = yI(s, e);
    return `${gI}=${t}`
}
const Zf = /CMCD=[^&#]+/;
function vI(s, e, t) {
    const n = xI(e, t);
    if (!n)
        return s;
    if (Zf.test(s))
        return s.replace(Zf, n);
    const r = s.includes("?") ? "&" : "?";
    return `${s}${r}${n}`
}
class EI {
    constructor(e) {
        this.hls = void 0,
        this.config = void 0,
        this.media = void 0,
        this.sid = void 0,
        this.cid = void 0,
        this.useHeaders = !1,
        this.includeKeys = void 0,
        this.initialized = !1,
        this.starved = !1,
        this.buffering = !0,
        this.audioBuffer = void 0,
        this.videoBuffer = void 0,
        this.onWaiting = () => {
            this.initialized && (this.starved = !0),
            this.buffering = !0
        }
        ,
        this.onPlaying = () => {
            this.initialized || (this.initialized = !0),
            this.buffering = !1
        }
        ,
        this.applyPlaylistData = r => {
            try {
                this.apply(r, {
                    ot: ft.MANIFEST,
                    su: !this.initialized
                })
            } catch (i) {
                this.hls.logger.warn("Could not generate manifest CMCD data.", i)
            }
        }
        ,
        this.applyFragmentData = r => {
            try {
                const {frag: i, part: a} = r
                  , o = this.hls.levels[i.level]
                  , l = this.getObjectType(i)
                  , c = {
                    d: (a || i).duration * 1e3,
                    ot: l
                };
                (l === ft.VIDEO || l === ft.AUDIO || l == ft.MUXED) && (c.br = o.bitrate / 1e3,
                c.tb = this.getTopBandwidth(l) / 1e3,
                c.bl = this.getBufferLength(l));
                const u = a ? this.getNextPart(a) : this.getNextFrag(i);
                u != null && u.url && u.url !== i.url && (c.nor = u.url),
                this.apply(r, c)
            } catch (i) {
                this.hls.logger.warn("Could not generate segment CMCD data.", i)
            }
        }
        ,
        this.hls = e;
        const t = this.config = e.config
          , {cmcd: n} = t;
        n != null && (t.pLoader = this.createPlaylistLoader(),
        t.fLoader = this.createFragmentLoader(),
        this.sid = n.sessionId || e.sessionId,
        this.cid = n.contentId,
        this.useHeaders = n.useHeaders === !0,
        this.includeKeys = n.includeKeys,
        this.registerListeners())
    }
    registerListeners() {
        const e = this.hls;
        e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(S.MEDIA_DETACHED, this.onMediaDetached, this),
        e.on(S.BUFFER_CREATED, this.onBufferCreated, this)
    }
    unregisterListeners() {
        const e = this.hls;
        e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(S.MEDIA_DETACHED, this.onMediaDetached, this),
        e.off(S.BUFFER_CREATED, this.onBufferCreated, this)
    }
    destroy() {
        this.unregisterListeners(),
        this.onMediaDetached(),
        this.hls = this.config = this.audioBuffer = this.videoBuffer = null,
        this.onWaiting = this.onPlaying = this.media = null
    }
    onMediaAttached(e, t) {
        this.media = t.media,
        this.media.addEventListener("waiting", this.onWaiting),
        this.media.addEventListener("playing", this.onPlaying)
    }
    onMediaDetached() {
        this.media && (this.media.removeEventListener("waiting", this.onWaiting),
        this.media.removeEventListener("playing", this.onPlaying),
        this.media = null)
    }
    onBufferCreated(e, t) {
        var n, r;
        this.audioBuffer = (n = t.tracks.audio) == null ? void 0 : n.buffer,
        this.videoBuffer = (r = t.tracks.video) == null ? void 0 : r.buffer
    }
    createData() {
        var e;
        return {
            v: 1,
            sf: RL.HLS,
            sid: this.sid,
            cid: this.cid,
            pr: (e = this.media) == null ? void 0 : e.playbackRate,
            mtp: this.hls.bandwidthEstimate / 1e3
        }
    }
    apply(e, t={}) {
        ye(t, this.createData());
        const n = t.ot === ft.INIT || t.ot === ft.VIDEO || t.ot === ft.MUXED;
        this.starved && n && (t.bs = !0,
        t.su = !0,
        this.starved = !1),
        t.su == null && (t.su = this.buffering);
        const {includeKeys: r} = this;
        r && (t = Object.keys(t).reduce( (a, o) => (r.includes(o) && (a[o] = t[o]),
        a), {}));
        const i = {
            baseUrl: e.url
        };
        this.useHeaders ? (e.headers || (e.headers = {}),
        mI(e.headers, t, i)) : e.url = vI(e.url, t, i)
    }
    getNextFrag(e) {
        var t;
        const n = (t = this.hls.levels[e.level]) == null ? void 0 : t.details;
        if (n) {
            const r = e.sn - n.startSN;
            return n.fragments[r + 1]
        }
    }
    getNextPart(e) {
        var t;
        const {index: n, fragment: r} = e
          , i = (t = this.hls.levels[r.level]) == null || (t = t.details) == null ? void 0 : t.partList;
        if (i) {
            const {sn: a} = r;
            for (let o = i.length - 1; o >= 0; o--) {
                const l = i[o];
                if (l.index === n && l.fragment.sn === a)
                    return i[o + 1]
            }
        }
    }
    getObjectType(e) {
        const {type: t} = e;
        if (t === "subtitle")
            return ft.TIMED_TEXT;
        if (e.sn === "initSegment")
            return ft.INIT;
        if (t === "audio")
            return ft.AUDIO;
        if (t === "main")
            return this.hls.audioTracks.length ? ft.VIDEO : ft.MUXED
    }
    getTopBandwidth(e) {
        let t = 0, n;
        const r = this.hls;
        if (e === ft.AUDIO)
            n = r.audioTracks;
        else {
            const i = r.maxAutoLevel
              , a = i > -1 ? i + 1 : r.levels.length;
            n = r.levels.slice(0, a)
        }
        return n.forEach(i => {
            i.bitrate > t && (t = i.bitrate)
        }
        ),
        t > 0 ? t : NaN
    }
    getBufferLength(e) {
        const t = this.media
          , n = e === ft.AUDIO ? this.audioBuffer : this.videoBuffer;
        return !n || !t ? NaN : ie.bufferInfo(n, t.currentTime, this.config.maxBufferHole).len * 1e3
    }
    createPlaylistLoader() {
        const {pLoader: e} = this.config
          , t = this.applyPlaylistData
          , n = e || this.config.loader;
        return class {
            constructor(i) {
                this.loader = void 0,
                this.loader = new n(i)
            }
            get stats() {
                return this.loader.stats
            }
            get context() {
                return this.loader.context
            }
            destroy() {
                this.loader.destroy()
            }
            abort() {
                this.loader.abort()
            }
            load(i, a, o) {
                t(i),
                this.loader.load(i, a, o)
            }
        }
    }
    createFragmentLoader() {
        const {fLoader: e} = this.config
          , t = this.applyFragmentData
          , n = e || this.config.loader;
        return class {
            constructor(i) {
                this.loader = void 0,
                this.loader = new n(i)
            }
            get stats() {
                return this.loader.stats
            }
            get context() {
                return this.loader.context
            }
            destroy() {
                this.loader.destroy()
            }
            abort() {
                this.loader.abort()
            }
            load(i, a, o) {
                t(i),
                this.loader.load(i, a, o)
            }
        }
    }
}
const SI = 3e5;
class TI extends Gt {
    constructor(e) {
        super("content-steering", e.logger),
        this.hls = void 0,
        this.loader = null,
        this.uri = null,
        this.pathwayId = ".",
        this._pathwayPriority = null,
        this.timeToLoad = 300,
        this.reloadTimer = -1,
        this.updated = 0,
        this.started = !1,
        this.enabled = !0,
        this.levels = null,
        this.audioTracks = null,
        this.subtitleTracks = null,
        this.penalizedPathways = {},
        this.hls = e,
        this.registerListeners()
    }
    registerListeners() {
        const e = this.hls;
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(S.ERROR, this.onError, this)
    }
    unregisterListeners() {
        const e = this.hls;
        e && (e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(S.ERROR, this.onError, this))
    }
    pathways() {
        return (this.levels || []).reduce( (e, t) => (e.indexOf(t.pathwayId) === -1 && e.push(t.pathwayId),
        e), [])
    }
    get pathwayPriority() {
        return this._pathwayPriority
    }
    set pathwayPriority(e) {
        this.updatePathwayPriority(e)
    }
    startLoad() {
        if (this.started = !0,
        this.clearTimeout(),
        this.enabled && this.uri) {
            if (this.updated) {
                const e = this.timeToLoad * 1e3 - (performance.now() - this.updated);
                if (e > 0) {
                    this.scheduleRefresh(this.uri, e);
                    return
                }
            }
            this.loadSteeringManifest(this.uri)
        }
    }
    stopLoad() {
        this.started = !1,
        this.loader && (this.loader.destroy(),
        this.loader = null),
        this.clearTimeout()
    }
    clearTimeout() {
        this.reloadTimer !== -1 && (self.clearTimeout(this.reloadTimer),
        this.reloadTimer = -1)
    }
    destroy() {
        this.unregisterListeners(),
        this.stopLoad(),
        this.hls = null,
        this.levels = this.audioTracks = this.subtitleTracks = null
    }
    removeLevel(e) {
        const t = this.levels;
        t && (this.levels = t.filter(n => n !== e))
    }
    onManifestLoading() {
        this.stopLoad(),
        this.enabled = !0,
        this.timeToLoad = 300,
        this.updated = 0,
        this.uri = null,
        this.pathwayId = ".",
        this.levels = this.audioTracks = this.subtitleTracks = null
    }
    onManifestLoaded(e, t) {
        const {contentSteering: n} = t;
        n !== null && (this.pathwayId = n.pathwayId,
        this.uri = n.uri,
        this.started && this.startLoad())
    }
    onManifestParsed(e, t) {
        this.audioTracks = t.audioTracks,
        this.subtitleTracks = t.subtitleTracks
    }
    onError(e, t) {
        const {errorAction: n} = t;
        if ((n == null ? void 0 : n.action) === qe.SendAlternateToPenaltyBox && n.flags === Tt.MoveAllAlternatesMatchingHost) {
            const r = this.levels;
            let i = this._pathwayPriority
              , a = this.pathwayId;
            if (t.context) {
                const {groupId: o, pathwayId: l, type: c} = t.context;
                o && r ? a = this.getPathwayForGroupId(o, c, a) : l && (a = l)
            }
            a in this.penalizedPathways || (this.penalizedPathways[a] = performance.now()),
            !i && r && (i = this.pathways()),
            i && i.length > 1 && (this.updatePathwayPriority(i),
            n.resolved = this.pathwayId !== a),
            t.details === N.BUFFER_APPEND_ERROR && !t.fatal ? n.resolved = !0 : n.resolved || this.warn(`Could not resolve ${t.details} ("${t.error.message}") with content-steering for Pathway: ${a} levels: ${r && r.length} priorities: ${Te(i)} penalized: ${Te(this.penalizedPathways)}`)
        }
    }
    filterParsedLevels(e) {
        this.levels = e;
        let t = this.getLevelsForPathway(this.pathwayId);
        if (t.length === 0) {
            const n = e[0].pathwayId;
            this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${n}"`),
            t = this.getLevelsForPathway(n),
            this.pathwayId = n
        }
        return t.length !== e.length && this.log(`Found ${t.length}/${e.length} levels in Pathway "${this.pathwayId}"`),
        t
    }
    getLevelsForPathway(e) {
        return this.levels === null ? [] : this.levels.filter(t => e === t.pathwayId)
    }
    updatePathwayPriority(e) {
        this._pathwayPriority = e;
        let t;
        const n = this.penalizedPathways
          , r = performance.now();
        Object.keys(n).forEach(i => {
            r - n[i] > SI && delete n[i]
        }
        );
        for (let i = 0; i < e.length; i++) {
            const a = e[i];
            if (a in n)
                continue;
            if (a === this.pathwayId)
                return;
            const o = this.hls.nextLoadLevel
              , l = this.hls.levels[o];
            if (t = this.getLevelsForPathway(a),
            t.length > 0) {
                this.log(`Setting Pathway to "${a}"`),
                this.pathwayId = a,
                T0(t),
                this.hls.trigger(S.LEVELS_UPDATED, {
                    levels: t
                });
                const c = this.hls.levels[o];
                l && c && this.levels && (c.attrs["STABLE-VARIANT-ID"] !== l.attrs["STABLE-VARIANT-ID"] && c.bitrate !== l.bitrate && this.log(`Unstable Pathways change from bitrate ${l.bitrate} to ${c.bitrate}`),
                this.hls.nextLoadLevel = o);
                break
            }
        }
    }
    getPathwayForGroupId(e, t, n) {
        const r = this.getLevelsForPathway(n).concat(this.levels || []);
        for (let i = 0; i < r.length; i++)
            if (t === le.AUDIO_TRACK && r[i].hasAudioGroup(e) || t === le.SUBTITLE_TRACK && r[i].hasSubtitleGroup(e))
                return r[i].pathwayId;
        return n
    }
    clonePathways(e) {
        const t = this.levels;
        if (!t)
            return;
        const n = {}
          , r = {};
        e.forEach(i => {
            const {ID: a, "BASE-ID": o, "URI-REPLACEMENT": l} = i;
            if (t.some(u => u.pathwayId === a))
                return;
            const c = this.getLevelsForPathway(o).map(u => {
                const d = new Ae(u.attrs);
                d["PATHWAY-ID"] = a;
                const h = d.AUDIO && `${d.AUDIO}_clone_${a}`
                  , f = d.SUBTITLES && `${d.SUBTITLES}_clone_${a}`;
                h && (n[d.AUDIO] = h,
                d.AUDIO = h),
                f && (r[d.SUBTITLES] = f,
                d.SUBTITLES = f);
                const m = ny(u.uri, d["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", l)
                  , p = new bi({
                    attrs: d,
                    audioCodec: u.audioCodec,
                    bitrate: u.bitrate,
                    height: u.height,
                    name: u.name,
                    url: m,
                    videoCodec: u.videoCodec,
                    width: u.width
                });
                if (u.audioGroups)
                    for (let x = 1; x < u.audioGroups.length; x++)
                        p.addGroupId("audio", `${u.audioGroups[x]}_clone_${a}`);
                if (u.subtitleGroups)
                    for (let x = 1; x < u.subtitleGroups.length; x++)
                        p.addGroupId("text", `${u.subtitleGroups[x]}_clone_${a}`);
                return p
            }
            );
            t.push(...c),
            qf(this.audioTracks, n, l, a),
            qf(this.subtitleTracks, r, l, a)
        }
        )
    }
    loadSteeringManifest(e) {
        const t = this.hls.config
          , n = t.loader;
        this.loader && this.loader.destroy(),
        this.loader = new n(t);
        let r;
        try {
            r = new self.URL(e)
        } catch {
            this.enabled = !1,
            this.log(`Failed to parse Steering Manifest URI: ${e}`);
            return
        }
        if (r.protocol !== "data:") {
            const u = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0;
            r.searchParams.set("_HLS_pathway", this.pathwayId),
            r.searchParams.set("_HLS_throughput", "" + u)
        }
        const i = {
            responseType: "json",
            url: r.href
        }
          , a = t.steeringManifestLoadPolicy.default
          , o = a.errorRetry || a.timeoutRetry || {}
          , l = {
            loadPolicy: a,
            timeout: a.maxLoadTimeMs,
            maxRetry: o.maxNumRetry || 0,
            retryDelay: o.retryDelayMs || 0,
            maxRetryDelay: o.maxRetryDelayMs || 0
        }
          , c = {
            onSuccess: (u, d, h, f) => {
                this.log(`Loaded steering manifest: "${r}"`);
                const m = u.data;
                if ((m == null ? void 0 : m.VERSION) !== 1) {
                    this.log(`Steering VERSION ${m.VERSION} not supported!`);
                    return
                }
                this.updated = performance.now(),
                this.timeToLoad = m.TTL;
                const {"RELOAD-URI": p, "PATHWAY-CLONES": x, "PATHWAY-PRIORITY": y} = m;
                if (p)
                    try {
                        this.uri = new self.URL(p,r).href
                    } catch {
                        this.enabled = !1,
                        this.log(`Failed to parse Steering Manifest RELOAD-URI: ${p}`);
                        return
                    }
                this.scheduleRefresh(this.uri || h.url),
                x && this.clonePathways(x);
                const v = {
                    steeringManifest: m,
                    url: r.toString()
                };
                this.hls.trigger(S.STEERING_MANIFEST_LOADED, v),
                y && this.updatePathwayPriority(y)
            }
            ,
            onError: (u, d, h, f) => {
                if (this.log(`Error loading steering manifest: ${u.code} ${u.text} (${d.url})`),
                this.stopLoad(),
                u.code === 410) {
                    this.enabled = !1,
                    this.log(`Steering manifest ${d.url} no longer available`);
                    return
                }
                let m = this.timeToLoad * 1e3;
                if (u.code === 429) {
                    const p = this.loader;
                    if (typeof (p == null ? void 0 : p.getResponseHeader) == "function") {
                        const x = p.getResponseHeader("Retry-After");
                        x && (m = parseFloat(x) * 1e3)
                    }
                    this.log(`Steering manifest ${d.url} rate limited`);
                    return
                }
                this.scheduleRefresh(this.uri || d.url, m)
            }
            ,
            onTimeout: (u, d, h) => {
                this.log(`Timeout loading steering manifest (${d.url})`),
                this.scheduleRefresh(this.uri || d.url)
            }
        };
        this.log(`Requesting steering manifest: ${r}`),
        this.loader.load(i, l, c)
    }
    scheduleRefresh(e, t=this.timeToLoad * 1e3) {
        this.clearTimeout(),
        this.reloadTimer = self.setTimeout( () => {
            var n;
            const r = (n = this.hls) == null ? void 0 : n.media;
            if (r && !r.ended) {
                this.loadSteeringManifest(e);
                return
            }
            this.scheduleRefresh(e, this.timeToLoad * 1e3)
        }
        , t)
    }
}
function qf(s, e, t, n) {
    s && Object.keys(e).forEach(r => {
        const i = s.filter(a => a.groupId === r).map(a => {
            const o = ye({}, a);
            return o.details = void 0,
            o.attrs = new Ae(o.attrs),
            o.url = o.attrs.URI = ny(a.url, a.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", t),
            o.groupId = o.attrs["GROUP-ID"] = e[r],
            o.attrs["PATHWAY-ID"] = n,
            o
        }
        );
        s.push(...i)
    }
    )
}
function ny(s, e, t, n) {
    const {HOST: r, PARAMS: i, [t]: a} = n;
    let o;
    e && (o = a == null ? void 0 : a[e],
    o && (s = o));
    const l = new self.URL(s);
    return r && !o && (l.host = r),
    i && Object.keys(i).sort().forEach(c => {
        c && l.searchParams.set(c, i[c])
    }
    ),
    l.href
}
class mr extends Gt {
    constructor(e) {
        super("eme", e.logger),
        this.hls = void 0,
        this.config = void 0,
        this.media = null,
        this.keyFormatPromise = null,
        this.keySystemAccessPromises = {},
        this._requestLicenseFailureCount = 0,
        this.mediaKeySessions = [],
        this.keyIdToKeySessionPromise = {},
        this.mediaKeys = null,
        this.setMediaKeysQueue = mr.CDMCleanupPromise ? [mr.CDMCleanupPromise] : [],
        this.bannedKeyIds = {},
        this.onMediaEncrypted = t => {
            const {initDataType: n, initData: r} = t
              , i = `"${t.type}" event: init data type: "${n}"`;
            if (this.debug(i),
            r !== null) {
                if (!this.keyFormatPromise) {
                    let a = Object.keys(this.keySystemAccessPromises);
                    a.length || (a = zr(this.config));
                    const o = a.map(Dl).filter(l => !!l);
                    this.keyFormatPromise = this.getKeyFormatPromise(o)
                }
                this.keyFormatPromise.then(a => {
                    const o = Ua(a);
                    if (n !== "sinf" || o !== Pe.FAIRPLAY) {
                        this.log(`Ignoring "${t.type}" event with init data type: "${n}" for selected key-system ${o}`);
                        return
                    }
                    let l;
                    try {
                        const f = je(new Uint8Array(r))
                          , m = Ed(JSON.parse(f).sinf)
                          , p = t0(m);
                        if (!p)
                            throw new Error("'schm' box missing or not cbcs/cenc with schi > tenc");
                        l = new Uint8Array(p.subarray(8, 24))
                    } catch (f) {
                        this.warn(`${i} Failed to parse sinf: ${f}`);
                        return
                    }
                    const c = It(l)
                      , {keyIdToKeySessionPromise: u, mediaKeySessions: d} = this;
                    let h = u[c];
                    for (let f = 0; f < d.length; f++) {
                        const m = d[f]
                          , p = m.decryptdata;
                        if (!p.keyId)
                            continue;
                        const x = It(p.keyId);
                        if (c === x || p.uri.replace(/-/g, "").indexOf(c) !== -1) {
                            if (h = u[x],
                            !h)
                                continue;
                            if (p.pssh)
                                break;
                            delete u[x],
                            p.pssh = new Uint8Array(r),
                            p.keyId = l,
                            h = u[c] = h.then( () => this.generateRequestWithPreferredKeySession(m, n, r, "encrypted-event-key-match")),
                            h.catch(y => this.handleError(y));
                            break
                        }
                    }
                    h || this.handleError(new Error(`Key ID ${c} not encountered in playlist. Key-system sessions ${d.length}.`))
                }
                ).catch(a => this.handleError(a))
            }
        }
        ,
        this.onWaitingForKey = t => {
            this.log(`"${t.type}" event`)
        }
        ,
        this.hls = e,
        this.config = e.config,
        this.registerListeners()
    }
    destroy() {
        this.onDestroying(),
        this.onMediaDetached();
        const e = this.config;
        e.requestMediaKeySystemAccessFunc = null,
        e.licenseXhrSetup = e.licenseResponseCallback = void 0,
        e.drmSystems = e.drmSystemOptions = {},
        this.hls = this.config = this.keyIdToKeySessionPromise = null,
        this.onMediaEncrypted = this.onWaitingForKey = null
    }
    registerListeners() {
        this.hls.on(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        this.hls.on(S.MEDIA_DETACHED, this.onMediaDetached, this),
        this.hls.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        this.hls.on(S.MANIFEST_LOADED, this.onManifestLoaded, this),
        this.hls.on(S.DESTROYING, this.onDestroying, this)
    }
    unregisterListeners() {
        this.hls.off(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        this.hls.off(S.MEDIA_DETACHED, this.onMediaDetached, this),
        this.hls.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        this.hls.off(S.MANIFEST_LOADED, this.onManifestLoaded, this),
        this.hls.off(S.DESTROYING, this.onDestroying, this)
    }
    getLicenseServerUrl(e) {
        const {drmSystems: t, widevineLicenseUrl: n} = this.config
          , r = t == null ? void 0 : t[e];
        if (r)
            return r.licenseUrl;
        if (e === Pe.WIDEVINE && n)
            return n
    }
    getLicenseServerUrlOrThrow(e) {
        const t = this.getLicenseServerUrl(e);
        if (t === void 0)
            throw new Error(`no license server URL configured for key-system "${e}"`);
        return t
    }
    getServerCertificateUrl(e) {
        const {drmSystems: t} = this.config
          , n = t == null ? void 0 : t[e];
        if (n)
            return n.serverCertificateUrl;
        this.log(`No Server Certificate in config.drmSystems["${e}"]`)
    }
    attemptKeySystemAccess(e) {
        const t = this.hls.levels
          , n = (a, o, l) => !!a && l.indexOf(a) === o
          , r = t.map(a => a.audioCodec).filter(n)
          , i = t.map(a => a.videoCodec).filter(n);
        return r.length + i.length === 0 && i.push("avc1.42e01e"),
        new Promise( (a, o) => {
            const l = c => {
                const u = c.shift();
                this.getMediaKeysPromise(u, r, i).then(d => a({
                    keySystem: u,
                    mediaKeys: d
                })).catch(d => {
                    c.length ? l(c) : d instanceof zt ? o(d) : o(new zt({
                        type: q.KEY_SYSTEM_ERROR,
                        details: N.KEY_SYSTEM_NO_ACCESS,
                        error: d,
                        fatal: !0
                    },d.message))
                }
                )
            }
            ;
            l(e)
        }
        )
    }
    requestMediaKeySystemAccess(e, t) {
        const {requestMediaKeySystemAccessFunc: n} = this.config;
        if (typeof n != "function") {
            let r = `Configured requestMediaKeySystemAccess is not a function ${n}`;
            return g0 === null && self.location.protocol === "http:" && (r = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`),
            Promise.reject(new Error(r))
        }
        return n(e, t)
    }
    getMediaKeysPromise(e, t, n) {
        var r;
        const i = s1(e, t, n, this.config.drmSystemOptions || {});
        let a = this.keySystemAccessPromises[e]
          , o = (r = a) == null ? void 0 : r.keySystemAccess;
        if (!o) {
            this.log(`Requesting encrypted media "${e}" key-system access with config: ${Te(i)}`),
            o = this.requestMediaKeySystemAccess(e, i);
            const l = a = this.keySystemAccessPromises[e] = {
                keySystemAccess: o
            };
            return o.catch(c => {
                this.log(`Failed to obtain access to key-system "${e}": ${c}`)
            }
            ),
            o.then(c => {
                this.log(`Access for key-system "${c.keySystem}" obtained`);
                const u = this.fetchServerCertificate(e);
                this.log(`Create media-keys for "${e}"`);
                const d = l.mediaKeys = c.createMediaKeys().then(h => (this.log(`Media-keys created for "${e}"`),
                l.hasMediaKeys = !0,
                u.then(f => f ? this.setMediaKeysServerCertificate(h, e, f) : h)));
                return d.catch(h => {
                    this.error(`Failed to create media-keys for "${e}"}: ${h}`)
                }
                ),
                d
            }
            )
        }
        return o.then( () => a.mediaKeys)
    }
    createMediaKeySessionContext({decryptdata: e, keySystem: t, mediaKeys: n}) {
        this.log(`Creating key-system session "${t}" keyId: ${It(e.keyId || [])}`);
        const r = n.createSession()
          , i = {
            decryptdata: e,
            keySystem: t,
            mediaKeys: n,
            mediaKeysSession: r,
            keyStatus: "status-pending"
        };
        return this.mediaKeySessions.push(i),
        i
    }
    renewKeySession(e) {
        const t = e.decryptdata;
        if (t.pssh) {
            const n = this.createMediaKeySessionContext(e)
              , r = this.getKeyIdString(t)
              , i = "cenc";
            this.keyIdToKeySessionPromise[r] = this.generateRequestWithPreferredKeySession(n, i, t.pssh.buffer, "expired")
        } else
            this.warn("Could not renew expired session. Missing pssh initData.");
        this.removeSession(e)
    }
    getKeyIdString(e) {
        if (!e)
            throw new Error("Could not read keyId of undefined decryptdata");
        if (e.keyId === null)
            throw new Error("keyId is null");
        return It(e.keyId)
    }
    updateKeySession(e, t) {
        const n = e.mediaKeysSession;
        return this.log(`Updating key-session "${n.sessionId}" for keyId ${It(e.decryptdata.keyId || [])}
      } (data length: ${t.byteLength})`),
        n.update(t)
    }
    getSelectedKeySystemFormats() {
        return Object.keys(this.keySystemAccessPromises).map(e => ({
            keySystem: e,
            hasMediaKeys: this.keySystemAccessPromises[e].hasMediaKeys
        })).filter( ({hasMediaKeys: e}) => !!e).map( ({keySystem: e}) => Dl(e)).filter(e => !!e)
    }
    getKeySystemAccess(e) {
        return this.getKeySystemSelectionPromise(e).then( ({keySystem: t, mediaKeys: n}) => this.attemptSetMediaKeys(t, n))
    }
    selectKeySystem(e) {
        return new Promise( (t, n) => {
            this.getKeySystemSelectionPromise(e).then( ({keySystem: r}) => {
                const i = Dl(r);
                i ? t(i) : n(new Error(`Unable to find format for key-system "${r}"`))
            }
            ).catch(n)
        }
        )
    }
    selectKeySystemFormat(e) {
        const t = Object.keys(e.levelkeys || {});
        return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(", ")}`),
        this.keyFormatPromise = this.getKeyFormatPromise(t)),
        this.keyFormatPromise
    }
    getKeyFormatPromise(e) {
        const t = zr(this.config)
          , n = e.map(Ua).filter(r => !!r && t.indexOf(r) !== -1);
        return this.selectKeySystem(n)
    }
    loadKey(e) {
        const t = e.keyInfo.decryptdata
          , n = this.getKeyIdString(t)
          , r = this.bannedKeyIds[n];
        if (r) {
            const o = Qf(r, t);
            return this.handleError(o, e.frag),
            Promise.reject(o)
        }
        const i = `(keyId: ${n} format: "${t.keyFormat}" method: ${t.method} uri: ${t.uri})`;
        this.log(`Starting session for key ${i}`);
        const a = this.keyIdToKeySessionPromise[n];
        if (!a) {
            const o = this.getKeySystemForKeyPromise(t).then( ({keySystem: l, mediaKeys: c}) => (this.throwIfDestroyed(),
            this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${i}`),
            this.attemptSetMediaKeys(l, c).then( () => (this.throwIfDestroyed(),
            this.createMediaKeySessionContext({
                keySystem: l,
                mediaKeys: c,
                decryptdata: t
            }))))).then(l => {
                const c = "cenc"
                  , u = t.pssh ? t.pssh.buffer : null;
                return this.generateRequestWithPreferredKeySession(l, c, u, "playlist-key")
            }
            );
            return o.catch(l => this.handleError(l, e.frag)),
            this.keyIdToKeySessionPromise[n] = o,
            o
        }
        return a
    }
    throwIfDestroyed(e="Invalid state") {
        if (!this.hls)
            throw new Error("invalid state")
    }
    handleError(e, t) {
        this.hls && (this.error(e.message),
        e instanceof zt ? (t && (e.data.frag = t),
        this.hls.trigger(S.ERROR, e.data)) : this.hls.trigger(S.ERROR, {
            type: q.KEY_SYSTEM_ERROR,
            details: N.KEY_SYSTEM_NO_KEYS,
            error: e,
            fatal: !0
        }))
    }
    getKeySystemForKeyPromise(e) {
        const t = this.getKeyIdString(e)
          , n = this.keyIdToKeySessionPromise[t];
        if (!n) {
            const r = Ua(e.keyFormat)
              , i = r ? [r] : zr(this.config);
            return this.attemptKeySystemAccess(i)
        }
        return n
    }
    getKeySystemSelectionPromise(e) {
        if (e.length || (e = zr(this.config)),
        e.length === 0)
            throw new zt({
                type: q.KEY_SYSTEM_ERROR,
                details: N.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
                fatal: !0
            },`Missing key-system license configuration options ${Te({
                drmSystems: this.config.drmSystems
            })}`);
        return this.attemptKeySystemAccess(e)
    }
    attemptSetMediaKeys(e, t) {
        if (this.mediaKeys === t)
            return Promise.resolve();
        const n = this.setMediaKeysQueue.slice();
        this.log(`Setting media-keys for "${e}"`);
        const r = Promise.all(n).then( () => {
            if (!this.media)
                throw this.mediaKeys = null,
                new Error("Attempted to set mediaKeys without media element attached");
            return this.media.setMediaKeys(t)
        }
        );
        return this.mediaKeys = t,
        this.setMediaKeysQueue.push(r),
        r.then( () => {
            this.log(`Media-keys set for "${e}"`),
            n.push(r),
            this.setMediaKeysQueue = this.setMediaKeysQueue.filter(i => n.indexOf(i) === -1)
        }
        )
    }
    generateRequestWithPreferredKeySession(e, t, n, r) {
        var i;
        const a = (i = this.config.drmSystems) == null || (i = i[e.keySystem]) == null ? void 0 : i.generateRequest;
        if (a)
            try {
                const h = a.call(this.hls, t, n, e);
                if (!h)
                    throw new Error("Invalid response from configured generateRequest filter");
                t = h.initDataType,
                n = h.initData ? h.initData : null,
                e.decryptdata.pssh = n ? new Uint8Array(n) : null
            } catch (h) {
                if (this.warn(h.message),
                this.hls && this.hls.config.debug)
                    throw h
            }
        if (n === null)
            return this.log(`Skipping key-session request for "${r}" (no initData)`),
            Promise.resolve(e);
        const o = this.getKeyIdString(e.decryptdata);
        this.log(`Generating key-session request for "${r}": ${o} (init data type: ${t} length: ${n.byteLength})`);
        const l = new Td
          , c = e._onmessage = h => {
            const f = e.mediaKeysSession;
            if (!f) {
                l.emit("error", new Error("invalid state"));
                return
            }
            const {messageType: m, message: p} = h;
            this.log(`"${m}" message event for session "${f.sessionId}" message size: ${p.byteLength}`),
            m === "license-request" || m === "license-renewal" ? this.renewLicense(e, p).catch(x => {
                l.eventNames().length ? l.emit("error", x) : this.handleError(x)
            }
            ) : m === "license-release" ? e.keySystem === Pe.FAIRPLAY && (this.updateKeySession(e, Jc("acknowledged")),
            this.removeSession(e)) : this.warn(`unhandled media key message type "${m}"`)
        }
          , u = e._onkeystatuseschange = h => {
            if (!e.mediaKeysSession) {
                l.emit("error", new Error("invalid state"));
                return
            }
            const m = e.keyStatus;
            this.onKeyStatusChange(e);
            const p = e.keyStatus;
            p !== m && (l.emit("keyStatus", p, e),
            p === "expired" && (this.log(`${e.keySystem} expired for key ${o}`),
            this.renewKeySession(e)))
        }
        ;
        lt(e.mediaKeysSession, "message", c),
        lt(e.mediaKeysSession, "keystatuseschange", u);
        const d = new Promise( (h, f) => {
            l.on("error", f),
            l.on("keyStatus", (m, {decryptdata: p}) => {
                m.startsWith("usable") ? h() : m === "internal-error" || m === "output-restricted" ? f(Qf(m, p)) : m === "expired" ? f(new Error(`key expired while generating request (keyId: ${o})`)) : this.warn(`unhandled key status change "${m}" (keyId: ${o})`)
            }
            )
        }
        );
        return e.mediaKeysSession.generateRequest(t, n).then( () => {
            this.log(`Request generated for key-session "${e.mediaKeysSession.sessionId}" keyId: ${o}`)
        }
        ).catch(h => {
            throw new zt({
                type: q.KEY_SYSTEM_ERROR,
                details: N.KEY_SYSTEM_NO_SESSION,
                error: h,
                decryptdata: e.decryptdata,
                fatal: !1
            },`Error generating key-session request: ${h}`)
        }
        ).then( () => d).catch(h => {
            throw l.removeAllListeners(),
            this.removeSession(e),
            h
        }
        ).then( () => (l.removeAllListeners(),
        e))
    }
    onKeyStatusChange(e) {
        const t = It(new Uint8Array(e.decryptdata.keyId || []));
        e.mediaKeysSession.keyStatuses.forEach( (n, r) => {
            if (typeof r == "string" && typeof n == "object") {
                const o = r;
                r = n,
                n = o
            }
            const i = It("buffer"in r ? new Uint8Array(r.buffer,r.byteOffset,r.byteLength) : new Uint8Array(r));
            n === "internal-error" && (this.bannedKeyIds[i] = n);
            const a = i === t;
            this.log(`${a ? "" : "un"}matched key status change "${n}" for keyStatuses keyId: ${i} session keyId: ${t} uri: ${e.decryptdata.uri}`),
            a && (e.keyStatus = n)
        }
        )
    }
    fetchServerCertificate(e) {
        const t = this.config
          , n = t.loader
          , r = new n(t)
          , i = this.getServerCertificateUrl(e);
        return i ? (this.log(`Fetching server certificate for "${e}"`),
        new Promise( (a, o) => {
            const l = {
                responseType: "arraybuffer",
                url: i
            }
              , c = t.certLoadPolicy.default
              , u = {
                loadPolicy: c,
                timeout: c.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0
            }
              , d = {
                onSuccess: (h, f, m, p) => {
                    a(h.data)
                }
                ,
                onError: (h, f, m, p) => {
                    o(new zt({
                        type: q.KEY_SYSTEM_ERROR,
                        details: N.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                        fatal: !0,
                        networkDetails: m,
                        response: pe({
                            url: l.url,
                            data: void 0
                        }, h)
                    },`"${e}" certificate request failed (${i}). Status: ${h.code} (${h.text})`))
                }
                ,
                onTimeout: (h, f, m) => {
                    o(new zt({
                        type: q.KEY_SYSTEM_ERROR,
                        details: N.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                        fatal: !0,
                        networkDetails: m,
                        response: {
                            url: l.url,
                            data: void 0
                        }
                    },`"${e}" certificate request timed out (${i})`))
                }
                ,
                onAbort: (h, f, m) => {
                    o(new Error("aborted"))
                }
            };
            r.load(l, u, d)
        }
        )) : Promise.resolve()
    }
    setMediaKeysServerCertificate(e, t, n) {
        return new Promise( (r, i) => {
            e.setServerCertificate(n).then(a => {
                this.log(`setServerCertificate ${a ? "success" : "not supported by CDM"} (${n.byteLength}) on "${t}"`),
                r(e)
            }
            ).catch(a => {
                i(new zt({
                    type: q.KEY_SYSTEM_ERROR,
                    details: N.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                    error: a,
                    fatal: !0
                },a.message))
            }
            )
        }
        )
    }
    renewLicense(e, t) {
        return this.requestLicense(e, new Uint8Array(t)).then(n => this.updateKeySession(e, new Uint8Array(n)).catch(r => {
            throw new zt({
                type: q.KEY_SYSTEM_ERROR,
                details: N.KEY_SYSTEM_SESSION_UPDATE_FAILED,
                decryptdata: e.decryptdata,
                error: r,
                fatal: !1
            },r.message)
        }
        ))
    }
    unpackPlayReadyKeyMessage(e, t) {
        const n = String.fromCharCode.apply(null, new Uint16Array(t.buffer));
        if (!n.includes("PlayReadyKeyMessage"))
            return e.setRequestHeader("Content-Type", "text/xml; charset=utf-8"),
            t;
        const r = new DOMParser().parseFromString(n, "application/xml")
          , i = r.querySelectorAll("HttpHeader");
        if (i.length > 0) {
            let u;
            for (let d = 0, h = i.length; d < h; d++) {
                var a, o;
                u = i[d];
                const f = (a = u.querySelector("name")) == null ? void 0 : a.textContent
                  , m = (o = u.querySelector("value")) == null ? void 0 : o.textContent;
                f && m && e.setRequestHeader(f, m)
            }
        }
        const l = r.querySelector("Challenge")
          , c = l == null ? void 0 : l.textContent;
        if (!c)
            throw new Error("Cannot find <Challenge> in key message");
        return Jc(atob(c))
    }
    setupLicenseXHR(e, t, n, r) {
        const i = this.config.licenseXhrSetup;
        return i ? Promise.resolve().then( () => {
            if (!n.decryptdata)
                throw new Error("Key removed");
            return i.call(this.hls, e, t, n, r)
        }
        ).catch(a => {
            if (!n.decryptdata)
                throw a;
            return e.open("POST", t, !0),
            i.call(this.hls, e, t, n, r)
        }
        ).then(a => (e.readyState || e.open("POST", t, !0),
        {
            xhr: e,
            licenseChallenge: a || r
        })) : (e.open("POST", t, !0),
        Promise.resolve({
            xhr: e,
            licenseChallenge: r
        }))
    }
    requestLicense(e, t) {
        const n = this.config.keyLoadPolicy.default;
        return new Promise( (r, i) => {
            const a = this.getLicenseServerUrlOrThrow(e.keySystem);
            this.log(`Sending license request to URL: ${a}`);
            const o = new XMLHttpRequest;
            o.responseType = "arraybuffer",
            o.onreadystatechange = () => {
                if (!this.hls || !e.mediaKeysSession)
                    return i(new Error("invalid state"));
                if (o.readyState === 4)
                    if (o.status === 200) {
                        this._requestLicenseFailureCount = 0;
                        let l = o.response;
                        this.log(`License received ${linstanceof ArrayBuffer ? l.byteLength : l}`);
                        const c = this.config.licenseResponseCallback;
                        if (c)
                            try {
                                l = c.call(this.hls, o, a, e)
                            } catch (u) {
                                this.error(u)
                            }
                        r(l)
                    } else {
                        const l = n.errorRetry
                          , c = l ? l.maxNumRetry : 0;
                        if (this._requestLicenseFailureCount++,
                        this._requestLicenseFailureCount > c || o.status >= 400 && o.status < 500)
                            i(new zt({
                                type: q.KEY_SYSTEM_ERROR,
                                details: N.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                                decryptdata: e.decryptdata,
                                fatal: !0,
                                networkDetails: o,
                                response: {
                                    url: a,
                                    data: void 0,
                                    code: o.status,
                                    text: o.statusText
                                }
                            },`License Request XHR failed (${a}). Status: ${o.status} (${o.statusText})`));
                        else {
                            const u = c - this._requestLicenseFailureCount + 1;
                            this.warn(`Retrying license request, ${u} attempts left`),
                            this.requestLicense(e, t).then(r, i)
                        }
                    }
            }
            ,
            e.licenseXhr && e.licenseXhr.readyState !== XMLHttpRequest.DONE && e.licenseXhr.abort(),
            e.licenseXhr = o,
            this.setupLicenseXHR(o, a, e, t).then( ({xhr: l, licenseChallenge: c}) => {
                e.keySystem == Pe.PLAYREADY && (c = this.unpackPlayReadyKeyMessage(l, c)),
                l.send(c)
            }
            ).catch(i)
        }
        )
    }
    onDestroying() {
        this.unregisterListeners(),
        this._clear()
    }
    onMediaAttached(e, t) {
        if (!this.config.emeEnabled)
            return;
        const n = t.media;
        this.media = n,
        lt(n, "encrypted", this.onMediaEncrypted),
        lt(n, "waitingforkey", this.onWaitingForKey)
    }
    onMediaDetached() {
        const e = this.media;
        e && (yt(e, "encrypted", this.onMediaEncrypted),
        yt(e, "waitingforkey", this.onWaitingForKey),
        this.media = null,
        this.mediaKeys = null)
    }
    _clear() {
        var e;
        if (this._requestLicenseFailureCount = 0,
        this.keyIdToKeySessionPromise = {},
        this.bannedKeyIds = {},
        !this.mediaKeys && !this.mediaKeySessions.length)
            return;
        const t = this.media
          , n = this.mediaKeySessions.slice();
        this.mediaKeySessions = [],
        this.mediaKeys = null,
        Xo.clearKeyUriToKeyIdMap();
        const r = n.length;
        mr.CDMCleanupPromise = Promise.all(n.map(i => this.removeSession(i)).concat(t == null || (e = t.setMediaKeys(null)) == null ? void 0 : e.catch(i => {
            this.log(`Could not clear media keys: ${i}`),
            this.hls && this.hls.trigger(S.ERROR, {
                type: q.OTHER_ERROR,
                details: N.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,
                fatal: !1,
                error: new Error(`Could not clear media keys: ${i}`)
            })
        }
        ))).catch(i => {
            this.log(`Could not close sessions and clear media keys: ${i}`),
            this.hls && this.hls.trigger(S.ERROR, {
                type: q.OTHER_ERROR,
                details: N.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
                fatal: !1,
                error: new Error(`Could not close sessions and clear media keys: ${i}`)
            })
        }
        ).then( () => {
            r && this.log("finished closing key sessions and clearing media keys")
        }
        )
    }
    onManifestLoading() {
        this.keyFormatPromise = null,
        this.bannedKeyIds = {}
    }
    onManifestLoaded(e, {sessionKeys: t}) {
        if (!(!t || !this.config.emeEnabled) && !this.keyFormatPromise) {
            const n = t.reduce( (r, i) => (r.indexOf(i.keyFormat) === -1 && r.push(i.keyFormat),
            r), []);
            this.log(`Selecting key-system from session-keys ${n.join(", ")}`),
            this.keyFormatPromise = this.getKeyFormatPromise(n)
        }
    }
    removeSession(e) {
        const {mediaKeysSession: t, licenseXhr: n, decryptdata: r} = e;
        if (t) {
            this.log(`Remove licenses and keys and close session "${t.sessionId}" keyId: ${It((r == null ? void 0 : r.keyId) || [])}`),
            e._onmessage && (t.removeEventListener("message", e._onmessage),
            e._onmessage = void 0),
            e._onkeystatuseschange && (t.removeEventListener("keystatuseschange", e._onkeystatuseschange),
            e._onkeystatuseschange = void 0),
            n && n.readyState !== XMLHttpRequest.DONE && n.abort(),
            e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;
            const i = this.mediaKeySessions.indexOf(e);
            i > -1 && this.mediaKeySessions.splice(i, 1);
            const {drmSystemOptions: a} = this.config;
            return (r1(a) ? new Promise( (l, c) => {
                self.setTimeout( () => c(new Error("MediaKeySession.remove() timeout")), 8e3),
                t.remove().then(l).catch(c)
            }
            ) : Promise.resolve()).catch(l => {
                this.log(`Could not remove session: ${l}`),
                this.hls && this.hls.trigger(S.ERROR, {
                    type: q.OTHER_ERROR,
                    details: N.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,
                    fatal: !1,
                    error: new Error(`Could not remove session: ${l}`)
                })
            }
            ).then( () => t.close()).catch(l => {
                this.log(`Could not close session: ${l}`),
                this.hls && this.hls.trigger(S.ERROR, {
                    type: q.OTHER_ERROR,
                    details: N.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,
                    fatal: !1,
                    error: new Error(`Could not close session: ${l}`)
                })
            }
            )
        }
    }
}
mr.CDMCleanupPromise = void 0;
class zt extends Error {
    constructor(e, t) {
        super(t),
        this.data = void 0,
        e.error || (e.error = new Error(t)),
        this.data = e,
        e.err = e.error
    }
}
function Qf(s, e) {
    const t = s === "output-restricted"
      , n = t ? N.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED : N.KEY_SYSTEM_STATUS_INTERNAL_ERROR;
    return new zt({
        type: q.KEY_SYSTEM_ERROR,
        details: n,
        fatal: !1,
        decryptdata: e
    },t ? "HDCP level output restricted" : `key status changed to "${s}"`)
}
class LI {
    constructor(e) {
        this.hls = void 0,
        this.isVideoPlaybackQualityAvailable = !1,
        this.timer = void 0,
        this.media = null,
        this.lastTime = void 0,
        this.lastDroppedFrames = 0,
        this.lastDecodedFrames = 0,
        this.streamController = void 0,
        this.hls = e,
        this.registerListeners()
    }
    setStreamController(e) {
        this.streamController = e
    }
    registerListeners() {
        this.hls.on(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        this.hls.on(S.MEDIA_DETACHING, this.onMediaDetaching, this)
    }
    unregisterListeners() {
        this.hls.off(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        this.hls.off(S.MEDIA_DETACHING, this.onMediaDetaching, this)
    }
    destroy() {
        this.timer && clearInterval(this.timer),
        this.unregisterListeners(),
        this.isVideoPlaybackQualityAvailable = !1,
        this.media = null
    }
    onMediaAttaching(e, t) {
        const n = this.hls.config;
        if (n.capLevelOnFPSDrop) {
            const r = t.media instanceof self.HTMLVideoElement ? t.media : null;
            this.media = r,
            r && typeof r.getVideoPlaybackQuality == "function" && (this.isVideoPlaybackQualityAvailable = !0),
            self.clearInterval(this.timer),
            this.timer = self.setInterval(this.checkFPSInterval.bind(this), n.fpsDroppedMonitoringPeriod)
        }
    }
    onMediaDetaching() {
        this.media = null
    }
    checkFPS(e, t, n) {
        const r = performance.now();
        if (t) {
            if (this.lastTime) {
                const i = r - this.lastTime
                  , a = n - this.lastDroppedFrames
                  , o = t - this.lastDecodedFrames
                  , l = 1e3 * a / i
                  , c = this.hls;
                if (c.trigger(S.FPS_DROP, {
                    currentDropped: a,
                    currentDecoded: o,
                    totalDroppedFrames: n
                }),
                l > 0 && a > c.config.fpsDroppedMonitoringThreshold * o) {
                    let u = c.currentLevel;
                    c.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + u),
                    u > 0 && (c.autoLevelCapping === -1 || c.autoLevelCapping >= u) && (u = u - 1,
                    c.trigger(S.FPS_DROP_LEVEL_CAPPING, {
                        level: u,
                        droppedLevel: c.currentLevel
                    }),
                    c.autoLevelCapping = u,
                    this.streamController.nextLevelSwitch())
                }
            }
            this.lastTime = r,
            this.lastDroppedFrames = n,
            this.lastDecodedFrames = t
        }
    }
    checkFPSInterval() {
        const e = this.media;
        if (e)
            if (this.isVideoPlaybackQualityAvailable) {
                const t = e.getVideoPlaybackQuality();
                this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)
            } else
                this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount)
    }
}
function ry(s, e) {
    let t;
    try {
        t = new Event("addtrack")
    } catch {
        t = document.createEvent("Event"),
        t.initEvent("addtrack", !1, !1)
    }
    t.track = s,
    e.dispatchEvent(t)
}
function iy(s, e) {
    const t = s.mode;
    if (t === "disabled" && (s.mode = "hidden"),
    s.cues && !s.cues.getCueById(e.id))
        try {
            if (s.addCue(e),
            !s.cues.getCueById(e.id))
                throw new Error(`addCue is failed for: ${e}`)
        } catch (n) {
            fe.debug(`[texttrack-utils]: ${n}`);
            try {
                const r = new self.TextTrackCue(e.startTime,e.endTime,e.text);
                r.id = e.id,
                s.addCue(r)
            } catch (r) {
                fe.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${r}`)
            }
        }
    t === "disabled" && (s.mode = t)
}
function nr(s, e) {
    const t = s.mode;
    if (t === "disabled" && (s.mode = "hidden"),
    s.cues)
        for (let n = s.cues.length; n--; )
            e && s.cues[n].removeEventListener("enter", e),
            s.removeCue(s.cues[n]);
    t === "disabled" && (s.mode = t)
}
function lu(s, e, t, n) {
    const r = s.mode;
    if (r === "disabled" && (s.mode = "hidden"),
    s.cues && s.cues.length > 0) {
        const i = AI(s.cues, e, t);
        for (let a = 0; a < i.length; a++)
            (!n || n(i[a])) && s.removeCue(i[a])
    }
    r === "disabled" && (s.mode = r)
}
function II(s, e) {
    if (e <= s[0].startTime)
        return 0;
    const t = s.length - 1;
    if (e > s[t].endTime)
        return -1;
    let n = 0, r = t, i;
    for (; n <= r; )
        if (i = Math.floor((r + n) / 2),
        e < s[i].startTime)
            r = i - 1;
        else if (e > s[i].startTime && n < t)
            n = i + 1;
        else
            return i;
    return s[n].startTime - e < e - s[r].startTime ? n : r
}
function AI(s, e, t) {
    const n = []
      , r = II(s, e);
    if (r > -1)
        for (let i = r, a = s.length; i < a; i++) {
            const o = s[i];
            if (o.startTime >= e && o.endTime <= t)
                n.push(o);
            else if (o.startTime > t)
                return n
        }
    return n
}
function Ga(s) {
    const e = [];
    for (let t = 0; t < s.length; t++) {
        const n = s[t];
        (n.kind === "subtitles" || n.kind === "captions") && n.label && e.push(s[t])
    }
    return e
}
class bI extends Cd {
    constructor(e) {
        super(e, "subtitle-track-controller"),
        this.media = null,
        this.tracks = [],
        this.groupIds = null,
        this.tracksInGroup = [],
        this.trackId = -1,
        this.currentTrack = null,
        this.selectDefaultTrack = !0,
        this.queuedDefaultTrack = -1,
        this.useTextTrackPolling = !1,
        this.subtitlePollingInterval = -1,
        this._subtitleDisplay = !0,
        this.asyncPollTrackChange = () => this.pollTrackChange(0),
        this.onTextTracksChanged = () => {
            if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval),
            !this.media || !this.hls.config.renderTextTracksNatively)
                return;
            let t = null;
            const n = Ga(this.media.textTracks);
            for (let i = 0; i < n.length; i++)
                if (n[i].mode === "hidden")
                    t = n[i];
                else if (n[i].mode === "showing") {
                    t = n[i];
                    break
                }
            const r = this.findTrackForTextTrack(t);
            this.subtitleTrack !== r && this.setSubtitleTrack(r)
        }
        ,
        this.registerListeners()
    }
    destroy() {
        this.unregisterListeners(),
        this.tracks.length = 0,
        this.tracksInGroup.length = 0,
        this.currentTrack = null,
        this.onTextTracksChanged = this.asyncPollTrackChange = null,
        super.destroy()
    }
    get subtitleDisplay() {
        return this._subtitleDisplay
    }
    set subtitleDisplay(e) {
        this._subtitleDisplay = e,
        this.trackId > -1 && this.toggleTrackModes()
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(S.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(S.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.on(S.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.on(S.ERROR, this.onError, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(S.LEVEL_LOADING, this.onLevelLoading, this),
        e.off(S.LEVEL_SWITCHING, this.onLevelSwitching, this),
        e.off(S.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.off(S.ERROR, this.onError, this)
    }
    onMediaAttached(e, t) {
        this.media = t.media,
        this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack,
        this.queuedDefaultTrack = -1),
        this.useTextTrackPolling = !(this.media.textTracks && "onchange"in this.media.textTracks),
        this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
    }
    pollTrackChange(e) {
        self.clearInterval(this.subtitlePollingInterval),
        this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e)
    }
    onMediaDetaching(e, t) {
        const n = this.media;
        if (!n)
            return;
        const r = !!t.transferMedia;
        if (self.clearInterval(this.subtitlePollingInterval),
        this.useTextTrackPolling || n.textTracks.removeEventListener("change", this.asyncPollTrackChange),
        this.trackId > -1 && (this.queuedDefaultTrack = this.trackId),
        this.subtitleTrack = -1,
        this.media = null,
        r)
            return;
        Ga(n.textTracks).forEach(a => {
            nr(a)
        }
        )
    }
    onManifestLoading() {
        this.tracks = [],
        this.groupIds = null,
        this.tracksInGroup = [],
        this.trackId = -1,
        this.currentTrack = null,
        this.selectDefaultTrack = !0
    }
    onManifestParsed(e, t) {
        this.tracks = t.subtitleTracks
    }
    onSubtitleTrackLoaded(e, t) {
        const {id: n, groupId: r, details: i} = t
          , a = this.tracksInGroup[n];
        if (!a || a.groupId !== r) {
            this.warn(`Subtitle track with id:${n} and group:${r} not found in active group ${a == null ? void 0 : a.groupId}`);
            return
        }
        const o = a.details;
        a.details = t.details,
        this.log(`Subtitle track ${n} "${a.name}" lang:${a.lang} group:${r} loaded [${i.startSN}-${i.endSN}]`),
        n === this.trackId && this.playlistLoaded(n, t, o)
    }
    onLevelLoading(e, t) {
        this.switchLevel(t.level)
    }
    onLevelSwitching(e, t) {
        this.switchLevel(t.level)
    }
    switchLevel(e) {
        const t = this.hls.levels[e];
        if (!t)
            return;
        const n = t.subtitleGroups || null
          , r = this.groupIds;
        let i = this.currentTrack;
        if (!n || (r == null ? void 0 : r.length) !== (n == null ? void 0 : n.length) || n != null && n.some(a => (r == null ? void 0 : r.indexOf(a)) === -1)) {
            this.groupIds = n,
            this.trackId = -1,
            this.currentTrack = null;
            const a = this.tracks.filter(u => !n || n.indexOf(u.groupId) !== -1);
            if (a.length)
                this.selectDefaultTrack && !a.some(u => u.default) && (this.selectDefaultTrack = !1),
                a.forEach( (u, d) => {
                    u.id = d
                }
                );
            else if (!i && !this.tracksInGroup.length)
                return;
            this.tracksInGroup = a;
            const o = this.hls.config.subtitlePreference;
            if (!i && o) {
                this.selectDefaultTrack = !1;
                const u = ls(o, a);
                if (u > -1)
                    i = a[u];
                else {
                    const d = ls(o, this.tracks);
                    i = this.tracks[d]
                }
            }
            let l = this.findTrackId(i);
            l === -1 && i && (l = this.findTrackId(null));
            const c = {
                subtitleTracks: a
            };
            this.log(`Updating subtitle tracks, ${a.length} track(s) found in "${n == null ? void 0 : n.join(",")}" group-id`),
            this.hls.trigger(S.SUBTITLE_TRACKS_UPDATED, c),
            l !== -1 && this.trackId === -1 && this.setSubtitleTrack(l)
        }
    }
    findTrackId(e) {
        const t = this.tracksInGroup
          , n = this.selectDefaultTrack;
        for (let r = 0; r < t.length; r++) {
            const i = t[r];
            if (!(n && !i.default || !n && !e) && (!e || Rn(i, e)))
                return r
        }
        if (e) {
            for (let r = 0; r < t.length; r++) {
                const i = t[r];
                if (ki(e.attrs, i.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"]))
                    return r
            }
            for (let r = 0; r < t.length; r++) {
                const i = t[r];
                if (ki(e.attrs, i.attrs, ["LANGUAGE"]))
                    return r
            }
        }
        return -1
    }
    findTrackForTextTrack(e) {
        if (e) {
            const t = this.tracksInGroup;
            for (let n = 0; n < t.length; n++) {
                const r = t[n];
                if (ru(r, e))
                    return n
            }
        }
        return -1
    }
    onError(e, t) {
        t.fatal || !t.context || t.context.type === le.SUBTITLE_TRACK && t.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) && this.checkRetry(t)
    }
    get allSubtitleTracks() {
        return this.tracks
    }
    get subtitleTracks() {
        return this.tracksInGroup
    }
    get subtitleTrack() {
        return this.trackId
    }
    set subtitleTrack(e) {
        this.selectDefaultTrack = !1,
        this.setSubtitleTrack(e)
    }
    setSubtitleOption(e) {
        if (this.hls.config.subtitlePreference = e,
        e) {
            if (e.id === -1)
                return this.setSubtitleTrack(-1),
                null;
            const t = this.allSubtitleTracks;
            if (this.selectDefaultTrack = !1,
            t.length) {
                const n = this.currentTrack;
                if (n && Rn(e, n))
                    return n;
                const r = ls(e, this.tracksInGroup);
                if (r > -1) {
                    const i = this.tracksInGroup[r];
                    return this.setSubtitleTrack(r),
                    i
                } else {
                    if (n)
                        return null;
                    {
                        const i = ls(e, t);
                        if (i > -1)
                            return t[i]
                    }
                }
            }
        }
        return null
    }
    loadPlaylist(e) {
        super.loadPlaylist(),
        this.shouldLoadPlaylist(this.currentTrack) && this.scheduleLoading(this.currentTrack, e)
    }
    loadingPlaylist(e, t) {
        super.loadingPlaylist(e, t);
        const n = e.id
          , r = e.groupId
          , i = this.getUrlWithDirectives(e.url, t)
          , a = e.details
          , o = a == null ? void 0 : a.age;
        this.log(`Loading subtitle ${n} "${e.name}" lang:${e.lang} group:${r}${(t == null ? void 0 : t.msn) !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${i}`),
        this.hls.trigger(S.SUBTITLE_TRACK_LOADING, {
            url: i,
            id: n,
            groupId: r,
            deliveryDirectives: t || null,
            track: e
        })
    }
    toggleTrackModes() {
        const {media: e} = this;
        if (!e)
            return;
        const t = Ga(e.textTracks)
          , n = this.currentTrack;
        let r;
        if (n && (r = t.filter(i => ru(n, i))[0],
        r || this.warn(`Unable to find subtitle TextTrack with name "${n.name}" and language "${n.lang}"`)),
        [].slice.call(t).forEach(i => {
            i.mode !== "disabled" && i !== r && (i.mode = "disabled")
        }
        ),
        r) {
            const i = this.subtitleDisplay ? "showing" : "hidden";
            r.mode !== i && (r.mode = i)
        }
    }
    setSubtitleTrack(e) {
        const t = this.tracksInGroup;
        if (!this.media) {
            this.queuedDefaultTrack = e;
            return
        }
        if (e < -1 || e >= t.length || !z(e)) {
            this.warn(`Invalid subtitle track id: ${e}`);
            return
        }
        this.selectDefaultTrack = !1;
        const n = this.currentTrack
          , r = t[e] || null;
        if (this.trackId = e,
        this.currentTrack = r,
        this.toggleTrackModes(),
        !r) {
            this.hls.trigger(S.SUBTITLE_TRACK_SWITCH, {
                id: e
            });
            return
        }
        const i = !!r.details && !r.details.live;
        if (e === this.trackId && r === n && i)
            return;
        this.log(`Switching to subtitle-track ${e}` + (r ? ` "${r.name}" lang:${r.lang} group:${r.groupId}` : ""));
        const {id: a, groupId: o="", name: l, type: c, url: u} = r;
        this.hls.trigger(S.SUBTITLE_TRACK_SWITCH, {
            id: a,
            groupId: o,
            name: l,
            type: c,
            url: u
        });
        const d = this.switchParams(r.url, n == null ? void 0 : n.details, r.details);
        this.loadPlaylist(d)
    }
}
function RI() {
    try {
        return crypto.randomUUID()
    } catch {
        try {
            const e = URL.createObjectURL(new Blob)
              , t = e.toString();
            return URL.revokeObjectURL(e),
            t.slice(t.lastIndexOf("/") + 1)
        } catch {
            let t = new Date().getTime();
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, r => {
                const i = (t + Math.random() * 16) % 16 | 0;
                return t = Math.floor(t / 16),
                (r == "x" ? i : i & 3 | 8).toString(16)
            }
            )
        }
    }
}
function ii(s) {
    let e = 5381
      , t = s.length;
    for (; t; )
        e = e * 33 ^ s.charCodeAt(--t);
    return (e >>> 0).toString()
}
const gr = .025;
let wo = function(s) {
    return s[s.Point = 0] = "Point",
    s[s.Range = 1] = "Range",
    s
}({});
function wI(s, e, t) {
    return `${s.identifier}-${t + 1}-${ii(e)}`
}
class CI {
    constructor(e, t) {
        this.base = void 0,
        this._duration = null,
        this._timelineStart = null,
        this.appendInPlaceDisabled = void 0,
        this.appendInPlaceStarted = void 0,
        this.dateRange = void 0,
        this.hasPlayed = !1,
        this.cumulativeDuration = 0,
        this.resumeOffset = NaN,
        this.playoutLimit = NaN,
        this.restrictions = {
            skip: !1,
            jump: !1
        },
        this.snapOptions = {
            out: !1,
            in: !1
        },
        this.assetList = [],
        this.assetListLoader = void 0,
        this.assetListResponse = null,
        this.resumeAnchor = void 0,
        this.error = void 0,
        this.resetOnResume = void 0,
        this.base = t,
        this.dateRange = e,
        this.setDateRange(e)
    }
    setDateRange(e) {
        this.dateRange = e,
        this.resumeOffset = e.attr.optionalFloat("X-RESUME-OFFSET", this.resumeOffset),
        this.playoutLimit = e.attr.optionalFloat("X-PLAYOUT-LIMIT", this.playoutLimit),
        this.restrictions = e.attr.enumeratedStringList("X-RESTRICT", this.restrictions),
        this.snapOptions = e.attr.enumeratedStringList("X-SNAP", this.snapOptions)
    }
    reset() {
        var e;
        this.appendInPlaceStarted = !1,
        (e = this.assetListLoader) == null || e.destroy(),
        this.assetListLoader = void 0,
        this.supplementsPrimary || (this.assetListResponse = null,
        this.assetList = [],
        this._duration = null)
    }
    isAssetPastPlayoutLimit(e) {
        var t;
        if (e > 0 && e >= this.assetList.length)
            return !0;
        const n = this.playoutLimit;
        return e <= 0 || isNaN(n) ? !1 : n === 0 ? !0 : (((t = this.assetList[e]) == null ? void 0 : t.startOffset) || 0) > n
    }
    findAssetIndex(e) {
        return this.assetList.indexOf(e)
    }
    get identifier() {
        return this.dateRange.id
    }
    get startDate() {
        return this.dateRange.startDate
    }
    get startTime() {
        const e = this.dateRange.startTime;
        if (this.snapOptions.out) {
            const t = this.dateRange.tagAnchor;
            if (t)
                return jl(e, t)
        }
        return e
    }
    get startOffset() {
        return this.cue.pre ? 0 : this.startTime
    }
    get startIsAligned() {
        if (this.startTime === 0 || this.snapOptions.out)
            return !0;
        const e = this.dateRange.tagAnchor;
        if (e) {
            const t = this.dateRange.startTime
              , n = jl(t, e);
            return t - n < .1
        }
        return !1
    }
    get resumptionOffset() {
        const e = this.resumeOffset
          , t = z(e) ? e : this.duration;
        return this.cumulativeDuration + t
    }
    get resumeTime() {
        const e = this.startOffset + this.resumptionOffset;
        if (this.snapOptions.in) {
            const t = this.resumeAnchor;
            if (t)
                return jl(e, t)
        }
        return e
    }
    get appendInPlace() {
        return this.appendInPlaceStarted ? !0 : this.appendInPlaceDisabled ? !1 : !!(!this.cue.once && !this.cue.pre && this.startIsAligned && (isNaN(this.playoutLimit) && isNaN(this.resumeOffset) || this.resumeOffset && this.duration && Math.abs(this.resumeOffset - this.duration) < gr))
    }
    set appendInPlace(e) {
        if (this.appendInPlaceStarted) {
            this.resetOnResume = !e;
            return
        }
        this.appendInPlaceDisabled = !e
    }
    get timelineStart() {
        return this._timelineStart !== null ? this._timelineStart : this.startTime
    }
    set timelineStart(e) {
        this._timelineStart = e
    }
    get duration() {
        const e = this.playoutLimit;
        let t;
        return this._duration !== null ? t = this._duration : this.dateRange.duration ? t = this.dateRange.duration : t = this.dateRange.plannedDuration || 0,
        !isNaN(e) && e < t && (t = e),
        t
    }
    set duration(e) {
        this._duration = e
    }
    get cue() {
        return this.dateRange.cue
    }
    get timelineOccupancy() {
        return this.dateRange.attr["X-TIMELINE-OCCUPIES"] === "RANGE" ? wo.Range : wo.Point
    }
    get supplementsPrimary() {
        return this.dateRange.attr["X-TIMELINE-STYLE"] === "PRIMARY"
    }
    get contentMayVary() {
        return this.dateRange.attr["X-CONTENT-MAY-VARY"] !== "NO"
    }
    get assetUrl() {
        return this.dateRange.attr["X-ASSET-URI"]
    }
    get assetListUrl() {
        return this.dateRange.attr["X-ASSET-LIST"]
    }
    get baseUrl() {
        return this.base.url
    }
    get assetListLoaded() {
        return this.assetList.length > 0 || this.assetListResponse !== null
    }
    toString() {
        return kI(this)
    }
}
function jl(s, e) {
    return s - e.start < e.duration / 2 && !(Math.abs(s - (e.start + e.duration)) < gr) ? e.start : e.start + e.duration
}
function ay(s, e, t) {
    const n = new self.URL(s,t);
    return n.protocol !== "data:" && n.searchParams.set("_HLS_primary_id", e),
    n
}
function Gl(s, e) {
    for (; (t = s.assetList[++e]) != null && t.error; )
        var t;
    return e
}
function kI(s) {
    return `["${s.identifier}" ${s.cue.pre ? "<pre>" : s.cue.post ? "<post>" : ""}${s.timelineStart.toFixed(2)}-${s.resumeTime.toFixed(2)}]`
}
function Hn(s) {
    const e = s.timelineStart
      , t = s.duration || 0;
    return `["${s.identifier}" ${e.toFixed(2)}-${(e + t).toFixed(2)}]`
}
class _I {
    constructor(e, t, n, r) {
        this.hls = void 0,
        this.interstitial = void 0,
        this.assetItem = void 0,
        this.tracks = null,
        this.hasDetails = !1,
        this.mediaAttached = null,
        this._currentTime = void 0,
        this._bufferedEosTime = void 0,
        this.checkPlayout = () => {
            this.reachedPlayout(this.currentTime) && this.hls && this.hls.trigger(S.PLAYOUT_LIMIT_REACHED, {})
        }
        ;
        const i = this.hls = new e(t);
        this.interstitial = n,
        this.assetItem = r;
        const a = () => {
            this.hasDetails = !0
        }
        ;
        i.once(S.LEVEL_LOADED, a),
        i.once(S.AUDIO_TRACK_LOADED, a),
        i.once(S.SUBTITLE_TRACK_LOADED, a),
        i.on(S.MEDIA_ATTACHING, (o, {media: l}) => {
            this.removeMediaListeners(),
            this.mediaAttached = l,
            this.interstitial.playoutLimit && (l.addEventListener("timeupdate", this.checkPlayout),
            this.appendInPlace && i.on(S.BUFFER_APPENDED, () => {
                const u = this.bufferedEnd;
                this.reachedPlayout(u) && (this._bufferedEosTime = u,
                i.trigger(S.BUFFERED_TO_END, void 0))
            }
            ))
        }
        )
    }
    get appendInPlace() {
        return this.interstitial.appendInPlace
    }
    loadSource() {
        const e = this.hls;
        if (e)
            if (e.url)
                e.levels.length && !e.started && e.startLoad(-1, !0);
            else {
                let t = this.assetItem.uri;
                try {
                    t = ay(t, e.config.primarySessionId || "").href
                } catch {}
                e.loadSource(t)
            }
    }
    bufferedInPlaceToEnd(e) {
        var t;
        if (!this.appendInPlace)
            return !1;
        if ((t = this.hls) != null && t.bufferedToEnd)
            return !0;
        if (!e)
            return !1;
        const n = Math.min(this._bufferedEosTime || 1 / 0, this.duration)
          , r = this.timelineOffset
          , i = ie.bufferInfo(e, r, 0);
        return this.getAssetTime(i.end) >= n - .02
    }
    reachedPlayout(e) {
        const n = this.interstitial.playoutLimit;
        return this.startOffset + e >= n
    }
    get destroyed() {
        var e;
        return !((e = this.hls) != null && e.userConfig)
    }
    get assetId() {
        return this.assetItem.identifier
    }
    get interstitialId() {
        return this.assetItem.parentIdentifier
    }
    get media() {
        var e;
        return ((e = this.hls) == null ? void 0 : e.media) || null
    }
    get bufferedEnd() {
        const e = this.media || this.mediaAttached;
        if (!e)
            return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime;
        const t = ie.bufferInfo(e, e.currentTime, .001);
        return this.getAssetTime(t.end)
    }
    get currentTime() {
        const e = this.media || this.mediaAttached;
        return e ? this.getAssetTime(e.currentTime) : this._currentTime || 0
    }
    get duration() {
        const e = this.assetItem.duration;
        if (!e)
            return 0;
        const t = this.interstitial.playoutLimit;
        if (t) {
            const n = t - this.startOffset;
            if (n > 0 && n < e)
                return n
        }
        return e
    }
    get remaining() {
        const e = this.duration;
        return e ? Math.max(0, e - this.currentTime) : 0
    }
    get startOffset() {
        return this.assetItem.startOffset
    }
    get timelineOffset() {
        var e;
        return ((e = this.hls) == null ? void 0 : e.config.timelineOffset) || 0
    }
    set timelineOffset(e) {
        const t = this.timelineOffset;
        if (e !== t) {
            const n = e - t;
            if (Math.abs(n) > 1 / 9e4 && this.hls) {
                if (this.hasDetails)
                    throw new Error("Cannot set timelineOffset after playlists are loaded");
                this.hls.config.timelineOffset = e
            }
        }
    }
    getAssetTime(e) {
        const t = this.timelineOffset
          , n = this.duration;
        return Math.min(Math.max(0, e - t), n)
    }
    removeMediaListeners() {
        const e = this.mediaAttached;
        e && (this._currentTime = e.currentTime,
        this.bufferSnapShot(),
        e.removeEventListener("timeupdate", this.checkPlayout))
    }
    bufferSnapShot() {
        if (this.mediaAttached) {
            var e;
            (e = this.hls) != null && e.bufferedToEnd && (this._bufferedEosTime = this.bufferedEnd)
        }
    }
    destroy() {
        this.removeMediaListeners(),
        this.hls && this.hls.destroy(),
        this.hls = null,
        this.tracks = this.mediaAttached = this.checkPlayout = null
    }
    attachMedia(e) {
        var t;
        this.loadSource(),
        (t = this.hls) == null || t.attachMedia(e)
    }
    detachMedia() {
        var e;
        this.removeMediaListeners(),
        this.mediaAttached = null,
        (e = this.hls) == null || e.detachMedia()
    }
    resumeBuffering() {
        var e;
        (e = this.hls) == null || e.resumeBuffering()
    }
    pauseBuffering() {
        var e;
        (e = this.hls) == null || e.pauseBuffering()
    }
    transferMedia() {
        var e;
        return this.bufferSnapShot(),
        ((e = this.hls) == null ? void 0 : e.transferMedia()) || null
    }
    resetDetails() {
        const e = this.hls;
        if (e && this.hasDetails) {
            e.stopLoad();
            const t = n => delete n.details;
            e.levels.forEach(t),
            e.allAudioTracks.forEach(t),
            e.allSubtitleTracks.forEach(t),
            this.hasDetails = !1
        }
    }
    on(e, t, n) {
        var r;
        (r = this.hls) == null || r.on(e, t)
    }
    once(e, t, n) {
        var r;
        (r = this.hls) == null || r.once(e, t)
    }
    off(e, t, n) {
        var r;
        (r = this.hls) == null || r.off(e, t)
    }
    toString() {
        var e;
        return `HlsAssetPlayer: ${Hn(this.assetItem)} ${(e = this.hls) == null ? void 0 : e.sessionId} ${this.appendInPlace ? "append-in-place" : ""}`
    }
}
const Jf = .033;
class DI extends Gt {
    constructor(e, t) {
        super("interstitials-sched", t),
        this.onScheduleUpdate = void 0,
        this.eventMap = {},
        this.events = null,
        this.items = null,
        this.durations = {
            primary: 0,
            playout: 0,
            integrated: 0
        },
        this.onScheduleUpdate = e
    }
    destroy() {
        this.reset(),
        this.onScheduleUpdate = null
    }
    reset() {
        this.eventMap = {},
        this.setDurations(0, 0, 0),
        this.events && this.events.forEach(e => e.reset()),
        this.events = this.items = null
    }
    resetErrorsInRange(e, t) {
        return this.events ? this.events.reduce( (n, r) => e <= r.startOffset && t > r.startOffset ? (delete r.error,
        n + 1) : n, 0) : 0
    }
    get duration() {
        const e = this.items;
        return e ? e[e.length - 1].end : 0
    }
    get length() {
        return this.items ? this.items.length : 0
    }
    getEvent(e) {
        return e && this.eventMap[e] || null
    }
    hasEvent(e) {
        return e in this.eventMap
    }
    findItemIndex(e, t) {
        if (e.event)
            return this.findEventIndex(e.event.identifier);
        let n = -1;
        e.nextEvent ? n = this.findEventIndex(e.nextEvent.identifier) - 1 : e.previousEvent && (n = this.findEventIndex(e.previousEvent.identifier) + 1);
        const r = this.items;
        if (r)
            for (r[n] || (t === void 0 && (t = e.start),
            n = this.findItemIndexAtTime(t)); n >= 0 && (i = r[n]) != null && i.event; ) {
                var i;
                n--
            }
        return n
    }
    findItemIndexAtTime(e, t) {
        const n = this.items;
        if (n)
            for (let r = 0; r < n.length; r++) {
                let i = n[r];
                if (t && t !== "primary" && (i = i[t]),
                e === i.start || e > i.start && e < i.end)
                    return r
            }
        return -1
    }
    findJumpRestrictedIndex(e, t) {
        const n = this.items;
        if (n)
            for (let r = e; r <= t && n[r]; r++) {
                const i = n[r].event;
                if (i != null && i.restrictions.jump && !i.appendInPlace)
                    return r
            }
        return -1
    }
    findEventIndex(e) {
        const t = this.items;
        if (t)
            for (let r = t.length; r--; ) {
                var n;
                if (((n = t[r].event) == null ? void 0 : n.identifier) === e)
                    return r
            }
        return -1
    }
    findAssetIndex(e, t) {
        const n = e.assetList
          , r = n.length;
        if (r > 1)
            for (let i = 0; i < r; i++) {
                const a = n[i];
                if (!a.error) {
                    const o = a.timelineStart;
                    if (t === o || t > o && (t < o + (a.duration || 0) || i === r - 1))
                        return i
                }
            }
        return 0
    }
    get assetIdAtEnd() {
        var e;
        const t = (e = this.items) == null || (e = e[this.length - 1]) == null ? void 0 : e.event;
        if (t) {
            const n = t.assetList
              , r = n[n.length - 1];
            if (r)
                return r.identifier
        }
        return null
    }
    parseInterstitialDateRanges(e, t) {
        const n = e.main.details
          , {dateRanges: r} = n
          , i = this.events
          , a = this.parseDateRanges(r, {
            url: n.url
        }, t)
          , o = Object.keys(r)
          , l = i ? i.filter(c => !o.includes(c.identifier)) : [];
        a.length && a.sort( (c, u) => {
            const d = c.cue.pre
              , h = c.cue.post
              , f = u.cue.pre
              , m = u.cue.post;
            if (d && !f)
                return -1;
            if (f && !d || h && !m)
                return 1;
            if (m && !h)
                return -1;
            if (!d && !f && !h && !m) {
                const p = c.startTime
                  , x = u.startTime;
                if (p !== x)
                    return p - x
            }
            return c.dateRange.tagOrder - u.dateRange.tagOrder
        }
        ),
        this.events = a,
        l.forEach(c => {
            this.removeEvent(c)
        }
        ),
        this.updateSchedule(e, l)
    }
    updateSchedule(e, t=[], n=!1) {
        const r = this.events || [];
        if (r.length || t.length || this.length < 2) {
            const i = this.items
              , a = this.parseSchedule(r, e);
            (n || t.length || (i == null ? void 0 : i.length) !== a.length || a.some( (l, c) => Math.abs(l.playout.start - i[c].playout.start) > .005 || Math.abs(l.playout.end - i[c].playout.end) > .005)) && (this.items = a,
            this.onScheduleUpdate(t, i))
        }
    }
    parseDateRanges(e, t, n) {
        const r = []
          , i = Object.keys(e);
        for (let a = 0; a < i.length; a++) {
            const o = i[a]
              , l = e[o];
            if (l.isInterstitial) {
                let c = this.eventMap[o];
                c ? c.setDateRange(l) : (c = new CI(l,t),
                this.eventMap[o] = c,
                n === !1 && (c.appendInPlace = n)),
                r.push(c)
            }
        }
        return r
    }
    parseSchedule(e, t) {
        const n = []
          , r = t.main.details
          , i = r.live ? 1 / 0 : r.edge;
        let a = 0;
        if (e = e.filter(l => !l.error && !(l.cue.once && l.hasPlayed)),
        e.length) {
            this.resolveOffsets(e, t);
            let l = 0
              , c = 0;
            if (e.forEach( (u, d) => {
                const h = u.cue.pre
                  , f = u.cue.post
                  , m = e[d - 1] || null
                  , p = u.appendInPlace
                  , x = f ? i : u.startOffset
                  , y = u.duration
                  , v = u.timelineOccupancy === wo.Range ? y : 0
                  , E = u.resumptionOffset
                  , T = (m == null ? void 0 : m.startTime) === x
                  , L = x + u.cumulativeDuration;
                let R = p ? L + y : x + E;
                if (h || !f && x <= 0) {
                    const A = c;
                    c += v,
                    u.timelineStart = L;
                    const C = a;
                    a += y,
                    n.push({
                        event: u,
                        start: L,
                        end: R,
                        playout: {
                            start: C,
                            end: a
                        },
                        integrated: {
                            start: A,
                            end: c
                        }
                    })
                } else if (x <= i) {
                    if (!T) {
                        const b = x - l;
                        if (b > Jf) {
                            const O = l
                              , _ = c;
                            c += b;
                            const $ = a;
                            a += b;
                            const K = {
                                previousEvent: e[d - 1] || null,
                                nextEvent: u,
                                start: O,
                                end: O + b,
                                playout: {
                                    start: $,
                                    end: a
                                },
                                integrated: {
                                    start: _,
                                    end: c
                                }
                            };
                            n.push(K)
                        } else
                            b > 0 && m && (m.cumulativeDuration += b,
                            n[n.length - 1].end = x)
                    }
                    f && (R = L),
                    u.timelineStart = L;
                    const A = c;
                    c += v;
                    const C = a;
                    a += y,
                    n.push({
                        event: u,
                        start: L,
                        end: R,
                        playout: {
                            start: C,
                            end: a
                        },
                        integrated: {
                            start: A,
                            end: c
                        }
                    })
                } else
                    return;
                const I = u.resumeTime;
                f || I > i ? l = i : l = I
            }
            ),
            l < i) {
                var o;
                const u = l
                  , d = c
                  , h = i - l;
                c += h;
                const f = a;
                a += h,
                n.push({
                    previousEvent: ((o = n[n.length - 1]) == null ? void 0 : o.event) || null,
                    nextEvent: null,
                    start: l,
                    end: u + h,
                    playout: {
                        start: f,
                        end: a
                    },
                    integrated: {
                        start: d,
                        end: c
                    }
                })
            }
            this.setDurations(i, a, c)
        } else
            n.push({
                previousEvent: null,
                nextEvent: null,
                start: 0,
                end: i,
                playout: {
                    start: 0,
                    end: i
                },
                integrated: {
                    start: 0,
                    end: i
                }
            }),
            this.setDurations(i, i, i);
        return n
    }
    setDurations(e, t, n) {
        this.durations = {
            primary: e,
            playout: t,
            integrated: n
        }
    }
    resolveOffsets(e, t) {
        const n = t.main.details
          , r = n.live ? 1 / 0 : n.edge;
        let i = 0
          , a = -1;
        e.forEach( (o, l) => {
            const c = o.cue.pre
              , u = o.cue.post
              , d = c ? 0 : u ? r : o.startTime;
            this.updateAssetDurations(o),
            a === d ? o.cumulativeDuration = i : (i = 0,
            a = d),
            !u && o.snapOptions.in && (o.resumeAnchor = Pn(null, n.fragments, o.startOffset + o.resumptionOffset, 0, 0) || void 0),
            o.appendInPlace && !o.appendInPlaceStarted && (this.primaryCanResumeInPlaceAt(o, t) || (o.appendInPlace = !1)),
            !o.appendInPlace && l + 1 < e.length && e[l + 1].startTime - e[l].resumeTime < Jf && (e[l + 1].appendInPlace = !1,
            e[l + 1].appendInPlace && this.warn(`Could not change append strategy for abutting event ${o}`));
            const f = z(o.resumeOffset) ? o.resumeOffset : o.duration;
            i += f
        }
        )
    }
    primaryCanResumeInPlaceAt(e, t) {
        const n = e.resumeTime
          , r = e.startTime + e.resumptionOffset;
        return Math.abs(n - r) > gr ? (this.log(`"${e.identifier}" resumption ${n} not aligned with estimated timeline end ${r}`),
        !1) : !Object.keys(t).some(a => {
            const o = t[a].details
              , l = o.edge;
            if (n >= l)
                return this.log(`"${e.identifier}" resumption ${n} past ${a} playlist end ${l}`),
                !1;
            const c = Pn(null, o.fragments, n);
            if (!c)
                return this.log(`"${e.identifier}" resumption ${n} does not align with any fragments in ${a} playlist (${o.fragStart}-${o.fragmentEnd})`),
                !0;
            const u = a === "audio" ? .175 : 0;
            return Math.abs(c.start - n) < gr + u || Math.abs(c.end - n) < gr + u ? !1 : (this.log(`"${e.identifier}" resumption ${n} not aligned with ${a} fragment bounds (${c.start}-${c.end} sn: ${c.sn} cc: ${c.cc})`),
            !0)
        }
        )
    }
    updateAssetDurations(e) {
        if (!e.assetListLoaded)
            return;
        const t = e.timelineStart;
        let n = 0
          , r = !1
          , i = !1;
        for (let a = 0; a < e.assetList.length; a++) {
            const o = e.assetList[a]
              , l = t + n;
            o.startOffset = n,
            o.timelineStart = l,
            r || (r = o.duration === null),
            i || (i = !!o.error);
            const c = o.error ? 0 : o.duration || 0;
            n += c
        }
        r && !i ? e.duration = Math.max(n, e.duration) : e.duration = n
    }
    removeEvent(e) {
        e.reset(),
        delete this.eventMap[e.identifier]
    }
}
function Kt(s) {
    return `[${s.event ? '"' + s.event.identifier + '"' : "primary"}: ${s.start.toFixed(2)}-${s.end.toFixed(2)}]`
}
class PI {
    constructor(e) {
        this.hls = void 0,
        this.hls = e
    }
    destroy() {
        this.hls = null
    }
    loadAssetList(e, t) {
        const n = e.assetListUrl;
        let r;
        try {
            r = ay(n, this.hls.sessionId, e.baseUrl)
        } catch (h) {
            const f = this.assignAssetListError(e, N.ASSET_LIST_LOAD_ERROR, h, n);
            this.hls.trigger(S.ERROR, f);
            return
        }
        t && r.protocol !== "data:" && r.searchParams.set("_HLS_start_offset", "" + t);
        const i = this.hls.config
          , a = i.loader
          , o = new a(i)
          , l = {
            responseType: "json",
            url: r.href
        }
          , c = i.interstitialAssetListLoadPolicy.default
          , u = {
            loadPolicy: c,
            timeout: c.maxLoadTimeMs,
            maxRetry: 0,
            retryDelay: 0,
            maxRetryDelay: 0
        }
          , d = {
            onSuccess: (h, f, m, p) => {
                const x = h.data
                  , y = x == null ? void 0 : x.ASSETS;
                if (!Array.isArray(y)) {
                    const v = this.assignAssetListError(e, N.ASSET_LIST_PARSING_ERROR, new Error("Invalid interstitial asset list"), m.url, f, p);
                    this.hls.trigger(S.ERROR, v);
                    return
                }
                e.assetListResponse = x,
                this.hls.trigger(S.ASSET_LIST_LOADED, {
                    event: e,
                    assetListResponse: x,
                    networkDetails: p
                })
            }
            ,
            onError: (h, f, m, p) => {
                const x = this.assignAssetListError(e, N.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${h.code} ${h.text} (${f.url})`), f.url, p, m);
                this.hls.trigger(S.ERROR, x)
            }
            ,
            onTimeout: (h, f, m) => {
                const p = this.assignAssetListError(e, N.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${f.url})`), f.url, h, m);
                this.hls.trigger(S.ERROR, p)
            }
        };
        return o.load(l, u, d),
        this.hls.trigger(S.ASSET_LIST_LOADING, {
            event: e
        }),
        o
    }
    assignAssetListError(e, t, n, r, i, a) {
        return e.error = n,
        {
            type: q.NETWORK_ERROR,
            details: t,
            fatal: !1,
            interstitial: e,
            url: r,
            error: n,
            networkDetails: a,
            stats: i
        }
    }
}
function em(s) {
    s == null || s.play().catch( () => {}
    )
}
function pa(s, e) {
    return `[${s}] Advancing timeline position to ${e}`
}
class NI extends Gt {
    constructor(e, t) {
        super("interstitials", e.logger),
        this.HlsPlayerClass = void 0,
        this.hls = void 0,
        this.assetListLoader = void 0,
        this.mediaSelection = null,
        this.altSelection = null,
        this.media = null,
        this.detachedData = null,
        this.requiredTracks = null,
        this.manager = null,
        this.playerQueue = [],
        this.bufferedPos = -1,
        this.timelinePos = -1,
        this.schedule = void 0,
        this.playingItem = null,
        this.bufferingItem = null,
        this.waitingItem = null,
        this.endedItem = null,
        this.playingAsset = null,
        this.endedAsset = null,
        this.bufferingAsset = null,
        this.shouldPlay = !1,
        this.onPlay = () => {
            this.shouldPlay = !0
        }
        ,
        this.onPause = () => {
            this.shouldPlay = !1
        }
        ,
        this.onSeeking = () => {
            const n = this.currentTime;
            if (n === void 0 || this.playbackDisabled || !this.schedule)
                return;
            const r = n - this.timelinePos;
            if (Math.abs(r) < 1 / 7056e5)
                return;
            const a = r <= -.01;
            this.timelinePos = n,
            this.bufferedPos = n;
            const o = this.playingItem;
            if (!o) {
                this.checkBuffer();
                return
            }
            if (a && this.schedule.resetErrorsInRange(n, n - r) && this.updateSchedule(!0),
            this.checkBuffer(),
            a && n < o.start || n >= o.end) {
                var l;
                const f = this.findItemIndex(o);
                let m = this.schedule.findItemIndexAtTime(n);
                if (m === -1 && (m = f + (a ? -1 : 1),
                this.log(`seeked ${a ? "back " : ""}to position not covered by schedule ${n} (resolving from ${f} to ${m})`)),
                !this.isInterstitial(o) && (l = this.media) != null && l.paused && (this.shouldPlay = !1),
                !a && m > f) {
                    const p = this.schedule.findJumpRestrictedIndex(f + 1, m);
                    if (p > f) {
                        this.setSchedulePosition(p);
                        return
                    }
                }
                this.setSchedulePosition(m);
                return
            }
            const c = this.playingAsset;
            if (!c) {
                if (this.playingLastItem && this.isInterstitial(o)) {
                    const f = o.event.assetList[0];
                    f && (this.endedItem = this.playingItem,
                    this.playingItem = null,
                    this.setScheduleToAssetAtTime(n, f))
                }
                return
            }
            const u = c.timelineStart
              , d = c.duration || 0;
            if (a && n < u || n >= u + d) {
                var h;
                (h = o.event) != null && h.appendInPlace && (this.clearInterstitial(o.event, o),
                this.flushFrontBuffer(n)),
                this.setScheduleToAssetAtTime(n, c)
            }
        }
        ,
        this.onTimeupdate = () => {
            const n = this.currentTime;
            if (n === void 0 || this.playbackDisabled)
                return;
            if (n > this.timelinePos)
                this.timelinePos = n,
                n > this.bufferedPos && this.checkBuffer();
            else
                return;
            const r = this.playingItem;
            if (!r || this.playingLastItem)
                return;
            if (n >= r.end) {
                this.timelinePos = r.end;
                const o = this.findItemIndex(r);
                this.setSchedulePosition(o + 1)
            }
            const i = this.playingAsset;
            if (!i)
                return;
            const a = i.timelineStart + (i.duration || 0);
            n >= a && this.setScheduleToAssetAtTime(n, i)
        }
        ,
        this.onScheduleUpdate = (n, r) => {
            const i = this.schedule;
            if (!i)
                return;
            const a = this.playingItem
              , o = i.events || []
              , l = i.items || []
              , c = i.durations
              , u = n.map(p => p.identifier)
              , d = !!(o.length || u.length);
            (d || r) && this.log(`INTERSTITIALS_UPDATED (${o.length}): ${o}
Schedule: ${l.map(p => Kt(p))} pos: ${this.timelinePos}`),
            u.length && this.log(`Removed events ${u}`);
            let h = null
              , f = null;
            a && (h = this.updateItem(a, this.timelinePos),
            this.itemsMatch(a, h) ? this.playingItem = h : this.waitingItem = this.endedItem = null),
            this.waitingItem = this.updateItem(this.waitingItem),
            this.endedItem = this.updateItem(this.endedItem);
            const m = this.bufferingItem;
            if (m && (f = this.updateItem(m, this.bufferedPos),
            this.itemsMatch(m, f) ? this.bufferingItem = f : m.event && (this.bufferingItem = this.playingItem,
            this.clearInterstitial(m.event, null))),
            n.forEach(p => {
                p.assetList.forEach(x => {
                    this.clearAssetPlayer(x.identifier, null)
                }
                )
            }
            ),
            this.playerQueue.forEach(p => {
                if (p.interstitial.appendInPlace) {
                    const x = p.assetItem.timelineStart
                      , y = p.timelineOffset - x;
                    if (y)
                        try {
                            p.timelineOffset = x
                        } catch (v) {
                            Math.abs(y) > gr && this.warn(`${v} ("${p.assetId}" ${p.timelineOffset}->${x})`)
                        }
                }
            }
            ),
            d || r) {
                if (this.hls.trigger(S.INTERSTITIALS_UPDATED, {
                    events: o.slice(0),
                    schedule: l.slice(0),
                    durations: c,
                    removedIds: u
                }),
                this.isInterstitial(a) && u.includes(a.event.identifier)) {
                    this.warn(`Interstitial "${a.event.identifier}" removed while playing`),
                    this.primaryFallback(a.event);
                    return
                }
                a && this.trimInPlace(h, a),
                m && f !== h && this.trimInPlace(f, m),
                this.checkBuffer()
            }
        }
        ,
        this.hls = e,
        this.HlsPlayerClass = t,
        this.assetListLoader = new PI(e),
        this.schedule = new DI(this.onScheduleUpdate,e.logger),
        this.registerListeners()
    }
    registerListeners() {
        const e = this.hls;
        e && (e.on(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.on(S.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.on(S.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this),
        e.on(S.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
        e.on(S.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this),
        e.on(S.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this),
        e.on(S.ASSET_LIST_LOADED, this.onAssetListLoaded, this),
        e.on(S.BUFFER_APPENDED, this.onBufferAppended, this),
        e.on(S.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.on(S.BUFFERED_TO_END, this.onBufferedToEnd, this),
        e.on(S.MEDIA_ENDED, this.onMediaEnded, this),
        e.on(S.ERROR, this.onError, this),
        e.on(S.DESTROYING, this.onDestroying, this))
    }
    unregisterListeners() {
        const e = this.hls;
        e && (e.off(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.off(S.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.off(S.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this),
        e.off(S.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
        e.off(S.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this),
        e.off(S.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this),
        e.off(S.ASSET_LIST_LOADED, this.onAssetListLoaded, this),
        e.off(S.BUFFER_CODECS, this.onBufferCodecs, this),
        e.off(S.BUFFER_APPENDED, this.onBufferAppended, this),
        e.off(S.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.off(S.BUFFERED_TO_END, this.onBufferedToEnd, this),
        e.off(S.MEDIA_ENDED, this.onMediaEnded, this),
        e.off(S.ERROR, this.onError, this),
        e.off(S.DESTROYING, this.onDestroying, this))
    }
    startLoad() {
        this.resumeBuffering()
    }
    stopLoad() {
        this.pauseBuffering()
    }
    resumeBuffering() {
        var e;
        (e = this.getBufferingPlayer()) == null || e.resumeBuffering()
    }
    pauseBuffering() {
        var e;
        (e = this.getBufferingPlayer()) == null || e.pauseBuffering()
    }
    destroy() {
        this.unregisterListeners(),
        this.stopLoad(),
        this.assetListLoader && this.assetListLoader.destroy(),
        this.emptyPlayerQueue(),
        this.clearScheduleState(),
        this.schedule && this.schedule.destroy(),
        this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.schedule = this.manager = null,
        this.hls = this.HlsPlayerClass = this.log = null,
        this.assetListLoader = null,
        this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null,
        this.onScheduleUpdate = null
    }
    onDestroying() {
        const e = this.primaryMedia || this.media;
        e && this.removeMediaListeners(e)
    }
    removeMediaListeners(e) {
        yt(e, "play", this.onPlay),
        yt(e, "pause", this.onPause),
        yt(e, "seeking", this.onSeeking),
        yt(e, "timeupdate", this.onTimeupdate)
    }
    onMediaAttaching(e, t) {
        const n = this.media = t.media;
        lt(n, "seeking", this.onSeeking),
        lt(n, "timeupdate", this.onTimeupdate),
        lt(n, "play", this.onPlay),
        lt(n, "pause", this.onPause)
    }
    onMediaAttached(e, t) {
        const n = this.effectivePlayingItem
          , r = this.detachedData;
        if (this.detachedData = null,
        n === null)
            this.checkStart();
        else if (!r) {
            this.clearScheduleState();
            const i = this.findItemIndex(n);
            this.setSchedulePosition(i)
        }
    }
    clearScheduleState() {
        this.log("clear schedule state"),
        this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null
    }
    onMediaDetaching(e, t) {
        const n = !!t.transferMedia
          , r = this.media;
        if (this.media = null,
        !n && (r && this.removeMediaListeners(r),
        this.detachedData)) {
            const i = this.getBufferingPlayer();
            i && (this.log(`Removing schedule state for detachedData and ${i}`),
            this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null,
            i.detachMedia()),
            this.shouldPlay = !1
        }
    }
    get interstitialsManager() {
        if (!this.hls)
            return null;
        if (this.manager)
            return this.manager;
        const e = this
          , t = () => e.bufferingItem || e.waitingItem
          , n = d => d && e.getAssetPlayer(d.identifier)
          , r = (d, h, f, m, p) => {
            if (d) {
                let x = d[h].start;
                const y = d.event;
                if (y) {
                    if (h === "playout" || y.timelineOccupancy !== wo.Point) {
                        const v = n(f);
                        (v == null ? void 0 : v.interstitial) === y && (x += v.assetItem.startOffset + v[p])
                    }
                } else {
                    const v = m === "bufferedPos" ? a() : e[m];
                    x += v - d.start
                }
                return x
            }
            return 0
        }
          , i = (d, h) => {
            var f;
            if (d !== 0 && h !== "primary" && (f = e.schedule) != null && f.length) {
                var m;
                const p = e.schedule.findItemIndexAtTime(d)
                  , x = (m = e.schedule.items) == null ? void 0 : m[p];
                if (x) {
                    const y = x[h].start - x.start;
                    return d + y
                }
            }
            return d
        }
          , a = () => {
            const d = e.bufferedPos;
            return d === Number.MAX_VALUE ? o("primary") : Math.max(d, 0)
        }
          , o = d => {
            var h, f;
            return (h = e.primaryDetails) != null && h.live ? e.primaryDetails.edge : ((f = e.schedule) == null ? void 0 : f.durations[d]) || 0
        }
          , l = (d, h) => {
            var f, m;
            const p = e.effectivePlayingItem;
            if (p != null && (f = p.event) != null && f.restrictions.skip || !e.schedule)
                return;
            e.log(`seek to ${d} "${h}"`);
            const x = e.effectivePlayingItem
              , y = e.schedule.findItemIndexAtTime(d, h)
              , v = (m = e.schedule.items) == null ? void 0 : m[y]
              , E = e.getBufferingPlayer()
              , T = E == null ? void 0 : E.interstitial
              , L = T == null ? void 0 : T.appendInPlace
              , R = x && e.itemsMatch(x, v);
            if (x && (L || R)) {
                const I = n(e.playingAsset)
                  , A = (I == null ? void 0 : I.media) || e.primaryMedia;
                if (A) {
                    const C = h === "primary" ? A.currentTime : r(x, h, e.playingAsset, "timelinePos", "currentTime")
                      , b = d - C
                      , O = (L ? C : A.currentTime) + b;
                    if (O >= 0 && (!I || L || O <= I.duration)) {
                        A.currentTime = O;
                        return
                    }
                }
            }
            if (v) {
                let I = d;
                if (h !== "primary") {
                    const C = v[h].start
                      , b = d - C;
                    I = v.start + b
                }
                const A = !e.isInterstitial(v);
                if ((!e.isInterstitial(x) || x.event.appendInPlace) && (A || v.event.appendInPlace)) {
                    const C = e.media || (L ? E == null ? void 0 : E.media : null);
                    C && (C.currentTime = I)
                } else if (x) {
                    const C = e.findItemIndex(x);
                    if (y > C) {
                        const O = e.schedule.findJumpRestrictedIndex(C + 1, y);
                        if (O > C) {
                            e.setSchedulePosition(O);
                            return
                        }
                    }
                    let b = 0;
                    if (A)
                        e.timelinePos = I,
                        e.checkBuffer();
                    else {
                        const O = v.event.assetList
                          , _ = d - (v[h] || v).start;
                        for (let $ = O.length; $--; ) {
                            const K = O[$];
                            if (K.duration && _ >= K.startOffset && _ < K.startOffset + K.duration) {
                                b = $;
                                break
                            }
                        }
                    }
                    e.setSchedulePosition(y, b)
                }
            }
        }
          , c = () => {
            const d = e.effectivePlayingItem;
            if (e.isInterstitial(d))
                return d;
            const h = t();
            return e.isInterstitial(h) ? h : null
        }
          , u = {
            get bufferedEnd() {
                const d = t()
                  , h = e.bufferingItem;
                if (h && h === d) {
                    var f;
                    return r(h, "playout", e.bufferingAsset, "bufferedPos", "bufferedEnd") - h.playout.start || ((f = e.bufferingAsset) == null ? void 0 : f.startOffset) || 0
                }
                return 0
            },
            get currentTime() {
                const d = c()
                  , h = e.effectivePlayingItem;
                return h && h === d ? r(h, "playout", e.effectivePlayingAsset, "timelinePos", "currentTime") - h.playout.start : 0
            },
            set currentTime(d) {
                const h = c()
                  , f = e.effectivePlayingItem;
                f && f === h && l(d + f.playout.start, "playout")
            },
            get duration() {
                const d = c();
                return d ? d.playout.end - d.playout.start : 0
            },
            get assetPlayers() {
                var d;
                const h = (d = c()) == null ? void 0 : d.event.assetList;
                return h ? h.map(f => e.getAssetPlayer(f.identifier)) : []
            },
            get playingIndex() {
                var d;
                const h = (d = c()) == null ? void 0 : d.event;
                return h && e.effectivePlayingAsset ? h.findAssetIndex(e.effectivePlayingAsset) : -1
            },
            get scheduleItem() {
                return c()
            }
        };
        return this.manager = {
            get events() {
                var d;
                return ((d = e.schedule) == null || (d = d.events) == null ? void 0 : d.slice(0)) || []
            },
            get schedule() {
                var d;
                return ((d = e.schedule) == null || (d = d.items) == null ? void 0 : d.slice(0)) || []
            },
            get interstitialPlayer() {
                return c() ? u : null
            },
            get playerQueue() {
                return e.playerQueue.slice(0)
            },
            get bufferingAsset() {
                return e.bufferingAsset
            },
            get bufferingItem() {
                return t()
            },
            get bufferingIndex() {
                const d = t();
                return e.findItemIndex(d)
            },
            get playingAsset() {
                return e.effectivePlayingAsset
            },
            get playingItem() {
                return e.effectivePlayingItem
            },
            get playingIndex() {
                const d = e.effectivePlayingItem;
                return e.findItemIndex(d)
            },
            primary: {
                get bufferedEnd() {
                    return a()
                },
                get currentTime() {
                    const d = e.timelinePos;
                    return d > 0 ? d : 0
                },
                set currentTime(d) {
                    l(d, "primary")
                },
                get duration() {
                    return o("primary")
                },
                get seekableStart() {
                    var d;
                    return ((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0
                }
            },
            integrated: {
                get bufferedEnd() {
                    return r(t(), "integrated", e.bufferingAsset, "bufferedPos", "bufferedEnd")
                },
                get currentTime() {
                    return r(e.effectivePlayingItem, "integrated", e.effectivePlayingAsset, "timelinePos", "currentTime")
                },
                set currentTime(d) {
                    l(d, "integrated")
                },
                get duration() {
                    return o("integrated")
                },
                get seekableStart() {
                    var d;
                    return i(((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0, "integrated")
                }
            },
            skip: () => {
                const d = e.effectivePlayingItem
                  , h = d == null ? void 0 : d.event;
                if (h && !h.restrictions.skip) {
                    const f = e.findItemIndex(d);
                    if (h.appendInPlace) {
                        const m = d.playout.start + d.event.duration;
                        l(m + .001, "playout")
                    } else
                        e.advanceAfterAssetEnded(h, f, 1 / 0)
                }
            }
        }
    }
    get effectivePlayingItem() {
        return this.waitingItem || this.playingItem || this.endedItem
    }
    get effectivePlayingAsset() {
        return this.playingAsset || this.endedAsset
    }
    get playingLastItem() {
        var e;
        const t = this.playingItem
          , n = (e = this.schedule) == null ? void 0 : e.items;
        return !this.playbackStarted || !t || !n ? !1 : this.findItemIndex(t) === n.length - 1
    }
    get playbackStarted() {
        return this.effectivePlayingItem !== null
    }
    get currentTime() {
        var e, t;
        if (this.mediaSelection === null)
            return;
        const n = this.waitingItem || this.playingItem;
        if (this.isInterstitial(n) && !n.event.appendInPlace)
            return;
        let r = this.media;
        !r && (e = this.bufferingItem) != null && (e = e.event) != null && e.appendInPlace && (r = this.primaryMedia);
        const i = (t = r) == null ? void 0 : t.currentTime;
        if (!(i === void 0 || !z(i)))
            return i
    }
    get primaryMedia() {
        var e;
        return this.media || ((e = this.detachedData) == null ? void 0 : e.media) || null
    }
    isInterstitial(e) {
        return !!(e != null && e.event)
    }
    retreiveMediaSource(e, t) {
        const n = this.getAssetPlayer(e);
        n && this.transferMediaFromPlayer(n, t)
    }
    transferMediaFromPlayer(e, t) {
        const n = e.interstitial.appendInPlace
          , r = e.media;
        if (n && r === this.primaryMedia) {
            if (this.bufferingAsset = null,
            (!t || this.isInterstitial(t) && !t.event.appendInPlace) && t && r) {
                this.detachedData = {
                    media: r
                };
                return
            }
            const i = e.transferMedia();
            this.log(`transfer MediaSource from ${e} ${Te(i)}`),
            this.detachedData = i
        } else
            t && r && (this.shouldPlay || (this.shouldPlay = !r.paused))
    }
    transferMediaTo(e, t) {
        var n, r;
        if (e.media === t)
            return;
        let i = null;
        const a = this.hls
          , o = e !== a
          , l = o && e.interstitial.appendInPlace
          , c = (n = this.detachedData) == null ? void 0 : n.mediaSource;
        let u;
        if (a.media)
            l && (i = a.transferMedia(),
            this.detachedData = i),
            u = "Primary";
        else if (c) {
            const m = this.getBufferingPlayer();
            m ? (i = m.transferMedia(),
            u = `${m}`) : u = "detached MediaSource"
        } else
            u = "detached media";
        if (!i) {
            if (c)
                i = this.detachedData,
                this.log(`using detachedData: MediaSource ${Te(i)}`);
            else if (!this.detachedData || a.media === t) {
                const m = this.playerQueue;
                m.length > 1 && m.forEach(p => {
                    if (o && p.interstitial.appendInPlace !== l) {
                        const x = p.interstitial;
                        this.clearInterstitial(p.interstitial, null),
                        x.appendInPlace = !1,
                        x.appendInPlace && this.warn(`Could not change append strategy for queued assets ${x}`)
                    }
                }
                ),
                this.hls.detachMedia(),
                this.detachedData = {
                    media: t
                }
            }
        }
        const d = i && "mediaSource"in i && ((r = i.mediaSource) == null ? void 0 : r.readyState) !== "closed"
          , h = d && i ? i : t;
        this.log(`${d ? "transfering MediaSource" : "attaching media"} to ${o ? e : "Primary"} from ${u} (media.currentTime: ${t.currentTime})`);
        const f = this.schedule;
        if (h === i && f) {
            const m = o && e.assetId === f.assetIdAtEnd;
            h.overrides = {
                duration: f.duration,
                endOfStream: !o || m,
                cueRemoval: !o
            }
        }
        e.attachMedia(h)
    }
    onInterstitialCueEnter() {
        this.onTimeupdate()
    }
    checkStart() {
        const e = this.schedule
          , t = e == null ? void 0 : e.events;
        if (!t || this.playbackDisabled || !this.media)
            return;
        this.bufferedPos === -1 && (this.bufferedPos = 0);
        const n = this.timelinePos
          , r = this.effectivePlayingItem;
        if (n === -1) {
            const i = this.hls.startPosition;
            if (this.log(pa("checkStart", i)),
            this.timelinePos = i,
            t.length && t[0].cue.pre) {
                const a = e.findEventIndex(t[0].identifier);
                this.setSchedulePosition(a)
            } else if (i >= 0 || !this.primaryLive) {
                const a = this.timelinePos = i > 0 ? i : 0
                  , o = e.findItemIndexAtTime(a);
                this.setSchedulePosition(o)
            }
        } else if (r && !this.playingItem) {
            const i = e.findItemIndex(r);
            this.setSchedulePosition(i)
        }
    }
    advanceAssetBuffering(e, t) {
        const n = e.event
          , r = n.findAssetIndex(t)
          , i = Gl(n, r);
        if (!n.isAssetPastPlayoutLimit(i))
            this.bufferedToEvent(e, i);
        else if (this.schedule) {
            var a;
            const o = (a = this.schedule.items) == null ? void 0 : a[this.findItemIndex(e) + 1];
            o && this.bufferedToItem(o)
        }
    }
    advanceAfterAssetEnded(e, t, n) {
        const r = Gl(e, n);
        if (e.isAssetPastPlayoutLimit(r)) {
            if (this.schedule) {
                const i = this.schedule.items;
                if (i) {
                    const a = t + 1
                      , o = i.length;
                    if (a >= o) {
                        this.setSchedulePosition(-1);
                        return
                    }
                    const l = e.resumeTime;
                    this.timelinePos < l && (this.log(pa("advanceAfterAssetEnded", l)),
                    this.timelinePos = l,
                    e.appendInPlace && this.advanceInPlace(l),
                    this.checkBuffer(this.bufferedPos < l)),
                    this.setSchedulePosition(a)
                }
            }
        } else {
            if (e.appendInPlace) {
                const i = e.assetList[r];
                i && this.advanceInPlace(i.timelineStart)
            }
            this.setSchedulePosition(t, r)
        }
    }
    setScheduleToAssetAtTime(e, t) {
        const n = this.schedule;
        if (!n)
            return;
        const r = t.parentIdentifier
          , i = n.getEvent(r);
        if (i) {
            const a = n.findEventIndex(r)
              , o = n.findAssetIndex(i, e);
            this.advanceAfterAssetEnded(i, a, o - 1)
        }
    }
    setSchedulePosition(e, t) {
        var n;
        const r = (n = this.schedule) == null ? void 0 : n.items;
        if (!r || this.playbackDisabled)
            return;
        const i = e >= 0 ? r[e] : null;
        this.log(`setSchedulePosition ${e}, ${t} (${i && Kt(i)}) pos: ${this.timelinePos}`);
        const a = this.waitingItem || this.playingItem
          , o = this.playingLastItem;
        if (this.isInterstitial(a)) {
            const u = a.event
              , d = this.playingAsset
              , h = d == null ? void 0 : d.identifier
              , f = h ? this.getAssetPlayer(h) : null;
            if (f && h && (!this.eventItemsMatch(a, i) || t !== void 0 && h !== u.assetList[t].identifier)) {
                var l;
                const m = u.findAssetIndex(d);
                if (this.log(`INTERSTITIAL_ASSET_ENDED ${m + 1}/${u.assetList.length} ${Hn(d)}`),
                this.endedAsset = d,
                this.playingAsset = null,
                this.hls.trigger(S.INTERSTITIAL_ASSET_ENDED, {
                    asset: d,
                    assetListIndex: m,
                    event: u,
                    schedule: r.slice(0),
                    scheduleIndex: e,
                    player: f
                }),
                a !== this.playingItem) {
                    this.itemsMatch(a, this.playingItem) && !this.playingAsset && this.advanceAfterAssetEnded(u, this.findItemIndex(this.playingItem), m);
                    return
                }
                this.retreiveMediaSource(h, i),
                f.media && !((l = this.detachedData) != null && l.mediaSource) && f.detachMedia()
            }
            if (!this.eventItemsMatch(a, i) && (this.endedItem = a,
            this.playingItem = null,
            this.log(`INTERSTITIAL_ENDED ${u} ${Kt(a)}`),
            u.hasPlayed = !0,
            this.hls.trigger(S.INTERSTITIAL_ENDED, {
                event: u,
                schedule: r.slice(0),
                scheduleIndex: e
            }),
            u.cue.once)) {
                var c;
                this.updateSchedule();
                const m = (c = this.schedule) == null ? void 0 : c.items;
                if (i && m) {
                    const p = this.findItemIndex(i);
                    this.advanceSchedule(p, m, t, a, o)
                }
                return
            }
        }
        this.advanceSchedule(e, r, t, a, o)
    }
    advanceSchedule(e, t, n, r, i) {
        const a = this.schedule;
        if (!a)
            return;
        const o = t[e] || null
          , l = this.primaryMedia
          , c = this.playerQueue;
        if (c.length && c.forEach(u => {
            const d = u.interstitial
              , h = a.findEventIndex(d.identifier);
            (h < e || h > e + 1) && this.clearInterstitial(d, o)
        }
        ),
        this.isInterstitial(o)) {
            this.timelinePos = Math.min(Math.max(this.timelinePos, o.start), o.end);
            const u = o.event;
            if (n === void 0) {
                n = a.findAssetIndex(u, this.timelinePos);
                const m = Gl(u, n - 1);
                if (u.isAssetPastPlayoutLimit(m) || u.appendInPlace && this.timelinePos === o.end) {
                    this.advanceAfterAssetEnded(u, e, n);
                    return
                }
                n = m
            }
            const d = this.waitingItem;
            this.assetsBuffered(o, l) || this.setBufferingItem(o);
            let h = this.preloadAssets(u, n);
            if (this.eventItemsMatch(o, d || r) || (this.waitingItem = o,
            this.log(`INTERSTITIAL_STARTED ${Kt(o)} ${u.appendInPlace ? "append in place" : ""}`),
            this.hls.trigger(S.INTERSTITIAL_STARTED, {
                event: u,
                schedule: t.slice(0),
                scheduleIndex: e
            })),
            !u.assetListLoaded) {
                this.log(`Waiting for ASSET-LIST to complete loading ${u}`);
                return
            }
            if (u.assetListLoader && (u.assetListLoader.destroy(),
            u.assetListLoader = void 0),
            !l) {
                this.log(`Waiting for attachMedia to start Interstitial ${u}`);
                return
            }
            this.waitingItem = this.endedItem = null,
            this.playingItem = o;
            const f = u.assetList[n];
            if (!f) {
                this.advanceAfterAssetEnded(u, e, n || 0);
                return
            }
            if (h || (h = this.getAssetPlayer(f.identifier)),
            h === null || h.destroyed) {
                const m = u.assetList.length;
                this.warn(`asset ${n + 1}/${m} player destroyed ${u}`),
                h = this.createAssetPlayer(u, f, n),
                h.loadSource()
            }
            if (!this.eventItemsMatch(o, this.bufferingItem) && u.appendInPlace && this.isAssetBuffered(f))
                return;
            this.startAssetPlayer(h, n, t, e, l),
            this.shouldPlay && em(h.media)
        } else
            o ? (this.resumePrimary(o, e, r),
            this.shouldPlay && em(this.hls.media)) : i && this.isInterstitial(r) && (this.endedItem = null,
            this.playingItem = r,
            r.event.appendInPlace || this.attachPrimary(a.durations.primary, null))
    }
    get playbackDisabled() {
        return this.hls.config.enableInterstitialPlayback === !1
    }
    get primaryDetails() {
        var e;
        return (e = this.mediaSelection) == null ? void 0 : e.main.details
    }
    get primaryLive() {
        var e;
        return !!((e = this.primaryDetails) != null && e.live)
    }
    resumePrimary(e, t, n) {
        var r, i;
        if (this.playingItem = e,
        this.playingAsset = this.endedAsset = null,
        this.waitingItem = this.endedItem = null,
        this.bufferedToItem(e),
        this.log(`resuming ${Kt(e)}`),
        !((r = this.detachedData) != null && r.mediaSource)) {
            let o = this.timelinePos;
            (o < e.start || o >= e.end) && (o = this.getPrimaryResumption(e, t),
            this.log(pa("resumePrimary", o)),
            this.timelinePos = o),
            this.attachPrimary(o, e)
        }
        if (!n)
            return;
        const a = (i = this.schedule) == null ? void 0 : i.items;
        a && (this.log(`INTERSTITIALS_PRIMARY_RESUMED ${Kt(e)}`),
        this.hls.trigger(S.INTERSTITIALS_PRIMARY_RESUMED, {
            schedule: a.slice(0),
            scheduleIndex: t
        }),
        this.checkBuffer())
    }
    getPrimaryResumption(e, t) {
        const n = e.start;
        if (this.primaryLive) {
            const r = this.primaryDetails;
            if (t === 0)
                return this.hls.startPosition;
            if (r && (n < r.fragmentStart || n > r.edge))
                return this.hls.liveSyncPosition || -1
        }
        return n
    }
    isAssetBuffered(e) {
        const t = this.getAssetPlayer(e.identifier);
        return t != null && t.hls ? t.hls.bufferedToEnd : ie.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 >= e.timelineStart + (e.duration || 0)
    }
    attachPrimary(e, t, n) {
        t ? this.setBufferingItem(t) : this.bufferingItem = this.playingItem,
        this.bufferingAsset = null;
        const r = this.primaryMedia;
        if (!r)
            return;
        const i = this.hls;
        i.media ? this.checkBuffer() : (this.transferMediaTo(i, r),
        n && this.startLoadingPrimaryAt(e, n)),
        n || (this.log(pa("attachPrimary", e)),
        this.timelinePos = e,
        this.startLoadingPrimaryAt(e, n))
    }
    startLoadingPrimaryAt(e, t) {
        var n;
        const r = this.hls;
        !r.loadingEnabled || !r.media || Math.abs((((n = r.mainForwardBufferInfo) == null ? void 0 : n.start) || r.media.currentTime) - e) > .5 ? r.startLoad(e, t) : r.bufferingEnabled || r.resumeBuffering()
    }
    onManifestLoading() {
        var e;
        this.stopLoad(),
        (e = this.schedule) == null || e.reset(),
        this.emptyPlayerQueue(),
        this.clearScheduleState(),
        this.shouldPlay = !1,
        this.bufferedPos = this.timelinePos = -1,
        this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null,
        this.hls.off(S.BUFFER_CODECS, this.onBufferCodecs, this),
        this.hls.on(S.BUFFER_CODECS, this.onBufferCodecs, this)
    }
    onLevelUpdated(e, t) {
        if (t.level === -1 || !this.schedule)
            return;
        const n = this.hls.levels[t.level]
          , r = pe(pe({}, this.mediaSelection || this.altSelection), {}, {
            main: n
        });
        this.mediaSelection = r,
        this.schedule.parseInterstitialDateRanges(r, this.hls.config.interstitialAppendInPlace),
        !this.effectivePlayingItem && this.schedule.items && this.checkStart()
    }
    onAudioTrackUpdated(e, t) {
        const n = this.hls.audioTracks[t.id]
          , r = this.mediaSelection;
        if (!r) {
            this.altSelection = pe(pe({}, this.altSelection), {}, {
                audio: n
            });
            return
        }
        const i = pe(pe({}, r), {}, {
            audio: n
        });
        this.mediaSelection = i
    }
    onSubtitleTrackUpdated(e, t) {
        const n = this.hls.subtitleTracks[t.id]
          , r = this.mediaSelection;
        if (!r) {
            this.altSelection = pe(pe({}, this.altSelection), {}, {
                subtitles: n
            });
            return
        }
        const i = pe(pe({}, r), {}, {
            subtitles: n
        });
        this.mediaSelection = i
    }
    onAudioTrackSwitching(e, t) {
        const n = df(t);
        this.playerQueue.forEach( ({hls: r}) => r && (r.setAudioOption(t) || r.setAudioOption(n)))
    }
    onSubtitleTrackSwitch(e, t) {
        const n = df(t);
        this.playerQueue.forEach( ({hls: r}) => r && (r.setSubtitleOption(t) || t.id !== -1 && r.setSubtitleOption(n)))
    }
    onBufferCodecs(e, t) {
        const n = t.tracks;
        n && (this.requiredTracks = n)
    }
    onBufferAppended(e, t) {
        this.checkBuffer()
    }
    onBufferFlushed(e, t) {
        const n = this.playingItem;
        if (n && !this.itemsMatch(n, this.bufferingItem) && !this.isInterstitial(n)) {
            const r = this.timelinePos;
            this.bufferedPos = r,
            this.checkBuffer()
        }
    }
    onBufferedToEnd(e) {
        if (!this.schedule)
            return;
        const t = this.schedule.events;
        if (this.bufferedPos < Number.MAX_VALUE && t) {
            for (let r = 0; r < t.length; r++) {
                const i = t[r];
                if (i.cue.post) {
                    var n;
                    const a = this.schedule.findEventIndex(i.identifier)
                      , o = (n = this.schedule.items) == null ? void 0 : n[a];
                    this.isInterstitial(o) && this.eventItemsMatch(o, this.bufferingItem) && this.bufferedToItem(o, 0);
                    break
                }
            }
            this.bufferedPos = Number.MAX_VALUE
        }
    }
    onMediaEnded(e) {
        const t = this.playingItem;
        if (!this.playingLastItem && t) {
            const n = this.findItemIndex(t);
            this.setSchedulePosition(n + 1)
        } else
            this.shouldPlay = !1
    }
    updateItem(e, t) {
        var n;
        const r = (n = this.schedule) == null ? void 0 : n.items;
        if (e && r) {
            const i = this.findItemIndex(e, t);
            return r[i] || null
        }
        return null
    }
    trimInPlace(e, t) {
        if (this.isInterstitial(e) && e.event.appendInPlace && t.end - e.end > .25) {
            e.event.assetList.forEach( (i, a) => {
                e.event.isAssetPastPlayoutLimit(a) && this.clearAssetPlayer(i.identifier, null)
            }
            );
            const n = e.end + .25
              , r = ie.bufferInfo(this.primaryMedia, n, 0);
            (r.end > n || (r.nextStart || 0) > n) && (this.log(`trim buffered interstitial ${Kt(e)} (was ${Kt(t)})`),
            this.attachPrimary(n, null, !0),
            this.flushFrontBuffer(n))
        }
    }
    itemsMatch(e, t) {
        return !!t && (e === t || e.event && t.event && this.eventItemsMatch(e, t) || !e.event && !t.event && this.findItemIndex(e) === this.findItemIndex(t))
    }
    eventItemsMatch(e, t) {
        var n;
        return !!t && (e === t || e.event.identifier === ((n = t.event) == null ? void 0 : n.identifier))
    }
    findItemIndex(e, t) {
        return e && this.schedule ? this.schedule.findItemIndex(e, t) : -1
    }
    updateSchedule(e=!1) {
        var t;
        const n = this.mediaSelection;
        n && ((t = this.schedule) == null || t.updateSchedule(n, [], e))
    }
    checkBuffer(e) {
        var t;
        const n = (t = this.schedule) == null ? void 0 : t.items;
        if (!n)
            return;
        const r = ie.bufferInfo(this.primaryMedia, this.timelinePos, 0);
        e && (this.bufferedPos = this.timelinePos),
        e || (e = r.len < 1),
        this.updateBufferedPos(r.end, n, e)
    }
    updateBufferedPos(e, t, n) {
        const r = this.schedule
          , i = this.bufferingItem;
        if (this.bufferedPos > e || !r)
            return;
        if (t.length === 1 && this.itemsMatch(t[0], i)) {
            this.bufferedPos = e;
            return
        }
        const a = this.playingItem
          , o = this.findItemIndex(a);
        let l = r.findItemIndexAtTime(e);
        if (this.bufferedPos < e) {
            var c;
            const u = this.findItemIndex(i)
              , d = Math.min(u + 1, t.length - 1)
              , h = t[d];
            if ((l === -1 && i && e >= i.end || (c = h.event) != null && c.appendInPlace && e + .01 >= h.start) && (l = d),
            this.isInterstitial(i)) {
                const f = i.event;
                if (d - o > 1 && f.appendInPlace === !1 || f.assetList.length === 0 && f.assetListLoader)
                    return
            }
            if (this.bufferedPos = e,
            l > u && l > o)
                this.bufferedToItem(h);
            else {
                const f = this.primaryDetails;
                this.primaryLive && f && e > f.edge - f.targetduration && h.start < f.edge + this.hls.config.interstitialLiveLookAhead && this.isInterstitial(h) && this.preloadAssets(h.event, 0)
            }
        } else
            n && a && !this.itemsMatch(a, i) && (l === o ? this.bufferedToItem(a) : l === o + 1 && this.bufferedToItem(t[l]))
    }
    assetsBuffered(e, t) {
        return e.event.assetList.length === 0 ? !1 : !e.event.assetList.some(r => {
            const i = this.getAssetPlayer(r.identifier);
            return !(i != null && i.bufferedInPlaceToEnd(t))
        }
        )
    }
    setBufferingItem(e) {
        const t = this.bufferingItem
          , n = this.schedule;
        if (!this.itemsMatch(e, t) && n) {
            const {items: r, events: i} = n;
            if (!r || !i)
                return t;
            const a = this.isInterstitial(e)
              , o = this.getBufferingPlayer();
            this.bufferingItem = e,
            this.bufferedPos = Math.max(e.start, Math.min(e.end, this.timelinePos));
            const l = o ? o.remaining : t ? t.end - this.timelinePos : 0;
            if (this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${Kt(e)}` + (t ? ` (${l.toFixed(2)} remaining)` : "")),
            !this.playbackDisabled)
                if (a) {
                    const c = n.findAssetIndex(e.event, this.bufferedPos);
                    e.event.assetList.forEach( (u, d) => {
                        const h = this.getAssetPlayer(u.identifier);
                        h && (d === c && h.loadSource(),
                        h.resumeBuffering())
                    }
                    )
                } else
                    this.hls.resumeBuffering(),
                    this.playerQueue.forEach(c => c.pauseBuffering());
            this.hls.trigger(S.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {
                events: i.slice(0),
                schedule: r.slice(0),
                bufferingIndex: this.findItemIndex(e),
                playingIndex: this.findItemIndex(this.playingItem)
            })
        } else
            this.bufferingItem !== e && (this.bufferingItem = e);
        return t
    }
    bufferedToItem(e, t=0) {
        const n = this.setBufferingItem(e);
        if (!this.playbackDisabled) {
            if (this.isInterstitial(e))
                this.bufferedToEvent(e, t);
            else if (n !== null) {
                this.bufferingAsset = null;
                const r = this.detachedData;
                r ? r.mediaSource ? this.attachPrimary(e.start, e, !0) : this.preloadPrimary(e) : this.preloadPrimary(e)
            }
        }
    }
    preloadPrimary(e) {
        const t = this.findItemIndex(e)
          , n = this.getPrimaryResumption(e, t);
        this.startLoadingPrimaryAt(n)
    }
    bufferedToEvent(e, t) {
        const n = e.event
          , r = n.assetList.length === 0 && !n.assetListLoader
          , i = n.cue.once;
        if (r || !i) {
            const a = this.preloadAssets(n, t);
            if (a != null && a.interstitial.appendInPlace) {
                const o = this.primaryMedia;
                o && this.bufferAssetPlayer(a, o)
            }
        }
    }
    preloadAssets(e, t) {
        const n = e.assetUrl
          , r = e.assetList.length
          , i = r === 0 && !e.assetListLoader
          , a = e.cue.once;
        if (i) {
            const l = e.timelineStart;
            if (e.appendInPlace) {
                var o;
                const h = this.playingItem;
                !this.isInterstitial(h) && (h == null || (o = h.nextEvent) == null ? void 0 : o.identifier) === e.identifier && this.flushFrontBuffer(l + .25)
            }
            let c, u = 0;
            if (!this.playingItem && this.primaryLive && (u = this.hls.startPosition,
            u === -1 && (u = this.hls.liveSyncPosition || 0)),
            u && !(e.cue.pre || e.cue.post)) {
                const h = u - l;
                h > 0 && (c = Math.round(h * 1e3) / 1e3)
            }
            if (this.log(`Load interstitial asset ${t + 1}/${n ? 1 : r} ${e}${c ? ` live-start: ${u} start-offset: ${c}` : ""}`),
            n)
                return this.createAsset(e, 0, 0, l, e.duration, n);
            const d = this.assetListLoader.loadAssetList(e, c);
            d && (e.assetListLoader = d)
        } else if (!a && r) {
            for (let c = t; c < r; c++) {
                const u = e.assetList[c]
                  , d = this.getAssetPlayerQueueIndex(u.identifier);
                (d === -1 || this.playerQueue[d].destroyed) && !u.error && this.createAssetPlayer(e, u, c)
            }
            const l = e.assetList[t];
            if (l) {
                const c = this.getAssetPlayer(l.identifier);
                return c && c.loadSource(),
                c
            }
        }
        return null
    }
    flushFrontBuffer(e) {
        const t = this.requiredTracks;
        if (!t)
            return;
        this.log(`Removing front buffer starting at ${e}`),
        Object.keys(t).forEach(r => {
            this.hls.trigger(S.BUFFER_FLUSHING, {
                startOffset: e,
                endOffset: 1 / 0,
                type: r
            })
        }
        )
    }
    getAssetPlayerQueueIndex(e) {
        const t = this.playerQueue;
        for (let n = 0; n < t.length; n++)
            if (e === t[n].assetId)
                return n;
        return -1
    }
    getAssetPlayer(e) {
        const t = this.getAssetPlayerQueueIndex(e);
        return this.playerQueue[t] || null
    }
    getBufferingPlayer() {
        const {playerQueue: e, primaryMedia: t} = this;
        if (t) {
            for (let n = 0; n < e.length; n++)
                if (e[n].media === t)
                    return e[n]
        }
        return null
    }
    createAsset(e, t, n, r, i, a) {
        const o = {
            parentIdentifier: e.identifier,
            identifier: wI(e, a, t),
            duration: i,
            startOffset: n,
            timelineStart: r,
            uri: a
        };
        return this.createAssetPlayer(e, o, t)
    }
    createAssetPlayer(e, t, n) {
        const r = this.hls
          , i = r.userConfig;
        let a = i.videoPreference;
        const o = r.loadLevelObj || r.levels[r.currentLevel];
        (a || o) && (a = ye({}, a),
        o.videoCodec && (a.videoCodec = o.videoCodec),
        o.videoRange && (a.allowedVideoRanges = [o.videoRange]));
        const l = r.audioTracks[r.audioTrack]
          , c = r.subtitleTracks[r.subtitleTrack];
        let u = 0;
        if (this.primaryLive || e.appendInPlace) {
            const T = this.timelinePos - t.timelineStart;
            if (T > 1) {
                const L = t.duration;
                L && T < L && (u = T)
            }
        }
        const d = t.identifier
          , h = pe(pe({}, i), {}, {
            maxMaxBufferLength: Math.min(180, r.config.maxMaxBufferLength),
            autoStartLoad: !0,
            startFragPrefetch: !0,
            primarySessionId: r.sessionId,
            assetPlayerId: d,
            abrEwmaDefaultEstimate: r.bandwidthEstimate,
            interstitialsController: void 0,
            startPosition: u,
            liveDurationInfinity: !1,
            testBandwidth: !1,
            videoPreference: a,
            audioPreference: l || i.audioPreference,
            subtitlePreference: c || i.subtitlePreference
        });
        e.appendInPlace && (e.appendInPlaceStarted = !0,
        t.timelineStart && (h.timelineOffset = t.timelineStart));
        const f = h.cmcd;
        f != null && f.sessionId && f.contentId && (h.cmcd = ye({}, f, {
            contentId: ii(t.uri)
        })),
        this.getAssetPlayer(d) && this.warn(`Duplicate date range identifier ${e} and asset ${d}`);
        const m = new _I(this.HlsPlayerClass,h,e,t);
        this.playerQueue.push(m),
        e.assetList[n] = t;
        let p = !0;
        const x = T => {
            if (T.live) {
                var L;
                const A = new Error(`Interstitials MUST be VOD assets ${e}`)
                  , C = {
                    fatal: !0,
                    type: q.OTHER_ERROR,
                    details: N.INTERSTITIAL_ASSET_ITEM_ERROR,
                    error: A
                }
                  , b = ((L = this.schedule) == null ? void 0 : L.findEventIndex(e.identifier)) || -1;
                this.handleAssetItemError(C, e, b, n, A.message);
                return
            }
            const R = T.edge - T.fragmentStart
              , I = t.duration;
            (p || I === null || R > I) && (p = !1,
            this.log(`Interstitial asset "${d}" duration change ${I} > ${R}`),
            t.duration = R,
            this.updateSchedule())
        }
        ;
        m.on(S.LEVEL_UPDATED, (T, {details: L}) => x(L)),
        m.on(S.LEVEL_PTS_UPDATED, (T, {details: L}) => x(L)),
        m.on(S.EVENT_CUE_ENTER, () => this.onInterstitialCueEnter());
        const y = (T, L) => {
            const R = this.getAssetPlayer(d);
            if (R && L.tracks) {
                R.off(S.BUFFER_CODECS, y),
                R.tracks = L.tracks;
                const I = this.primaryMedia;
                this.bufferingAsset === R.assetItem && I && !R.media && this.bufferAssetPlayer(R, I)
            }
        }
        ;
        m.on(S.BUFFER_CODECS, y);
        const v = () => {
            var T;
            const L = this.getAssetPlayer(d);
            if (this.log(`buffered to end of asset ${L}`),
            !L || !this.schedule)
                return;
            const R = this.schedule.findEventIndex(e.identifier)
              , I = (T = this.schedule.items) == null ? void 0 : T[R];
            this.isInterstitial(I) && this.advanceAssetBuffering(I, t)
        }
        ;
        m.on(S.BUFFERED_TO_END, v);
        const E = T => () => {
            if (!this.getAssetPlayer(d) || !this.schedule)
                return;
            this.shouldPlay = !0;
            const R = this.schedule.findEventIndex(e.identifier);
            this.advanceAfterAssetEnded(e, R, T)
        }
        ;
        return m.once(S.MEDIA_ENDED, E(n)),
        m.once(S.PLAYOUT_LIMIT_REACHED, E(1 / 0)),
        m.on(S.ERROR, (T, L) => {
            if (!this.schedule)
                return;
            const R = this.getAssetPlayer(d);
            if (L.details === N.BUFFER_STALLED_ERROR) {
                if (R != null && R.appendInPlace) {
                    this.handleInPlaceStall(e);
                    return
                }
                this.onTimeupdate(),
                this.checkBuffer(!0);
                return
            }
            this.handleAssetItemError(L, e, this.schedule.findEventIndex(e.identifier), n, `Asset player error ${L.error} ${e}`)
        }
        ),
        m.on(S.DESTROYING, () => {
            if (!this.getAssetPlayer(d) || !this.schedule)
                return;
            const L = new Error(`Asset player destroyed unexpectedly ${d}`)
              , R = {
                fatal: !0,
                type: q.OTHER_ERROR,
                details: N.INTERSTITIAL_ASSET_ITEM_ERROR,
                error: L
            };
            this.handleAssetItemError(R, e, this.schedule.findEventIndex(e.identifier), n, L.message)
        }
        ),
        this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${Hn(t)}`),
        this.hls.trigger(S.INTERSTITIAL_ASSET_PLAYER_CREATED, {
            asset: t,
            assetListIndex: n,
            event: e,
            player: m
        }),
        m
    }
    clearInterstitial(e, t) {
        e.assetList.forEach(n => {
            this.clearAssetPlayer(n.identifier, t)
        }
        ),
        e.reset()
    }
    resetAssetPlayer(e) {
        const t = this.getAssetPlayerQueueIndex(e);
        if (t !== -1) {
            this.log(`reset asset player "${e}" after error`);
            const n = this.playerQueue[t];
            this.transferMediaFromPlayer(n, null),
            n.resetDetails()
        }
    }
    clearAssetPlayer(e, t) {
        const n = this.getAssetPlayerQueueIndex(e);
        if (n !== -1) {
            const r = this.playerQueue[n];
            this.log(`clear ${r} toSegment: ${t && Kt(t)}`),
            this.transferMediaFromPlayer(r, t),
            this.playerQueue.splice(n, 1),
            r.destroy()
        }
    }
    emptyPlayerQueue() {
        let e;
        for (; e = this.playerQueue.pop(); )
            e.destroy();
        this.playerQueue = []
    }
    startAssetPlayer(e, t, n, r, i) {
        const {interstitial: a, assetItem: o, assetId: l} = e
          , c = a.assetList.length
          , u = this.playingAsset;
        this.endedAsset = null,
        this.playingAsset = o,
        (!u || u.identifier !== l) && (u && (this.clearAssetPlayer(u.identifier, n[r]),
        delete u.error),
        this.log(`INTERSTITIAL_ASSET_STARTED ${t + 1}/${c} ${Hn(o)}`),
        this.hls.trigger(S.INTERSTITIAL_ASSET_STARTED, {
            asset: o,
            assetListIndex: t,
            event: a,
            schedule: n.slice(0),
            scheduleIndex: r,
            player: e
        })),
        this.bufferAssetPlayer(e, i)
    }
    bufferAssetPlayer(e, t) {
        var n, r;
        if (!this.schedule)
            return;
        const {interstitial: i, assetItem: a} = e
          , o = this.schedule.findEventIndex(i.identifier)
          , l = (n = this.schedule.items) == null ? void 0 : n[o];
        if (!l)
            return;
        e.loadSource(),
        this.setBufferingItem(l),
        this.bufferingAsset = a;
        const c = this.getBufferingPlayer();
        if (c === e)
            return;
        const u = i.appendInPlace;
        if (u && (c == null ? void 0 : c.interstitial.appendInPlace) === !1)
            return;
        const d = (c == null ? void 0 : c.tracks) || ((r = this.detachedData) == null ? void 0 : r.tracks) || this.requiredTracks;
        if (u && a !== this.playingAsset) {
            if (!e.tracks) {
                this.log(`Waiting for track info before buffering ${e}`);
                return
            }
            if (d && !zp(d, e.tracks)) {
                const h = new Error(`Asset ${Hn(a)} SourceBuffer tracks ('${Object.keys(e.tracks)}') are not compatible with primary content tracks ('${Object.keys(d)}')`)
                  , f = {
                    fatal: !0,
                    type: q.OTHER_ERROR,
                    details: N.INTERSTITIAL_ASSET_ITEM_ERROR,
                    error: h
                }
                  , m = i.findAssetIndex(a);
                this.handleAssetItemError(f, i, o, m, h.message);
                return
            }
        }
        this.transferMediaTo(e, t)
    }
    handleInPlaceStall(e) {
        const t = this.schedule
          , n = this.primaryMedia;
        if (!t || !n)
            return;
        const r = n.currentTime
          , i = t.findAssetIndex(e, r)
          , a = e.assetList[i];
        if (a) {
            const o = this.getAssetPlayer(a.identifier);
            if (o) {
                const l = o.currentTime || r - a.timelineStart
                  , c = o.duration - l;
                if (this.warn(`Stalled at ${l} of ${l + c} in ${o} ${e} (media.currentTime: ${r})`),
                l && (c / n.playbackRate < .5 || o.bufferedInPlaceToEnd(n)) && o.hls) {
                    const u = t.findEventIndex(e.identifier);
                    this.advanceAfterAssetEnded(e, u, i)
                }
            }
        }
    }
    advanceInPlace(e) {
        const t = this.primaryMedia;
        t && t.currentTime < e && (t.currentTime = e)
    }
    handleAssetItemError(e, t, n, r, i) {
        if (e.details === N.BUFFER_STALLED_ERROR)
            return;
        const a = t.assetList[r] || null;
        if (this.warn(`INTERSTITIAL_ASSET_ERROR ${a && Hn(a)} ${e.error}`),
        !this.schedule)
            return;
        const o = (a == null ? void 0 : a.identifier) || ""
          , l = this.getAssetPlayerQueueIndex(o)
          , c = this.playerQueue[l] || null
          , u = this.schedule.items
          , d = ye({}, e, {
            fatal: !1,
            errorAction: hr(!0),
            asset: a,
            assetListIndex: r,
            event: t,
            schedule: u,
            scheduleIndex: n,
            player: c
        });
        if (this.hls.trigger(S.INTERSTITIAL_ASSET_ERROR, d),
        !e.fatal)
            return;
        const h = this.playingAsset
          , f = this.bufferingAsset
          , m = new Error(i);
        if (a && (this.clearAssetPlayer(o, null),
        a.error = m),
        !t.assetList.some(p => !p.error))
            t.error = m;
        else
            for (let p = r; p < t.assetList.length; p++)
                this.resetAssetPlayer(t.assetList[p].identifier);
        this.updateSchedule(!0),
        t.error ? this.primaryFallback(t) : h && h.identifier === o ? this.advanceAfterAssetEnded(t, n, r) : f && f.identifier === o && this.isInterstitial(this.bufferingItem) && this.advanceAssetBuffering(this.bufferingItem, f)
    }
    primaryFallback(e) {
        const t = e.timelineStart
          , n = this.effectivePlayingItem;
        if (n) {
            this.log(`Fallback to primary from event "${e.identifier}" start: ${t} pos: ${this.timelinePos} playing: ${Kt(n)} error: ${e.error}`);
            let r = this.timelinePos;
            r === -1 && (r = this.hls.startPosition);
            const i = this.updateItem(n, r);
            if (this.itemsMatch(n, i) && this.clearInterstitial(e, null),
            e.appendInPlace && (this.attachPrimary(t, null),
            this.flushFrontBuffer(t)),
            !this.schedule)
                return;
            const a = this.schedule.findItemIndexAtTime(r);
            this.setSchedulePosition(a)
        } else
            this.checkStart()
    }
    onAssetListLoaded(e, t) {
        var n, r;
        const i = t.event
          , a = i.identifier
          , o = t.assetListResponse.ASSETS;
        if (!((n = this.schedule) != null && n.hasEvent(a)))
            return;
        const l = i.timelineStart
          , c = i.duration;
        let u = 0;
        o.forEach( (p, x) => {
            const y = parseFloat(p.DURATION);
            this.createAsset(i, x, u, l + u, y, p.URI),
            u += y
        }
        ),
        i.duration = u,
        this.log(`Loaded asset-list with duration: ${u} (was: ${c}) ${i}`);
        const d = this.waitingItem
          , h = (d == null ? void 0 : d.event.identifier) === a;
        this.updateSchedule();
        const f = (r = this.bufferingItem) == null ? void 0 : r.event;
        if (h) {
            var m;
            const p = this.schedule.findEventIndex(a)
              , x = (m = this.schedule.items) == null ? void 0 : m[p];
            if (x) {
                if (!this.playingItem && this.timelinePos > x.end && this.schedule.findItemIndexAtTime(this.timelinePos) !== p) {
                    i.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${i}`),
                    this.updateSchedule(!0),
                    this.primaryFallback(i);
                    return
                }
                this.setBufferingItem(x)
            }
            this.setSchedulePosition(p)
        } else if ((f == null ? void 0 : f.identifier) === a) {
            const p = i.assetList[0];
            if (p) {
                const x = this.getAssetPlayer(p.identifier);
                if (f.appendInPlace) {
                    const y = this.primaryMedia;
                    x && y && this.bufferAssetPlayer(x, y)
                } else
                    x && x.loadSource()
            }
        }
    }
    onError(e, t) {
        if (this.schedule)
            switch (t.details) {
            case N.ASSET_LIST_PARSING_ERROR:
            case N.ASSET_LIST_LOAD_ERROR:
            case N.ASSET_LIST_LOAD_TIMEOUT:
                {
                    const n = t.interstitial;
                    n && (this.updateSchedule(!0),
                    this.primaryFallback(n));
                    break
                }
            case N.BUFFER_STALLED_ERROR:
                {
                    const n = this.endedItem || this.waitingItem || this.playingItem;
                    if (this.isInterstitial(n) && n.event.appendInPlace) {
                        this.handleInPlaceStall(n.event);
                        return
                    }
                    this.log(`Primary player stall @${this.timelinePos} bufferedPos: ${this.bufferedPos}`),
                    this.onTimeupdate(),
                    this.checkBuffer(!0);
                    break
                }
            }
    }
}
const tm = 500;
class OI extends Sd {
    constructor(e, t, n) {
        super(e, t, n, "subtitle-stream-controller", X.SUBTITLE),
        this.currentTrackId = -1,
        this.tracksBuffered = [],
        this.mainDetails = null,
        this.registerListeners()
    }
    onHandlerDestroying() {
        this.unregisterListeners(),
        super.onHandlerDestroying(),
        this.mainDetails = null
    }
    registerListeners() {
        super.registerListeners();
        const {hls: e} = this;
        e.on(S.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(S.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.on(S.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
        e.on(S.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.on(S.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this),
        e.on(S.BUFFER_FLUSHING, this.onBufferFlushing, this)
    }
    unregisterListeners() {
        super.unregisterListeners();
        const {hls: e} = this;
        e.off(S.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(S.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.off(S.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this),
        e.off(S.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this),
        e.off(S.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this),
        e.off(S.BUFFER_FLUSHING, this.onBufferFlushing, this)
    }
    startLoad(e, t) {
        this.stopLoad(),
        this.state = U.IDLE,
        this.setInterval(tm),
        this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset,
        this.startPosition = t ? -1 : e,
        this.tick()
    }
    onManifestLoading() {
        super.onManifestLoading(),
        this.mainDetails = null
    }
    onMediaDetaching(e, t) {
        this.tracksBuffered = [],
        super.onMediaDetaching(e, t)
    }
    onLevelLoaded(e, t) {
        this.mainDetails = t.details
    }
    onSubtitleFragProcessed(e, t) {
        const {frag: n, success: r} = t;
        if (this.fragContextChanged(n) || (Fe(n) && (this.fragPrevious = n),
        this.state = U.IDLE),
        !r)
            return;
        const i = this.tracksBuffered[this.currentTrackId];
        if (!i)
            return;
        let a;
        const o = n.start;
        for (let c = 0; c < i.length; c++)
            if (o >= i[c].start && o <= i[c].end) {
                a = i[c];
                break
            }
        const l = n.start + n.duration;
        a ? a.end = l : (a = {
            start: o,
            end: l
        },
        i.push(a)),
        this.fragmentTracker.fragBuffered(n),
        this.fragBufferedComplete(n, null),
        this.media && this.tick()
    }
    onBufferFlushing(e, t) {
        const {startOffset: n, endOffset: r} = t;
        if (n === 0 && r !== Number.POSITIVE_INFINITY) {
            const i = r - 1;
            if (i <= 0)
                return;
            t.endOffsetSubtitles = Math.max(0, i),
            this.tracksBuffered.forEach(a => {
                for (let o = 0; o < a.length; ) {
                    if (a[o].end <= i) {
                        a.shift();
                        continue
                    } else if (a[o].start < i)
                        a[o].start = i;
                    else
                        break;
                    o++
                }
            }
            ),
            this.fragmentTracker.removeFragmentsInRange(n, i, X.SUBTITLE)
        }
    }
    onError(e, t) {
        const n = t.frag;
        (n == null ? void 0 : n.type) === X.SUBTITLE && (t.details === N.FRAG_GAP && this.fragmentTracker.fragBuffered(n, !0),
        this.fragCurrent && this.fragCurrent.abortRequests(),
        this.state !== U.STOPPED && (this.state = U.IDLE))
    }
    onSubtitleTracksUpdated(e, {subtitleTracks: t}) {
        if (this.levels && K0(this.levels, t)) {
            this.levels = t.map(n => new bi(n));
            return
        }
        this.tracksBuffered = [],
        this.levels = t.map(n => {
            const r = new bi(n);
            return this.tracksBuffered[r.id] = [],
            r
        }
        ),
        this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, X.SUBTITLE),
        this.fragPrevious = null,
        this.mediaBuffer = null
    }
    onSubtitleTrackSwitch(e, t) {
        var n;
        if (this.currentTrackId = t.id,
        !((n = this.levels) != null && n.length) || this.currentTrackId === -1) {
            this.clearInterval();
            return
        }
        const r = this.levels[this.currentTrackId];
        r != null && r.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null,
        r && this.state !== U.STOPPED && this.setInterval(tm)
    }
    onSubtitleTrackLoaded(e, t) {
        var n;
        const {currentTrackId: r, levels: i} = this
          , {details: a, id: o} = t;
        if (!i) {
            this.warn(`Subtitle tracks were reset while loading level ${o}`);
            return
        }
        const l = i[o];
        if (o >= i.length || !l)
            return;
        this.log(`Subtitle track ${o} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : ""},duration:${a.totalduration}`),
        this.mediaBuffer = this.mediaBufferTimeRanges;
        let c = 0;
        if (a.live || (n = l.details) != null && n.live) {
            if (a.deltaUpdateFailed)
                return;
            const d = this.mainDetails;
            if (!d) {
                this.startFragRequested = !1;
                return
            }
            const h = d.fragments[0];
            if (!l.details)
                a.hasProgramDateTime && d.hasProgramDateTime ? (bo(a, d),
                c = a.fragmentStart) : h && (c = h.start,
                tu(a, c));
            else {
                var u;
                c = this.alignPlaylists(a, l.details, (u = this.levelLastLoaded) == null ? void 0 : u.details),
                c === 0 && h && (c = h.start,
                tu(a, c))
            }
            d && !this.startFragRequested && this.setStartPosition(d, c)
        }
        l.details = a,
        this.levelLastLoaded = l,
        o === r && (this.hls.trigger(S.SUBTITLE_TRACK_UPDATED, {
            details: a,
            id: o,
            groupId: t.groupId
        }),
        this.tick(),
        a.live && !this.fragCurrent && this.media && this.state === U.IDLE && (Pn(null, a.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"),
        l.details = void 0)))
    }
    _handleFragmentLoadComplete(e) {
        const {frag: t, payload: n} = e
          , r = t.decryptdata
          , i = this.hls;
        if (!this.fragContextChanged(t) && n && n.byteLength > 0 && r != null && r.key && r.iv && fr(r.method)) {
            const a = performance.now();
            this.decrypter.decrypt(new Uint8Array(n), r.key.buffer, r.iv.buffer, vd(r.method)).catch(o => {
                throw i.trigger(S.ERROR, {
                    type: q.MEDIA_ERROR,
                    details: N.FRAG_DECRYPT_ERROR,
                    fatal: !1,
                    error: o,
                    reason: o.message,
                    frag: t
                }),
                o
            }
            ).then(o => {
                const l = performance.now();
                i.trigger(S.FRAG_DECRYPTED, {
                    frag: t,
                    payload: o,
                    stats: {
                        tstart: a,
                        tdecrypt: l
                    }
                })
            }
            ).catch(o => {
                this.warn(`${o.name}: ${o.message}`),
                this.state = U.IDLE
            }
            )
        }
    }
    doTick() {
        if (!this.media) {
            this.state = U.IDLE;
            return
        }
        if (this.state === U.IDLE) {
            const {currentTrackId: e, levels: t} = this
              , n = t == null ? void 0 : t[e];
            if (!n || !t.length || !n.details || this.waitForLive(n))
                return;
            const {config: r} = this
              , i = this.getLoadPosition()
              , a = ie.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], i, r.maxBufferHole)
              , {end: o, len: l} = a
              , c = n.details
              , u = this.hls.maxBufferLength + c.levelTargetDuration;
            if (l > u)
                return;
            const d = c.fragments
              , h = d.length
              , f = c.edge;
            let m = null;
            const p = this.fragPrevious;
            if (o < f) {
                const v = r.maxFragLookUpTolerance
                  , E = o > f - v ? 0 : v;
                m = Pn(p, d, Math.max(d[0].start, o), E),
                !m && p && p.start < d[0].start && (m = d[0])
            } else
                m = d[h - 1];
            if (m = this.filterReplacedPrimary(m, n.details),
            !m)
                return;
            const x = m.sn - c.startSN
              , y = d[x - 1];
            if (y && y.cc === m.cc && this.fragmentTracker.getState(y) === Ve.NOT_LOADED && (m = y),
            this.fragmentTracker.getState(m) === Ve.NOT_LOADED) {
                const v = this.mapToInitFragWhenRequired(m);
                v && this.loadFragment(v, n, o)
            }
        }
    }
    loadFragment(e, t, n) {
        Fe(e) ? super.loadFragment(e, t, n) : this._loadInitSegment(e, t)
    }
    get mediaBufferTimeRanges() {
        return new MI(this.tracksBuffered[this.currentTrackId] || [])
    }
}
class MI {
    constructor(e) {
        this.buffered = void 0;
        const t = (n, r, i) => {
            if (r = r >>> 0,
            r > i - 1)
                throw new DOMException(`Failed to execute '${n}' on 'TimeRanges': The index provided (${r}) is greater than the maximum bound (${i})`);
            return e[r][n]
        }
        ;
        this.buffered = {
            get length() {
                return e.length
            },
            end(n) {
                return t("end", n, e.length)
            },
            start(n) {
                return t("start", n, e.length)
            }
        }
    }
}
const FI = {
    42: 225,
    92: 233,
    94: 237,
    95: 243,
    96: 250,
    123: 231,
    124: 247,
    125: 209,
    126: 241,
    127: 9608,
    128: 174,
    129: 176,
    130: 189,
    131: 191,
    132: 8482,
    133: 162,
    134: 163,
    135: 9834,
    136: 224,
    137: 32,
    138: 232,
    139: 226,
    140: 234,
    141: 238,
    142: 244,
    143: 251,
    144: 193,
    145: 201,
    146: 211,
    147: 218,
    148: 220,
    149: 252,
    150: 8216,
    151: 161,
    152: 42,
    153: 8217,
    154: 9473,
    155: 169,
    156: 8480,
    157: 8226,
    158: 8220,
    159: 8221,
    160: 192,
    161: 194,
    162: 199,
    163: 200,
    164: 202,
    165: 203,
    166: 235,
    167: 206,
    168: 207,
    169: 239,
    170: 212,
    171: 217,
    172: 249,
    173: 219,
    174: 171,
    175: 187,
    176: 195,
    177: 227,
    178: 205,
    179: 204,
    180: 236,
    181: 210,
    182: 242,
    183: 213,
    184: 245,
    185: 123,
    186: 125,
    187: 92,
    188: 94,
    189: 95,
    190: 124,
    191: 8764,
    192: 196,
    193: 228,
    194: 214,
    195: 246,
    196: 223,
    197: 165,
    198: 164,
    199: 9475,
    200: 197,
    201: 229,
    202: 216,
    203: 248,
    204: 9487,
    205: 9491,
    206: 9495,
    207: 9499
}
  , oy = s => String.fromCharCode(FI[s] || s)
  , Yt = 15
  , Ss = 100
  , UI = {
    17: 1,
    18: 3,
    21: 5,
    22: 7,
    23: 9,
    16: 11,
    19: 12,
    20: 14
}
  , BI = {
    17: 2,
    18: 4,
    21: 6,
    22: 8,
    23: 10,
    19: 13,
    20: 15
}
  , $I = {
    25: 1,
    26: 3,
    29: 5,
    30: 7,
    31: 9,
    24: 11,
    27: 12,
    28: 14
}
  , jI = {
    25: 2,
    26: 4,
    29: 6,
    30: 8,
    31: 10,
    27: 13,
    28: 15
}
  , GI = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
class VI {
    constructor() {
        this.time = null,
        this.verboseLevel = 0
    }
    log(e, t) {
        if (this.verboseLevel >= e) {
            const n = typeof t == "function" ? t() : t;
            fe.log(`${this.time} [${e}] ${n}`)
        }
    }
}
const xn = function(e) {
    const t = [];
    for (let n = 0; n < e.length; n++)
        t.push(e[n].toString(16));
    return t
};
class ly {
    constructor() {
        this.foreground = "white",
        this.underline = !1,
        this.italics = !1,
        this.background = "black",
        this.flash = !1
    }
    reset() {
        this.foreground = "white",
        this.underline = !1,
        this.italics = !1,
        this.background = "black",
        this.flash = !1
    }
    setStyles(e) {
        const t = ["foreground", "underline", "italics", "background", "flash"];
        for (let n = 0; n < t.length; n++) {
            const r = t[n];
            e.hasOwnProperty(r) && (this[r] = e[r])
        }
    }
    isDefault() {
        return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash
    }
    equals(e) {
        return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash
    }
    copy(e) {
        this.foreground = e.foreground,
        this.underline = e.underline,
        this.italics = e.italics,
        this.background = e.background,
        this.flash = e.flash
    }
    toString() {
        return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
    }
}
class HI {
    constructor() {
        this.uchar = " ",
        this.penState = new ly
    }
    reset() {
        this.uchar = " ",
        this.penState.reset()
    }
    setChar(e, t) {
        this.uchar = e,
        this.penState.copy(t)
    }
    setPenState(e) {
        this.penState.copy(e)
    }
    equals(e) {
        return this.uchar === e.uchar && this.penState.equals(e.penState)
    }
    copy(e) {
        this.uchar = e.uchar,
        this.penState.copy(e.penState)
    }
    isEmpty() {
        return this.uchar === " " && this.penState.isDefault()
    }
}
class KI {
    constructor(e) {
        this.chars = [],
        this.pos = 0,
        this.currPenState = new ly,
        this.cueStartTime = null,
        this.logger = void 0;
        for (let t = 0; t < Ss; t++)
            this.chars.push(new HI);
        this.logger = e
    }
    equals(e) {
        for (let t = 0; t < Ss; t++)
            if (!this.chars[t].equals(e.chars[t]))
                return !1;
        return !0
    }
    copy(e) {
        for (let t = 0; t < Ss; t++)
            this.chars[t].copy(e.chars[t])
    }
    isEmpty() {
        let e = !0;
        for (let t = 0; t < Ss; t++)
            if (!this.chars[t].isEmpty()) {
                e = !1;
                break
            }
        return e
    }
    setCursor(e) {
        this.pos !== e && (this.pos = e),
        this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos),
        this.pos = 0) : this.pos > Ss && (this.logger.log(3, "Too large cursor position " + this.pos),
        this.pos = Ss)
    }
    moveCursor(e) {
        const t = this.pos + e;
        if (e > 1)
            for (let n = this.pos + 1; n < t + 1; n++)
                this.chars[n].setPenState(this.currPenState);
        this.setCursor(t)
    }
    backSpace() {
        this.moveCursor(-1),
        this.chars[this.pos].setChar(" ", this.currPenState)
    }
    insertChar(e) {
        e >= 144 && this.backSpace();
        const t = oy(e);
        if (this.pos >= Ss) {
            this.logger.log(0, () => "Cannot insert " + e.toString(16) + " (" + t + ") at position " + this.pos + ". Skipping it!");
            return
        }
        this.chars[this.pos].setChar(t, this.currPenState),
        this.moveCursor(1)
    }
    clearFromPos(e) {
        let t;
        for (t = e; t < Ss; t++)
            this.chars[t].reset()
    }
    clear() {
        this.clearFromPos(0),
        this.pos = 0,
        this.currPenState.reset()
    }
    clearToEndOfRow() {
        this.clearFromPos(this.pos)
    }
    getTextString() {
        const e = [];
        let t = !0;
        for (let n = 0; n < Ss; n++) {
            const r = this.chars[n].uchar;
            r !== " " && (t = !1),
            e.push(r)
        }
        return t ? "" : e.join("")
    }
    setPenStyles(e) {
        this.currPenState.setStyles(e),
        this.chars[this.pos].setPenState(this.currPenState)
    }
}
class Vl {
    constructor(e) {
        this.rows = [],
        this.currRow = Yt - 1,
        this.nrRollUpRows = null,
        this.lastOutputScreen = null,
        this.logger = void 0;
        for (let t = 0; t < Yt; t++)
            this.rows.push(new KI(e));
        this.logger = e
    }
    reset() {
        for (let e = 0; e < Yt; e++)
            this.rows[e].clear();
        this.currRow = Yt - 1
    }
    equals(e) {
        let t = !0;
        for (let n = 0; n < Yt; n++)
            if (!this.rows[n].equals(e.rows[n])) {
                t = !1;
                break
            }
        return t
    }
    copy(e) {
        for (let t = 0; t < Yt; t++)
            this.rows[t].copy(e.rows[t])
    }
    isEmpty() {
        let e = !0;
        for (let t = 0; t < Yt; t++)
            if (!this.rows[t].isEmpty()) {
                e = !1;
                break
            }
        return e
    }
    backSpace() {
        this.rows[this.currRow].backSpace()
    }
    clearToEndOfRow() {
        this.rows[this.currRow].clearToEndOfRow()
    }
    insertChar(e) {
        this.rows[this.currRow].insertChar(e)
    }
    setPen(e) {
        this.rows[this.currRow].setPenStyles(e)
    }
    moveCursor(e) {
        this.rows[this.currRow].moveCursor(e)
    }
    setCursor(e) {
        this.logger.log(2, "setCursor: " + e),
        this.rows[this.currRow].setCursor(e)
    }
    setPAC(e) {
        this.logger.log(2, () => "pacData = " + Te(e));
        let t = e.row - 1;
        if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1),
        this.nrRollUpRows && this.currRow !== t) {
            for (let o = 0; o < Yt; o++)
                this.rows[o].clear();
            const i = this.currRow + 1 - this.nrRollUpRows
              , a = this.lastOutputScreen;
            if (a) {
                const o = a.rows[i].cueStartTime
                  , l = this.logger.time;
                if (o !== null && l !== null && o < l)
                    for (let c = 0; c < this.nrRollUpRows; c++)
                        this.rows[t - this.nrRollUpRows + c + 1].copy(a.rows[i + c])
            }
        }
        this.currRow = t;
        const n = this.rows[this.currRow];
        if (e.indent !== null) {
            const i = e.indent
              , a = Math.max(i - 1, 0);
            n.setCursor(e.indent),
            e.color = n.chars[a].penState.foreground
        }
        const r = {
            foreground: e.color,
            underline: e.underline,
            italics: e.italics,
            background: "black",
            flash: !1
        };
        this.setPen(r)
    }
    setBkgData(e) {
        this.logger.log(2, () => "bkgData = " + Te(e)),
        this.backSpace(),
        this.setPen(e),
        this.insertChar(32)
    }
    setRollUpRows(e) {
        this.nrRollUpRows = e
    }
    rollUp() {
        if (this.nrRollUpRows === null) {
            this.logger.log(3, "roll_up but nrRollUpRows not set yet");
            return
        }
        this.logger.log(1, () => this.getDisplayText());
        const e = this.currRow + 1 - this.nrRollUpRows
          , t = this.rows.splice(e, 1)[0];
        t.clear(),
        this.rows.splice(this.currRow, 0, t),
        this.logger.log(2, "Rolling up")
    }
    getDisplayText(e) {
        e = e || !1;
        const t = [];
        let n = ""
          , r = -1;
        for (let i = 0; i < Yt; i++) {
            const a = this.rows[i].getTextString();
            a && (r = i + 1,
            e ? t.push("Row " + r + ": '" + a + "'") : t.push(a.trim()))
        }
        return t.length > 0 && (e ? n = "[" + t.join(" | ") + "]" : n = t.join(`
`)),
        n
    }
    getTextAndFormat() {
        return this.rows
    }
}
class sm {
    constructor(e, t, n) {
        this.chNr = void 0,
        this.outputFilter = void 0,
        this.mode = void 0,
        this.verbose = void 0,
        this.displayedMemory = void 0,
        this.nonDisplayedMemory = void 0,
        this.lastOutputScreen = void 0,
        this.currRollUpRow = void 0,
        this.writeScreen = void 0,
        this.cueStartTime = void 0,
        this.logger = void 0,
        this.chNr = e,
        this.outputFilter = t,
        this.mode = null,
        this.verbose = 0,
        this.displayedMemory = new Vl(n),
        this.nonDisplayedMemory = new Vl(n),
        this.lastOutputScreen = new Vl(n),
        this.currRollUpRow = this.displayedMemory.rows[Yt - 1],
        this.writeScreen = this.displayedMemory,
        this.mode = null,
        this.cueStartTime = null,
        this.logger = n
    }
    reset() {
        this.mode = null,
        this.displayedMemory.reset(),
        this.nonDisplayedMemory.reset(),
        this.lastOutputScreen.reset(),
        this.outputFilter.reset(),
        this.currRollUpRow = this.displayedMemory.rows[Yt - 1],
        this.writeScreen = this.displayedMemory,
        this.mode = null,
        this.cueStartTime = null
    }
    getHandler() {
        return this.outputFilter
    }
    setHandler(e) {
        this.outputFilter = e
    }
    setPAC(e) {
        this.writeScreen.setPAC(e)
    }
    setBkgData(e) {
        this.writeScreen.setBkgData(e)
    }
    setMode(e) {
        e !== this.mode && (this.mode = e,
        this.logger.log(2, () => "MODE=" + e),
        this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory,
        this.writeScreen.reset()),
        this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.nrRollUpRows = null,
        this.nonDisplayedMemory.nrRollUpRows = null),
        this.mode = e)
    }
    insertChars(e) {
        for (let n = 0; n < e.length; n++)
            this.writeScreen.insertChar(e[n]);
        const t = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
        this.logger.log(2, () => t + ": " + this.writeScreen.getDisplayText(!0)),
        (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") && (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)),
        this.outputDataUpdate())
    }
    ccRCL() {
        this.logger.log(2, "RCL - Resume Caption Loading"),
        this.setMode("MODE_POP-ON")
    }
    ccBS() {
        this.logger.log(2, "BS - BackSpace"),
        this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(),
        this.writeScreen === this.displayedMemory && this.outputDataUpdate())
    }
    ccAOF() {}
    ccAON() {}
    ccDER() {
        this.logger.log(2, "DER- Delete to End of Row"),
        this.writeScreen.clearToEndOfRow(),
        this.outputDataUpdate()
    }
    ccRU(e) {
        this.logger.log(2, "RU(" + e + ") - Roll Up"),
        this.writeScreen = this.displayedMemory,
        this.setMode("MODE_ROLL-UP"),
        this.writeScreen.setRollUpRows(e)
    }
    ccFON() {
        this.logger.log(2, "FON - Flash On"),
        this.writeScreen.setPen({
            flash: !0
        })
    }
    ccRDC() {
        this.logger.log(2, "RDC - Resume Direct Captioning"),
        this.setMode("MODE_PAINT-ON")
    }
    ccTR() {
        this.logger.log(2, "TR"),
        this.setMode("MODE_TEXT")
    }
    ccRTD() {
        this.logger.log(2, "RTD"),
        this.setMode("MODE_TEXT")
    }
    ccEDM() {
        this.logger.log(2, "EDM - Erase Displayed Memory"),
        this.displayedMemory.reset(),
        this.outputDataUpdate(!0)
    }
    ccCR() {
        this.logger.log(2, "CR - Carriage Return"),
        this.writeScreen.rollUp(),
        this.outputDataUpdate(!0)
    }
    ccENM() {
        this.logger.log(2, "ENM - Erase Non-displayed Memory"),
        this.nonDisplayedMemory.reset()
    }
    ccEOC() {
        if (this.logger.log(2, "EOC - End Of Caption"),
        this.mode === "MODE_POP-ON") {
            const e = this.displayedMemory;
            this.displayedMemory = this.nonDisplayedMemory,
            this.nonDisplayedMemory = e,
            this.writeScreen = this.nonDisplayedMemory,
            this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText())
        }
        this.outputDataUpdate(!0)
    }
    ccTO(e) {
        this.logger.log(2, "TO(" + e + ") - Tab Offset"),
        this.writeScreen.moveCursor(e)
    }
    ccMIDROW(e) {
        const t = {
            flash: !1
        };
        if (t.underline = e % 2 === 1,
        t.italics = e >= 46,
        t.italics)
            t.foreground = "white";
        else {
            const n = Math.floor(e / 2) - 16
              , r = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
            t.foreground = r[n]
        }
        this.logger.log(2, "MIDROW: " + Te(t)),
        this.writeScreen.setPen(t)
    }
    outputDataUpdate(e=!1) {
        const t = this.logger.time;
        t !== null && this.outputFilter && (this.cueStartTime === null && !this.displayedMemory.isEmpty() ? this.cueStartTime = t : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen),
        e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(),
        this.cueStartTime = this.displayedMemory.isEmpty() ? null : t),
        this.lastOutputScreen.copy(this.displayedMemory))
    }
    cueSplitAtTime(e) {
        this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory),
        this.cueStartTime = e))
    }
}
class nm {
    constructor(e, t, n) {
        this.channels = void 0,
        this.currentChannel = 0,
        this.cmdHistory = zI(),
        this.logger = void 0;
        const r = this.logger = new VI;
        this.channels = [null, new sm(e,t,r), new sm(e + 1,n,r)]
    }
    getHandler(e) {
        return this.channels[e].getHandler()
    }
    setHandler(e, t) {
        this.channels[e].setHandler(t)
    }
    addData(e, t) {
        this.logger.time = e;
        for (let n = 0; n < t.length; n += 2) {
            const r = t[n] & 127
              , i = t[n + 1] & 127;
            let a = !1
              , o = null;
            if (r === 0 && i === 0)
                continue;
            this.logger.log(3, () => "[" + xn([t[n], t[n + 1]]) + "] -> (" + xn([r, i]) + ")");
            const l = this.cmdHistory;
            if (r >= 16 && r <= 31) {
                if (WI(r, i, l)) {
                    ya(null, null, l),
                    this.logger.log(3, () => "Repeated command (" + xn([r, i]) + ") is dropped");
                    continue
                }
                ya(r, i, this.cmdHistory),
                a = this.parseCmd(r, i),
                a || (a = this.parseMidrow(r, i)),
                a || (a = this.parsePAC(r, i)),
                a || (a = this.parseBackgroundAttributes(r, i))
            } else
                ya(null, null, l);
            if (!a && (o = this.parseChars(r, i),
            o)) {
                const u = this.currentChannel;
                u && u > 0 ? this.channels[u].insertChars(o) : this.logger.log(2, "No channel found yet. TEXT-MODE?")
            }
            !a && !o && this.logger.log(2, () => "Couldn't parse cleaned data " + xn([r, i]) + " orig: " + xn([t[n], t[n + 1]]))
        }
    }
    parseCmd(e, t) {
        const n = (e === 20 || e === 28 || e === 21 || e === 29) && t >= 32 && t <= 47
          , r = (e === 23 || e === 31) && t >= 33 && t <= 35;
        if (!(n || r))
            return !1;
        const i = e === 20 || e === 21 || e === 23 ? 1 : 2
          , a = this.channels[i];
        return e === 20 || e === 21 || e === 28 || e === 29 ? t === 32 ? a.ccRCL() : t === 33 ? a.ccBS() : t === 34 ? a.ccAOF() : t === 35 ? a.ccAON() : t === 36 ? a.ccDER() : t === 37 ? a.ccRU(2) : t === 38 ? a.ccRU(3) : t === 39 ? a.ccRU(4) : t === 40 ? a.ccFON() : t === 41 ? a.ccRDC() : t === 42 ? a.ccTR() : t === 43 ? a.ccRTD() : t === 44 ? a.ccEDM() : t === 45 ? a.ccCR() : t === 46 ? a.ccENM() : t === 47 && a.ccEOC() : a.ccTO(t - 32),
        this.currentChannel = i,
        !0
    }
    parseMidrow(e, t) {
        let n = 0;
        if ((e === 17 || e === 25) && t >= 32 && t <= 47) {
            if (e === 17 ? n = 1 : n = 2,
            n !== this.currentChannel)
                return this.logger.log(0, "Mismatch channel in midrow parsing"),
                !1;
            const r = this.channels[n];
            return r ? (r.ccMIDROW(t),
            this.logger.log(3, () => "MIDROW (" + xn([e, t]) + ")"),
            !0) : !1
        }
        return !1
    }
    parsePAC(e, t) {
        let n;
        const r = (e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127
          , i = (e === 16 || e === 24) && t >= 64 && t <= 95;
        if (!(r || i))
            return !1;
        const a = e <= 23 ? 1 : 2;
        t >= 64 && t <= 95 ? n = a === 1 ? UI[e] : $I[e] : n = a === 1 ? BI[e] : jI[e];
        const o = this.channels[a];
        return o ? (o.setPAC(this.interpretPAC(n, t)),
        this.currentChannel = a,
        !0) : !1
    }
    interpretPAC(e, t) {
        let n;
        const r = {
            color: null,
            italics: !1,
            indent: null,
            underline: !1,
            row: e
        };
        return t > 95 ? n = t - 96 : n = t - 64,
        r.underline = (n & 1) === 1,
        n <= 13 ? r.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(n / 2)] : n <= 15 ? (r.italics = !0,
        r.color = "white") : r.indent = Math.floor((n - 16) / 2) * 4,
        r
    }
    parseChars(e, t) {
        let n, r = null, i = null;
        if (e >= 25 ? (n = 2,
        i = e - 8) : (n = 1,
        i = e),
        i >= 17 && i <= 19) {
            let a;
            i === 17 ? a = t + 80 : i === 18 ? a = t + 112 : a = t + 144,
            this.logger.log(2, () => "Special char '" + oy(a) + "' in channel " + n),
            r = [a]
        } else
            e >= 32 && e <= 127 && (r = t === 0 ? [e] : [e, t]);
        return r && this.logger.log(3, () => "Char codes =  " + xn(r).join(",")),
        r
    }
    parseBackgroundAttributes(e, t) {
        const n = (e === 16 || e === 24) && t >= 32 && t <= 47
          , r = (e === 23 || e === 31) && t >= 45 && t <= 47;
        if (!(n || r))
            return !1;
        let i;
        const a = {};
        e === 16 || e === 24 ? (i = Math.floor((t - 32) / 2),
        a.background = GI[i],
        t % 2 === 1 && (a.background = a.background + "_semi")) : t === 45 ? a.background = "transparent" : (a.foreground = "black",
        t === 47 && (a.underline = !0));
        const o = e <= 23 ? 1 : 2;
        return this.channels[o].setBkgData(a),
        !0
    }
    reset() {
        for (let e = 0; e < Object.keys(this.channels).length; e++) {
            const t = this.channels[e];
            t && t.reset()
        }
        ya(null, null, this.cmdHistory)
    }
    cueSplitAtTime(e) {
        for (let t = 0; t < this.channels.length; t++) {
            const n = this.channels[t];
            n && n.cueSplitAtTime(e)
        }
    }
}
function ya(s, e, t) {
    t.a = s,
    t.b = e
}
function WI(s, e, t) {
    return t.a === s && t.b === e
}
function zI() {
    return {
        a: null,
        b: null
    }
}
var Pd = function() {
    if (Ao != null && Ao.VTTCue)
        return self.VTTCue;
    const s = ["", "lr", "rl"]
      , e = ["start", "middle", "end", "left", "right"];
    function t(o, l) {
        if (typeof l != "string" || !Array.isArray(o))
            return !1;
        const c = l.toLowerCase();
        return ~o.indexOf(c) ? c : !1
    }
    function n(o) {
        return t(s, o)
    }
    function r(o) {
        return t(e, o)
    }
    function i(o, ...l) {
        let c = 1;
        for (; c < arguments.length; c++) {
            const u = arguments[c];
            for (const d in u)
                o[d] = u[d]
        }
        return o
    }
    function a(o, l, c) {
        const u = this
          , d = {
            enumerable: !0
        };
        u.hasBeenReset = !1;
        let h = ""
          , f = !1
          , m = o
          , p = l
          , x = c
          , y = null
          , v = ""
          , E = !0
          , T = "auto"
          , L = "start"
          , R = 50
          , I = "middle"
          , A = 50
          , C = "middle";
        Object.defineProperty(u, "id", i({}, d, {
            get: function() {
                return h
            },
            set: function(b) {
                h = "" + b
            }
        })),
        Object.defineProperty(u, "pauseOnExit", i({}, d, {
            get: function() {
                return f
            },
            set: function(b) {
                f = !!b
            }
        })),
        Object.defineProperty(u, "startTime", i({}, d, {
            get: function() {
                return m
            },
            set: function(b) {
                if (typeof b != "number")
                    throw new TypeError("Start time must be set to a number.");
                m = b,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "endTime", i({}, d, {
            get: function() {
                return p
            },
            set: function(b) {
                if (typeof b != "number")
                    throw new TypeError("End time must be set to a number.");
                p = b,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "text", i({}, d, {
            get: function() {
                return x
            },
            set: function(b) {
                x = "" + b,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "region", i({}, d, {
            get: function() {
                return y
            },
            set: function(b) {
                y = b,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "vertical", i({}, d, {
            get: function() {
                return v
            },
            set: function(b) {
                const O = n(b);
                if (O === !1)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                v = O,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "snapToLines", i({}, d, {
            get: function() {
                return E
            },
            set: function(b) {
                E = !!b,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "line", i({}, d, {
            get: function() {
                return T
            },
            set: function(b) {
                if (typeof b != "number" && b !== "auto")
                    throw new SyntaxError("An invalid number or illegal string was specified.");
                T = b,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "lineAlign", i({}, d, {
            get: function() {
                return L
            },
            set: function(b) {
                const O = r(b);
                if (!O)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                L = O,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "position", i({}, d, {
            get: function() {
                return R
            },
            set: function(b) {
                if (b < 0 || b > 100)
                    throw new Error("Position must be between 0 and 100.");
                R = b,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "positionAlign", i({}, d, {
            get: function() {
                return I
            },
            set: function(b) {
                const O = r(b);
                if (!O)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                I = O,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "size", i({}, d, {
            get: function() {
                return A
            },
            set: function(b) {
                if (b < 0 || b > 100)
                    throw new Error("Size must be between 0 and 100.");
                A = b,
                this.hasBeenReset = !0
            }
        })),
        Object.defineProperty(u, "align", i({}, d, {
            get: function() {
                return C
            },
            set: function(b) {
                const O = r(b);
                if (!O)
                    throw new SyntaxError("An invalid or illegal string was specified.");
                C = O,
                this.hasBeenReset = !0
            }
        })),
        u.displayState = void 0
    }
    return a.prototype.getCueAsHTML = function() {
        return self.WebVTT.convertCueToDOMTree(self, this.text)
    }
    ,
    a
}();
class YI {
    decode(e, t) {
        if (!e)
            return "";
        if (typeof e != "string")
            throw new Error("Error - expected string data.");
        return decodeURIComponent(encodeURIComponent(e))
    }
}
function cy(s) {
    function e(n, r, i, a) {
        return (n | 0) * 3600 + (r | 0) * 60 + (i | 0) + parseFloat(a || 0)
    }
    const t = s.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
    return t ? parseFloat(t[2]) > 59 ? e(t[2], t[3], 0, t[4]) : e(t[1], t[2], t[3], t[4]) : null
}
class XI {
    constructor() {
        this.values = Object.create(null)
    }
    set(e, t) {
        !this.get(e) && t !== "" && (this.values[e] = t)
    }
    get(e, t, n) {
        return n ? this.has(e) ? this.values[e] : t[n] : this.has(e) ? this.values[e] : t
    }
    has(e) {
        return e in this.values
    }
    alt(e, t, n) {
        for (let r = 0; r < n.length; ++r)
            if (t === n[r]) {
                this.set(e, t);
                break
            }
    }
    integer(e, t) {
        /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10))
    }
    percent(e, t) {
        if (/^([\d]{1,3})(\.[\d]*)?%$/.test(t)) {
            const n = parseFloat(t);
            if (n >= 0 && n <= 100)
                return this.set(e, n),
                !0
        }
        return !1
    }
}
function uy(s, e, t, n) {
    const r = n ? s.split(n) : [s];
    for (const i in r) {
        if (typeof r[i] != "string")
            continue;
        const a = r[i].split(t);
        if (a.length !== 2)
            continue;
        const o = a[0]
          , l = a[1];
        e(o, l)
    }
}
const cu = new Pd(0,0,"")
  , xa = cu.align === "middle" ? "middle" : "center";
function ZI(s, e, t) {
    const n = s;
    function r() {
        const o = cy(s);
        if (o === null)
            throw new Error("Malformed timestamp: " + n);
        return s = s.replace(/^[^\sa-zA-Z-]+/, ""),
        o
    }
    function i(o, l) {
        const c = new XI;
        uy(o, function(h, f) {
            let m;
            switch (h) {
            case "region":
                for (let p = t.length - 1; p >= 0; p--)
                    if (t[p].id === f) {
                        c.set(h, t[p].region);
                        break
                    }
                break;
            case "vertical":
                c.alt(h, f, ["rl", "lr"]);
                break;
            case "line":
                m = f.split(","),
                c.integer(h, m[0]),
                c.percent(h, m[0]) && c.set("snapToLines", !1),
                c.alt(h, m[0], ["auto"]),
                m.length === 2 && c.alt("lineAlign", m[1], ["start", xa, "end"]);
                break;
            case "position":
                m = f.split(","),
                c.percent(h, m[0]),
                m.length === 2 && c.alt("positionAlign", m[1], ["start", xa, "end", "line-left", "line-right", "auto"]);
                break;
            case "size":
                c.percent(h, f);
                break;
            case "align":
                c.alt(h, f, ["start", xa, "end", "left", "right"]);
                break
            }
        }, /:/, /\s/),
        l.region = c.get("region", null),
        l.vertical = c.get("vertical", "");
        let u = c.get("line", "auto");
        u === "auto" && cu.line === -1 && (u = -1),
        l.line = u,
        l.lineAlign = c.get("lineAlign", "start"),
        l.snapToLines = c.get("snapToLines", !0),
        l.size = c.get("size", 100),
        l.align = c.get("align", xa);
        let d = c.get("position", "auto");
        d === "auto" && cu.position === 50 && (d = l.align === "start" || l.align === "left" ? 0 : l.align === "end" || l.align === "right" ? 100 : 50),
        l.position = d
    }
    function a() {
        s = s.replace(/^\s+/, "")
    }
    if (a(),
    e.startTime = r(),
    a(),
    s.slice(0, 3) !== "-->")
        throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + n);
    s = s.slice(3),
    a(),
    e.endTime = r(),
    a(),
    i(s, e)
}
function dy(s) {
    return s.replace(/<br(?: \/)?>/gi, `
`)
}
class qI {
    constructor() {
        this.state = "INITIAL",
        this.buffer = "",
        this.decoder = new YI,
        this.regionList = [],
        this.cue = null,
        this.oncue = void 0,
        this.onparsingerror = void 0,
        this.onflush = void 0
    }
    parse(e) {
        const t = this;
        e && (t.buffer += t.decoder.decode(e, {
            stream: !0
        }));
        function n() {
            let i = t.buffer
              , a = 0;
            for (i = dy(i); a < i.length && i[a] !== "\r" && i[a] !== `
`; )
                ++a;
            const o = i.slice(0, a);
            return i[a] === "\r" && ++a,
            i[a] === `
` && ++a,
            t.buffer = i.slice(a),
            o
        }
        function r(i) {
            uy(i, function(a, o) {}, /:/)
        }
        try {
            let i = "";
            if (t.state === "INITIAL") {
                if (!/\r\n|\n/.test(t.buffer))
                    return this;
                i = n();
                const o = i.match(/^()?WEBVTT([ \t].*)?$/);
                if (!(o != null && o[0]))
                    throw new Error("Malformed WebVTT signature.");
                t.state = "HEADER"
            }
            let a = !1;
            for (; t.buffer; ) {
                if (!/\r\n|\n/.test(t.buffer))
                    return this;
                switch (a ? a = !1 : i = n(),
                t.state) {
                case "HEADER":
                    /:/.test(i) ? r(i) : i || (t.state = "ID");
                    continue;
                case "NOTE":
                    i || (t.state = "ID");
                    continue;
                case "ID":
                    if (/^NOTE($|[ \t])/.test(i)) {
                        t.state = "NOTE";
                        break
                    }
                    if (!i)
                        continue;
                    if (t.cue = new Pd(0,0,""),
                    t.state = "CUE",
                    i.indexOf("-->") === -1) {
                        t.cue.id = i;
                        continue
                    }
                case "CUE":
                    if (!t.cue) {
                        t.state = "BADCUE";
                        continue
                    }
                    try {
                        ZI(i, t.cue, t.regionList)
                    } catch {
                        t.cue = null,
                        t.state = "BADCUE";
                        continue
                    }
                    t.state = "CUETEXT";
                    continue;
                case "CUETEXT":
                    {
                        const o = i.indexOf("-->") !== -1;
                        if (!i || o && (a = !0)) {
                            t.oncue && t.cue && t.oncue(t.cue),
                            t.cue = null,
                            t.state = "ID";
                            continue
                        }
                        if (t.cue === null)
                            continue;
                        t.cue.text && (t.cue.text += `
`),
                        t.cue.text += i
                    }
                    continue;
                case "BADCUE":
                    i || (t.state = "ID")
                }
            }
        } catch {
            t.state === "CUETEXT" && t.cue && t.oncue && t.oncue(t.cue),
            t.cue = null,
            t.state = t.state === "INITIAL" ? "BADWEBVTT" : "BADCUE"
        }
        return this
    }
    flush() {
        const e = this;
        try {
            if ((e.cue || e.state === "HEADER") && (e.buffer += `

`,
            e.parse()),
            e.state === "INITIAL" || e.state === "BADWEBVTT")
                throw new Error("Malformed WebVTT signature.")
        } catch (t) {
            e.onparsingerror && e.onparsingerror(t)
        }
        return e.onflush && e.onflush(),
        this
    }
}
const QI = /\r\n|\n\r|\n|\r/g
  , Hl = function(e, t, n=0) {
    return e.slice(n, n + t.length) === t
}
  , JI = function(e) {
    let t = parseInt(e.slice(-3));
    const n = parseInt(e.slice(-6, -4))
      , r = parseInt(e.slice(-9, -7))
      , i = e.length > 9 ? parseInt(e.substring(0, e.indexOf(":"))) : 0;
    if (!z(t) || !z(n) || !z(r) || !z(i))
        throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);
    return t += 1e3 * n,
    t += 60 * 1e3 * r,
    t += 60 * 60 * 1e3 * i,
    t
};
function Nd(s, e, t) {
    return ii(s.toString()) + ii(e.toString()) + ii(t)
}
const eA = function(e, t, n) {
    let r = e[t]
      , i = e[r.prevCC];
    if (!i || !i.new && r.new) {
        e.ccOffset = e.presentationOffset = r.start,
        r.new = !1;
        return
    }
    for (; (a = i) != null && a.new; ) {
        var a;
        e.ccOffset += r.start - i.start,
        r.new = !1,
        r = i,
        i = e[r.prevCC]
    }
    e.presentationOffset = n
};
function tA(s, e, t, n, r, i, a) {
    const o = new qI
      , l = wt(new Uint8Array(s)).trim().replace(QI, `
`).split(`
`)
      , c = []
      , u = e ? lL(e.baseTime, e.timescale) : 0;
    let d = "00:00.000", h = 0, f = 0, m, p = !0;
    o.oncue = function(x) {
        const y = t[n];
        let v = t.ccOffset;
        const E = (h - u) / 9e4;
        if (y != null && y.new && (f !== void 0 ? v = t.ccOffset = y.start : eA(t, n, E)),
        E) {
            if (!e) {
                m = new Error("Missing initPTS for VTT MPEGTS");
                return
            }
            v = E - t.presentationOffset
        }
        const T = x.endTime - x.startTime
          , L = Pt((x.startTime + v - f) * 9e4, r * 9e4) / 9e4;
        x.startTime = Math.max(L, 0),
        x.endTime = Math.max(L + T, 0);
        const R = x.text.trim();
        x.text = decodeURIComponent(encodeURIComponent(R)),
        x.id || (x.id = Nd(x.startTime, x.endTime, R)),
        x.endTime > 0 && c.push(x)
    }
    ,
    o.onparsingerror = function(x) {
        m = x
    }
    ,
    o.onflush = function() {
        if (m) {
            a(m);
            return
        }
        i(c)
    }
    ,
    l.forEach(x => {
        if (p)
            if (Hl(x, "X-TIMESTAMP-MAP=")) {
                p = !1,
                x.slice(16).split(",").forEach(y => {
                    Hl(y, "LOCAL:") ? d = y.slice(6) : Hl(y, "MPEGTS:") && (h = parseInt(y.slice(7)))
                }
                );
                try {
                    f = JI(d) / 1e3
                } catch (y) {
                    m = y
                }
                return
            } else
                x === "" && (p = !1);
        o.parse(x + `
`)
    }
    ),
    o.flush()
}
const Kl = "stpp.ttml.im1t"
  , hy = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/
  , fy = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/
  , sA = {
    left: "start",
    center: "center",
    right: "end",
    start: "start",
    end: "end"
};
function rm(s, e, t, n) {
    const r = ae(new Uint8Array(s), ["mdat"]);
    if (r.length === 0) {
        n(new Error("Could not parse IMSC1 mdat"));
        return
    }
    const i = r.map(o => wt(o))
      , a = oL(e.baseTime, 1, e.timescale);
    try {
        i.forEach(o => t(nA(o, a)))
    } catch (o) {
        n(o)
    }
}
function nA(s, e) {
    const r = new DOMParser().parseFromString(s, "text/xml").getElementsByTagName("tt")[0];
    if (!r)
        throw new Error("Invalid ttml");
    const i = {
        frameRate: 30,
        subFrameRate: 1,
        frameRateMultiplier: 0,
        tickRate: 0
    }
      , a = Object.keys(i).reduce( (d, h) => (d[h] = r.getAttribute(`ttp:${h}`) || i[h],
    d), {})
      , o = r.getAttribute("xml:space") !== "preserve"
      , l = im(Wl(r, "styling", "style"))
      , c = im(Wl(r, "layout", "region"))
      , u = Wl(r, "body", "[begin]");
    return [].map.call(u, d => {
        const h = my(d, o);
        if (!h || !d.hasAttribute("begin"))
            return null;
        const f = Yl(d.getAttribute("begin"), a)
          , m = Yl(d.getAttribute("dur"), a);
        let p = Yl(d.getAttribute("end"), a);
        if (f === null)
            throw am(d);
        if (p === null) {
            if (m === null)
                throw am(d);
            p = f + m
        }
        const x = new Pd(f - e,p - e,h);
        x.id = Nd(x.startTime, x.endTime, x.text);
        const y = c[d.getAttribute("region")]
          , v = l[d.getAttribute("style")]
          , E = rA(y, v, l)
          , {textAlign: T} = E;
        if (T) {
            const L = sA[T];
            L && (x.lineAlign = L),
            x.align = T
        }
        return ye(x, E),
        x
    }
    ).filter(d => d !== null)
}
function Wl(s, e, t) {
    const n = s.getElementsByTagName(e)[0];
    return n ? [].slice.call(n.querySelectorAll(t)) : []
}
function im(s) {
    return s.reduce( (e, t) => {
        const n = t.getAttribute("xml:id");
        return n && (e[n] = t),
        e
    }
    , {})
}
function my(s, e) {
    return [].slice.call(s.childNodes).reduce( (t, n, r) => {
        var i;
        return n.nodeName === "br" && r ? t + `
` : (i = n.childNodes) != null && i.length ? my(n, e) : e ? t + n.textContent.trim().replace(/\s+/g, " ") : t + n.textContent
    }
    , "")
}
function rA(s, e, t) {
    const n = "http://www.w3.org/ns/ttml#styling";
    let r = null;
    const i = ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"]
      , a = s != null && s.hasAttribute("style") ? s.getAttribute("style") : null;
    return a && t.hasOwnProperty(a) && (r = t[a]),
    i.reduce( (o, l) => {
        const c = zl(e, n, l) || zl(s, n, l) || zl(r, n, l);
        return c && (o[l] = c),
        o
    }
    , {})
}
function zl(s, e, t) {
    return s && s.hasAttributeNS(e, t) ? s.getAttributeNS(e, t) : null
}
function am(s) {
    return new Error(`Could not parse ttml timestamp ${s}`)
}
function Yl(s, e) {
    if (!s)
        return null;
    let t = cy(s);
    return t === null && (hy.test(s) ? t = iA(s, e) : fy.test(s) && (t = aA(s, e))),
    t
}
function iA(s, e) {
    const t = hy.exec(s)
      , n = (t[4] | 0) + (t[5] | 0) / e.subFrameRate;
    return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + n / e.frameRate
}
function aA(s, e) {
    const t = fy.exec(s)
      , n = Number(t[1]);
    switch (t[2]) {
    case "h":
        return n * 3600;
    case "m":
        return n * 60;
    case "ms":
        return n * 1e3;
    case "f":
        return n / e.frameRate;
    case "t":
        return n / e.tickRate
    }
    return n
}
class va {
    constructor(e, t) {
        this.timelineController = void 0,
        this.cueRanges = [],
        this.trackName = void 0,
        this.startTime = null,
        this.endTime = null,
        this.screen = null,
        this.timelineController = e,
        this.trackName = t
    }
    dispatchCue() {
        this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges),
        this.startTime = null)
    }
    newCue(e, t, n) {
        (this.startTime === null || this.startTime > e) && (this.startTime = e),
        this.endTime = t,
        this.screen = n,
        this.timelineController.createCaptionsTrack(this.trackName)
    }
    reset() {
        this.cueRanges = [],
        this.startTime = null
    }
}
class oA {
    constructor(e) {
        this.hls = void 0,
        this.media = null,
        this.config = void 0,
        this.enabled = !0,
        this.Cues = void 0,
        this.textTracks = [],
        this.tracks = [],
        this.initPTS = [],
        this.unparsedVttFrags = [],
        this.captionsTracks = {},
        this.nonNativeCaptionsTracks = {},
        this.cea608Parser1 = void 0,
        this.cea608Parser2 = void 0,
        this.lastCc = -1,
        this.lastSn = -1,
        this.lastPartIndex = -1,
        this.prevCC = -1,
        this.vttCCs = lm(),
        this.captionsProperties = void 0,
        this.hls = e,
        this.config = e.config,
        this.Cues = e.config.cueHandler,
        this.captionsProperties = {
            textTrack1: {
                label: this.config.captionsTextTrack1Label,
                languageCode: this.config.captionsTextTrack1LanguageCode
            },
            textTrack2: {
                label: this.config.captionsTextTrack2Label,
                languageCode: this.config.captionsTextTrack2LanguageCode
            },
            textTrack3: {
                label: this.config.captionsTextTrack3Label,
                languageCode: this.config.captionsTextTrack3LanguageCode
            },
            textTrack4: {
                label: this.config.captionsTextTrack4Label,
                languageCode: this.config.captionsTextTrack4LanguageCode
            }
        },
        e.on(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(S.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.on(S.FRAG_LOADING, this.onFragLoading, this),
        e.on(S.FRAG_LOADED, this.onFragLoaded, this),
        e.on(S.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
        e.on(S.FRAG_DECRYPTED, this.onFragDecrypted, this),
        e.on(S.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.on(S.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this),
        e.on(S.BUFFER_FLUSHING, this.onBufferFlushing, this)
    }
    destroy() {
        const {hls: e} = this;
        e.off(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(S.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this),
        e.off(S.FRAG_LOADING, this.onFragLoading, this),
        e.off(S.FRAG_LOADED, this.onFragLoaded, this),
        e.off(S.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this),
        e.off(S.FRAG_DECRYPTED, this.onFragDecrypted, this),
        e.off(S.INIT_PTS_FOUND, this.onInitPtsFound, this),
        e.off(S.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this),
        e.off(S.BUFFER_FLUSHING, this.onBufferFlushing, this),
        this.hls = this.config = this.media = null,
        this.cea608Parser1 = this.cea608Parser2 = void 0
    }
    initCea608Parsers() {
        const e = new va(this,"textTrack1")
          , t = new va(this,"textTrack2")
          , n = new va(this,"textTrack3")
          , r = new va(this,"textTrack4");
        this.cea608Parser1 = new nm(1,e,t),
        this.cea608Parser2 = new nm(3,n,r)
    }
    addCues(e, t, n, r, i) {
        let a = !1;
        for (let o = i.length; o--; ) {
            const l = i[o]
              , c = lA(l[0], l[1], t, n);
            if (c >= 0 && (l[0] = Math.min(l[0], t),
            l[1] = Math.max(l[1], n),
            a = !0,
            c / (n - t) > .5))
                return
        }
        if (a || i.push([t, n]),
        this.config.renderTextTracksNatively) {
            const o = this.captionsTracks[e];
            this.Cues.newCue(o, t, n, r)
        } else {
            const o = this.Cues.newCue(null, t, n, r);
            this.hls.trigger(S.CUES_PARSED, {
                type: "captions",
                cues: o,
                track: e
            })
        }
    }
    onInitPtsFound(e, {frag: t, id: n, initPTS: r, timescale: i, trackId: a}) {
        const {unparsedVttFrags: o} = this;
        n === X.MAIN && (this.initPTS[t.cc] = {
            baseTime: r,
            timescale: i,
            trackId: a
        }),
        o.length && (this.unparsedVttFrags = [],
        o.forEach(l => {
            this.initPTS[l.frag.cc] ? this.onFragLoaded(S.FRAG_LOADED, l) : this.hls.trigger(S.SUBTITLE_FRAG_PROCESSED, {
                success: !1,
                frag: l.frag,
                error: new Error("Subtitle discontinuity domain does not match main")
            })
        }
        ))
    }
    getExistingTrack(e, t) {
        const {media: n} = this;
        if (n)
            for (let r = 0; r < n.textTracks.length; r++) {
                const i = n.textTracks[r];
                if (om(i, {
                    name: e,
                    lang: t,
                    characteristics: "transcribes-spoken-dialog,describes-music-and-sound"
                }))
                    return i
            }
        return null
    }
    createCaptionsTrack(e) {
        this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e)
    }
    createNativeTrack(e) {
        if (this.captionsTracks[e])
            return;
        const {captionsProperties: t, captionsTracks: n, media: r} = this
          , {label: i, languageCode: a} = t[e]
          , o = this.getExistingTrack(i, a);
        if (o)
            n[e] = o,
            nr(n[e]),
            ry(n[e], r);
        else {
            const l = this.createTextTrack("captions", i, a);
            l && (l[e] = !0,
            n[e] = l)
        }
    }
    createNonNativeTrack(e) {
        if (this.nonNativeCaptionsTracks[e])
            return;
        const t = this.captionsProperties[e];
        if (!t)
            return;
        const n = t.label
          , r = {
            _id: e,
            label: n,
            kind: "captions",
            default: t.media ? !!t.media.default : !1,
            closedCaptions: t.media
        };
        this.nonNativeCaptionsTracks[e] = r,
        this.hls.trigger(S.NON_NATIVE_TEXT_TRACKS_FOUND, {
            tracks: [r]
        })
    }
    createTextTrack(e, t, n) {
        const r = this.media;
        if (r)
            return r.addTextTrack(e, t, n)
    }
    onMediaAttaching(e, t) {
        this.media = t.media,
        t.mediaSource || this._cleanTracks()
    }
    onMediaDetaching(e, t) {
        const n = !!t.transferMedia;
        if (this.media = null,
        n)
            return;
        const {captionsTracks: r} = this;
        Object.keys(r).forEach(i => {
            nr(r[i]),
            delete r[i]
        }
        ),
        this.nonNativeCaptionsTracks = {}
    }
    onManifestLoading() {
        this.lastCc = -1,
        this.lastSn = -1,
        this.lastPartIndex = -1,
        this.prevCC = -1,
        this.vttCCs = lm(),
        this._cleanTracks(),
        this.tracks = [],
        this.captionsTracks = {},
        this.nonNativeCaptionsTracks = {},
        this.textTracks = [],
        this.unparsedVttFrags = [],
        this.initPTS = [],
        this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(),
        this.cea608Parser2.reset())
    }
    _cleanTracks() {
        const {media: e} = this;
        if (!e)
            return;
        const t = e.textTracks;
        if (t)
            for (let n = 0; n < t.length; n++)
                nr(t[n])
    }
    onSubtitleTracksUpdated(e, t) {
        const n = t.subtitleTracks || []
          , r = n.some(i => i.textCodec === Kl);
        if (this.config.enableWebVTT || r && this.config.enableIMSC1) {
            if (K0(this.tracks, n)) {
                this.tracks = n;
                return
            }
            if (this.textTracks = [],
            this.tracks = n,
            this.config.renderTextTracksNatively) {
                const a = this.media
                  , o = a ? Ga(a.textTracks) : null;
                if (this.tracks.forEach( (l, c) => {
                    let u;
                    if (o) {
                        let d = null;
                        for (let h = 0; h < o.length; h++)
                            if (o[h] && om(o[h], l)) {
                                d = o[h],
                                o[h] = null;
                                break
                            }
                        d && (u = d)
                    }
                    if (u)
                        nr(u);
                    else {
                        const d = gy(l);
                        u = this.createTextTrack(d, l.name, l.lang),
                        u && (u.mode = "disabled")
                    }
                    u && this.textTracks.push(u)
                }
                ),
                o != null && o.length) {
                    const l = o.filter(c => c !== null).map(c => c.label);
                    l.length && this.hls.logger.warn(`Media element contains unused subtitle tracks: ${l.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`)
                }
            } else if (this.tracks.length) {
                const a = this.tracks.map(o => ({
                    label: o.name,
                    kind: o.type.toLowerCase(),
                    default: o.default,
                    subtitleTrack: o
                }));
                this.hls.trigger(S.NON_NATIVE_TEXT_TRACKS_FOUND, {
                    tracks: a
                })
            }
        }
    }
    onManifestLoaded(e, t) {
        this.config.enableCEA708Captions && t.captions && t.captions.forEach(n => {
            const r = /(?:CC|SERVICE)([1-4])/.exec(n.instreamId);
            if (!r)
                return;
            const i = `textTrack${r[1]}`
              , a = this.captionsProperties[i];
            a && (a.label = n.name,
            n.lang && (a.languageCode = n.lang),
            a.media = n)
        }
        )
    }
    closedCaptionsForLevel(e) {
        const t = this.hls.levels[e.level];
        return t == null ? void 0 : t.attrs["CLOSED-CAPTIONS"]
    }
    onFragLoading(e, t) {
        if (this.enabled && t.frag.type === X.MAIN) {
            var n, r;
            const {cea608Parser1: i, cea608Parser2: a, lastSn: o} = this
              , {cc: l, sn: c} = t.frag
              , u = (n = (r = t.part) == null ? void 0 : r.index) != null ? n : -1;
            i && a && (c !== o + 1 || c === o && u !== this.lastPartIndex + 1 || l !== this.lastCc) && (i.reset(),
            a.reset()),
            this.lastCc = l,
            this.lastSn = c,
            this.lastPartIndex = u
        }
    }
    onFragLoaded(e, t) {
        const {frag: n, payload: r} = t;
        if (n.type === X.SUBTITLE)
            if (r.byteLength) {
                const i = n.decryptdata
                  , a = "stats"in t;
                if (i == null || !i.encrypted || a) {
                    const o = this.tracks[n.level]
                      , l = this.vttCCs;
                    l[n.cc] || (l[n.cc] = {
                        start: n.start,
                        prevCC: this.prevCC,
                        new: !0
                    },
                    this.prevCC = n.cc),
                    o && o.textCodec === Kl ? this._parseIMSC1(n, r) : this._parseVTTs(t)
                }
            } else
                this.hls.trigger(S.SUBTITLE_FRAG_PROCESSED, {
                    success: !1,
                    frag: n,
                    error: new Error("Empty subtitle payload")
                })
    }
    _parseIMSC1(e, t) {
        const n = this.hls;
        rm(t, this.initPTS[e.cc], r => {
            this._appendCues(r, e.level),
            n.trigger(S.SUBTITLE_FRAG_PROCESSED, {
                success: !0,
                frag: e
            })
        }
        , r => {
            n.logger.log(`Failed to parse IMSC1: ${r}`),
            n.trigger(S.SUBTITLE_FRAG_PROCESSED, {
                success: !1,
                frag: e,
                error: r
            })
        }
        )
    }
    _parseVTTs(e) {
        var t;
        const {frag: n, payload: r} = e
          , {initPTS: i, unparsedVttFrags: a} = this
          , o = i.length - 1;
        if (!i[n.cc] && o === -1) {
            a.push(e);
            return
        }
        const l = this.hls
          , c = (t = n.initSegment) != null && t.data ? jt(n.initSegment.data, new Uint8Array(r)).buffer : r;
        tA(c, this.initPTS[n.cc], this.vttCCs, n.cc, n.start, u => {
            this._appendCues(u, n.level),
            l.trigger(S.SUBTITLE_FRAG_PROCESSED, {
                success: !0,
                frag: n
            })
        }
        , u => {
            const d = u.message === "Missing initPTS for VTT MPEGTS";
            d ? a.push(e) : this._fallbackToIMSC1(n, r),
            l.logger.log(`Failed to parse VTT cue: ${u}`),
            !(d && o > n.cc) && l.trigger(S.SUBTITLE_FRAG_PROCESSED, {
                success: !1,
                frag: n,
                error: u
            })
        }
        )
    }
    _fallbackToIMSC1(e, t) {
        const n = this.tracks[e.level];
        n.textCodec || rm(t, this.initPTS[e.cc], () => {
            n.textCodec = Kl,
            this._parseIMSC1(e, t)
        }
        , () => {
            n.textCodec = "wvtt"
        }
        )
    }
    _appendCues(e, t) {
        const n = this.hls;
        if (this.config.renderTextTracksNatively) {
            const r = this.textTracks[t];
            if (!r || r.mode === "disabled")
                return;
            e.forEach(i => iy(r, i))
        } else {
            const r = this.tracks[t];
            if (!r)
                return;
            const i = r.default ? "default" : "subtitles" + t;
            n.trigger(S.CUES_PARSED, {
                type: "subtitles",
                cues: e,
                track: i
            })
        }
    }
    onFragDecrypted(e, t) {
        const {frag: n} = t;
        n.type === X.SUBTITLE && this.onFragLoaded(S.FRAG_LOADED, t)
    }
    onSubtitleTracksCleared() {
        this.tracks = [],
        this.captionsTracks = {}
    }
    onFragParsingUserdata(e, t) {
        if (!this.enabled || !this.config.enableCEA708Captions)
            return;
        const {frag: n, samples: r} = t;
        if (!(n.type === X.MAIN && this.closedCaptionsForLevel(n) === "NONE"))
            for (let i = 0; i < r.length; i++) {
                const a = r[i].bytes;
                if (a) {
                    this.cea608Parser1 || this.initCea608Parsers();
                    const o = this.extractCea608Data(a);
                    this.cea608Parser1.addData(r[i].pts, o[0]),
                    this.cea608Parser2.addData(r[i].pts, o[1])
                }
            }
    }
    onBufferFlushing(e, {startOffset: t, endOffset: n, endOffsetSubtitles: r, type: i}) {
        const {media: a} = this;
        if (!(!a || a.currentTime < n)) {
            if (!i || i === "video") {
                const {captionsTracks: o} = this;
                Object.keys(o).forEach(l => lu(o[l], t, n))
            }
            if (this.config.renderTextTracksNatively && t === 0 && r !== void 0) {
                const {textTracks: o} = this;
                Object.keys(o).forEach(l => lu(o[l], t, r))
            }
        }
    }
    extractCea608Data(e) {
        const t = [[], []]
          , n = e[0] & 31;
        let r = 2;
        for (let i = 0; i < n; i++) {
            const a = e[r++]
              , o = 127 & e[r++]
              , l = 127 & e[r++];
            if (o === 0 && l === 0)
                continue;
            if ((4 & a) !== 0) {
                const u = 3 & a;
                (u === 0 || u === 1) && (t[u].push(o),
                t[u].push(l))
            }
        }
        return t
    }
}
function gy(s) {
    return s.characteristics && /transcribes-spoken-dialog/gi.test(s.characteristics) && /describes-music-and-sound/gi.test(s.characteristics) ? "captions" : "subtitles"
}
function om(s, e) {
    return !!s && s.kind === gy(e) && ru(e, s)
}
function lA(s, e, t, n) {
    return Math.min(e, n) - Math.max(s, t)
}
function lm() {
    return {
        ccOffset: 0,
        presentationOffset: 0,
        0: {
            start: 0,
            prevCC: -1,
            new: !0
        }
    }
}
const cA = /\s/
  , uA = {
    newCue(s, e, t, n) {
        const r = [];
        let i, a, o, l, c;
        const u = self.VTTCue || self.TextTrackCue;
        for (let h = 0; h < n.rows.length; h++)
            if (i = n.rows[h],
            o = !0,
            l = 0,
            c = "",
            !i.isEmpty()) {
                var d;
                for (let p = 0; p < i.chars.length; p++)
                    cA.test(i.chars[p].uchar) && o ? l++ : (c += i.chars[p].uchar,
                    o = !1);
                i.cueStartTime = e,
                e === t && (t += 1e-4),
                l >= 16 ? l-- : l++;
                const f = dy(c.trim())
                  , m = Nd(e, t, f);
                s != null && (d = s.cues) != null && d.getCueById(m) || (a = new u(e,t,f),
                a.id = m,
                a.line = h + 1,
                a.align = "left",
                a.position = 10 + Math.min(80, Math.floor(l * 8 / 32) * 10),
                r.push(a))
            }
        return s && r.length && (r.sort( (h, f) => h.line === "auto" || f.line === "auto" ? 0 : h.line > 8 && f.line > 8 ? f.line - h.line : h.line - f.line),
        r.forEach(h => iy(s, h))),
        r
    }
};
function dA() {
    if (self.fetch && self.AbortController && self.ReadableStream && self.Request)
        try {
            return new self.ReadableStream({}),
            !0
        } catch {}
    return !1
}
const hA = /(\d+)-(\d+)\/(\d+)/;
class cm {
    constructor(e) {
        this.fetchSetup = void 0,
        this.requestTimeout = void 0,
        this.request = null,
        this.response = null,
        this.controller = void 0,
        this.context = null,
        this.config = null,
        this.callbacks = null,
        this.stats = void 0,
        this.loader = null,
        this.fetchSetup = e.fetchSetup || pA,
        this.controller = new self.AbortController,
        this.stats = new hd
    }
    destroy() {
        this.loader = this.callbacks = this.context = this.config = this.request = null,
        this.abortInternal(),
        this.response = null,
        this.fetchSetup = this.controller = this.stats = null
    }
    abortInternal() {
        this.controller && !this.stats.loading.end && (this.stats.aborted = !0,
        this.controller.abort())
    }
    abort() {
        var e;
        this.abortInternal(),
        (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
    }
    load(e, t, n) {
        const r = this.stats;
        if (r.loading.start)
            throw new Error("Loader can only be used once.");
        r.loading.start = self.performance.now();
        const i = fA(e, this.controller.signal)
          , a = e.responseType === "arraybuffer"
          , o = a ? "byteLength" : "length"
          , {maxTimeToFirstByteMs: l, maxLoadTimeMs: c} = t.loadPolicy;
        this.context = e,
        this.config = t,
        this.callbacks = n,
        this.request = this.fetchSetup(e, i),
        self.clearTimeout(this.requestTimeout),
        t.timeout = l && z(l) ? l : c,
        this.requestTimeout = self.setTimeout( () => {
            this.callbacks && (this.abortInternal(),
            this.callbacks.onTimeout(r, e, this.response))
        }
        , t.timeout),
        (Ci(this.request) ? this.request.then(self.fetch) : self.fetch(this.request)).then(d => {
            var h;
            this.response = this.loader = d;
            const f = Math.max(self.performance.now(), r.loading.start);
            if (self.clearTimeout(this.requestTimeout),
            t.timeout = c,
            this.requestTimeout = self.setTimeout( () => {
                this.callbacks && (this.abortInternal(),
                this.callbacks.onTimeout(r, e, this.response))
            }
            , c - (f - r.loading.start)),
            !d.ok) {
                const {status: p, statusText: x} = d;
                throw new yA(x || "fetch, bad network response",p,d)
            }
            r.loading.first = f,
            r.total = gA(d.headers) || r.total;
            const m = (h = this.callbacks) == null ? void 0 : h.onProgress;
            return m && z(t.highWaterMark) ? this.loadProgressively(d, r, e, t.highWaterMark, m) : a ? d.arrayBuffer() : e.responseType === "json" ? d.json() : d.text()
        }
        ).then(d => {
            var h, f;
            const m = this.response;
            if (!m)
                throw new Error("loader destroyed");
            self.clearTimeout(this.requestTimeout),
            r.loading.end = Math.max(self.performance.now(), r.loading.first);
            const p = d[o];
            p && (r.loaded = r.total = p);
            const x = {
                url: m.url,
                data: d,
                code: m.status
            }
              , y = (h = this.callbacks) == null ? void 0 : h.onProgress;
            y && !z(t.highWaterMark) && y(r, e, d, m),
            (f = this.callbacks) == null || f.onSuccess(x, r, e, m)
        }
        ).catch(d => {
            var h;
            if (self.clearTimeout(this.requestTimeout),
            r.aborted)
                return;
            const f = d && d.code || 0
              , m = d ? d.message : null;
            (h = this.callbacks) == null || h.onError({
                code: f,
                text: m
            }, e, d ? d.details : null, r)
        }
        )
    }
    getCacheAge() {
        let e = null;
        if (this.response) {
            const t = this.response.headers.get("age");
            e = t ? parseFloat(t) : null
        }
        return e
    }
    getResponseHeader(e) {
        return this.response ? this.response.headers.get(e) : null
    }
    loadProgressively(e, t, n, r=0, i) {
        const a = new A0
          , o = e.body.getReader()
          , l = () => o.read().then(c => {
            if (c.done)
                return a.dataLength && i(t, n, a.flush().buffer, e),
                Promise.resolve(new ArrayBuffer(0));
            const u = c.value
              , d = u.length;
            return t.loaded += d,
            d < r || a.dataLength ? (a.push(u),
            a.dataLength >= r && i(t, n, a.flush().buffer, e)) : i(t, n, u.buffer, e),
            l()
        }
        ).catch( () => Promise.reject());
        return l()
    }
}
function fA(s, e) {
    const t = {
        method: "GET",
        mode: "cors",
        credentials: "same-origin",
        signal: e,
        headers: new self.Headers(ye({}, s.headers))
    };
    return s.rangeEnd && t.headers.set("Range", "bytes=" + s.rangeStart + "-" + String(s.rangeEnd - 1)),
    t
}
function mA(s) {
    const e = hA.exec(s);
    if (e)
        return parseInt(e[2]) - parseInt(e[1]) + 1
}
function gA(s) {
    const e = s.get("Content-Range");
    if (e) {
        const n = mA(e);
        if (z(n))
            return n
    }
    const t = s.get("Content-Length");
    if (t)
        return parseInt(t)
}
function pA(s, e) {
    return new self.Request(s.url,e)
}
class yA extends Error {
    constructor(e, t, n) {
        super(e),
        this.code = void 0,
        this.details = void 0,
        this.code = t,
        this.details = n
    }
}
const xA = /^age:\s*[\d.]+\s*$/im;
class py {
    constructor(e) {
        this.xhrSetup = void 0,
        this.requestTimeout = void 0,
        this.retryTimeout = void 0,
        this.retryDelay = void 0,
        this.config = null,
        this.callbacks = null,
        this.context = null,
        this.loader = null,
        this.stats = void 0,
        this.xhrSetup = e && e.xhrSetup || null,
        this.stats = new hd,
        this.retryDelay = 0
    }
    destroy() {
        this.callbacks = null,
        this.abortInternal(),
        this.loader = null,
        this.config = null,
        this.context = null,
        this.xhrSetup = null
    }
    abortInternal() {
        const e = this.loader;
        self.clearTimeout(this.requestTimeout),
        self.clearTimeout(this.retryTimeout),
        e && (e.onreadystatechange = null,
        e.onprogress = null,
        e.readyState !== 4 && (this.stats.aborted = !0,
        e.abort()))
    }
    abort() {
        var e;
        this.abortInternal(),
        (e = this.callbacks) != null && e.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
    }
    load(e, t, n) {
        if (this.stats.loading.start)
            throw new Error("Loader can only be used once.");
        this.stats.loading.start = self.performance.now(),
        this.context = e,
        this.config = t,
        this.callbacks = n,
        this.loadInternal()
    }
    loadInternal() {
        const {config: e, context: t} = this;
        if (!e || !t)
            return;
        const n = this.loader = new self.XMLHttpRequest
          , r = this.stats;
        r.loading.first = 0,
        r.loaded = 0,
        r.aborted = !1;
        const i = this.xhrSetup;
        i ? Promise.resolve().then( () => {
            if (!(this.loader !== n || this.stats.aborted))
                return i(n, t.url)
        }
        ).catch(a => {
            if (!(this.loader !== n || this.stats.aborted))
                return n.open("GET", t.url, !0),
                i(n, t.url)
        }
        ).then( () => {
            this.loader !== n || this.stats.aborted || this.openAndSendXhr(n, t, e)
        }
        ).catch(a => {
            var o;
            (o = this.callbacks) == null || o.onError({
                code: n.status,
                text: a.message
            }, t, n, r)
        }
        ) : this.openAndSendXhr(n, t, e)
    }
    openAndSendXhr(e, t, n) {
        e.readyState || e.open("GET", t.url, !0);
        const r = t.headers
          , {maxTimeToFirstByteMs: i, maxLoadTimeMs: a} = n.loadPolicy;
        if (r)
            for (const o in r)
                e.setRequestHeader(o, r[o]);
        t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)),
        e.onreadystatechange = this.readystatechange.bind(this),
        e.onprogress = this.loadprogress.bind(this),
        e.responseType = t.responseType,
        self.clearTimeout(this.requestTimeout),
        n.timeout = i && z(i) ? i : a,
        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), n.timeout),
        e.send()
    }
    readystatechange() {
        const {context: e, loader: t, stats: n} = this;
        if (!e || !t)
            return;
        const r = t.readyState
          , i = this.config;
        if (!n.aborted && r >= 2 && (n.loading.first === 0 && (n.loading.first = Math.max(self.performance.now(), n.loading.start),
        i.timeout !== i.loadPolicy.maxLoadTimeMs && (self.clearTimeout(this.requestTimeout),
        i.timeout = i.loadPolicy.maxLoadTimeMs,
        this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.loadPolicy.maxLoadTimeMs - (n.loading.first - n.loading.start)))),
        r === 4)) {
            self.clearTimeout(this.requestTimeout),
            t.onreadystatechange = null,
            t.onprogress = null;
            const c = t.status
              , u = t.responseType === "text" ? t.responseText : null;
            if (c >= 200 && c < 300) {
                const m = u ?? t.response;
                if (m != null) {
                    var a, o;
                    n.loading.end = Math.max(self.performance.now(), n.loading.first);
                    const p = t.responseType === "arraybuffer" ? m.byteLength : m.length;
                    n.loaded = n.total = p,
                    n.bwEstimate = n.total * 8e3 / (n.loading.end - n.loading.first);
                    const x = (a = this.callbacks) == null ? void 0 : a.onProgress;
                    x && x(n, e, m, t);
                    const y = {
                        url: t.responseURL,
                        data: m,
                        code: c
                    };
                    (o = this.callbacks) == null || o.onSuccess(y, n, e, t);
                    return
                }
            }
            const d = i.loadPolicy.errorRetry
              , h = n.retry
              , f = {
                url: e.url,
                data: void 0,
                code: c
            };
            if (Io(d, h, !1, f))
                this.retry(d);
            else {
                var l;
                fe.error(`${c} while loading ${e.url}`),
                (l = this.callbacks) == null || l.onError({
                    code: c,
                    text: t.statusText
                }, e, t, n)
            }
        }
    }
    loadtimeout() {
        if (!this.config)
            return;
        const e = this.config.loadPolicy.timeoutRetry
          , t = this.stats.retry;
        if (Io(e, t, !0))
            this.retry(e);
        else {
            var n;
            fe.warn(`timeout while loading ${(n = this.context) == null ? void 0 : n.url}`);
            const r = this.callbacks;
            r && (this.abortInternal(),
            r.onTimeout(this.stats, this.context, this.loader))
        }
    }
    retry(e) {
        const {context: t, stats: n} = this;
        this.retryDelay = pd(e, n.retry),
        n.retry++,
        fe.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${t == null ? void 0 : t.url}, retrying ${n.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`),
        this.abortInternal(),
        this.loader = null,
        self.clearTimeout(this.retryTimeout),
        this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay)
    }
    loadprogress(e) {
        const t = this.stats;
        t.loaded = e.loaded,
        e.lengthComputable && (t.total = e.total)
    }
    getCacheAge() {
        let e = null;
        if (this.loader && xA.test(this.loader.getAllResponseHeaders())) {
            const t = this.loader.getResponseHeader("age");
            e = t ? parseFloat(t) : null
        }
        return e
    }
    getResponseHeader(e) {
        return this.loader && new RegExp(`^${e}:\\s*[\\d.]+\\s*$`,"im").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null
    }
}
const vA = {
    maxTimeToFirstByteMs: 8e3,
    maxLoadTimeMs: 2e4,
    timeoutRetry: null,
    errorRetry: null
}
  , EA = pe(pe({
    autoStartLoad: !0,
    startPosition: -1,
    defaultAudioCodec: void 0,
    debug: !1,
    capLevelOnFPSDrop: !1,
    capLevelToPlayerSize: !1,
    ignoreDevicePixelRatio: !1,
    maxDevicePixelRatio: Number.POSITIVE_INFINITY,
    preferManagedMediaSource: !0,
    initialLiveManifestSize: 1,
    maxBufferLength: 30,
    backBufferLength: 1 / 0,
    frontBufferFlushThreshold: 1 / 0,
    startOnSegmentBoundary: !1,
    maxBufferSize: 60 * 1e3 * 1e3,
    maxFragLookUpTolerance: .25,
    maxBufferHole: .1,
    detectStallWithCurrentTimeMs: 1250,
    highBufferWatchdogPeriod: 2,
    nudgeOffset: .1,
    nudgeMaxRetry: 3,
    nudgeOnVideoHole: !0,
    liveSyncMode: "edge",
    liveSyncDurationCount: 3,
    liveSyncOnStallIncrease: 1,
    liveMaxLatencyDurationCount: 1 / 0,
    liveSyncDuration: void 0,
    liveMaxLatencyDuration: void 0,
    maxLiveSyncPlaybackRate: 1,
    liveDurationInfinity: !1,
    liveBackBufferLength: null,
    maxMaxBufferLength: 600,
    enableWorker: !0,
    workerPath: null,
    enableSoftwareAES: !0,
    startLevel: void 0,
    startFragPrefetch: !1,
    fpsDroppedMonitoringPeriod: 5e3,
    fpsDroppedMonitoringThreshold: .2,
    appendErrorMaxRetry: 3,
    ignorePlaylistParsingErrors: !1,
    loader: py,
    fLoader: void 0,
    pLoader: void 0,
    xhrSetup: void 0,
    licenseXhrSetup: void 0,
    licenseResponseCallback: void 0,
    abrController: _T,
    bufferController: LL,
    capLevelController: kd,
    errorController: MT,
    fpsController: LI,
    stretchShortVideoTrack: !1,
    maxAudioFramesDrift: 1,
    forceKeyFrameOnDiscontinuity: !0,
    abrEwmaFastLive: 3,
    abrEwmaSlowLive: 9,
    abrEwmaFastVoD: 3,
    abrEwmaSlowVoD: 9,
    abrEwmaDefaultEstimate: 5e5,
    abrEwmaDefaultEstimateMax: 5e6,
    abrBandWidthFactor: .95,
    abrBandWidthUpFactor: .7,
    abrMaxWithRealBitrate: !1,
    maxStarvationDelay: 4,
    maxLoadingDelay: 4,
    minAutoBitrate: 0,
    emeEnabled: !1,
    widevineLicenseUrl: void 0,
    drmSystems: {},
    drmSystemOptions: {},
    requestMediaKeySystemAccessFunc: g0,
    requireKeySystemAccessOnStart: !1,
    testBandwidth: !0,
    progressive: !1,
    lowLatencyMode: !0,
    cmcd: void 0,
    enableDateRangeMetadataCues: !0,
    enableEmsgMetadataCues: !0,
    enableEmsgKLVMetadata: !1,
    enableID3MetadataCues: !0,
    enableInterstitialPlayback: !0,
    interstitialAppendInPlace: !0,
    interstitialLiveLookAhead: 10,
    useMediaCapabilities: !0,
    preserveManualLevelOnError: !1,
    certLoadPolicy: {
        default: vA
    },
    keyLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 8e3,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 2e4,
                backoff: "linear"
            },
            errorRetry: {
                maxNumRetry: 8,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 2e4,
                backoff: "linear"
            }
        }
    },
    manifestLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1 / 0,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    playlistLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 2,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    fragLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 12e4,
            timeoutRetry: {
                maxNumRetry: 4,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 6,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    steeringManifestLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 2e4,
            timeoutRetry: {
                maxNumRetry: 2,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 1,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    interstitialAssetListLoadPolicy: {
        default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 3e4,
            timeoutRetry: {
                maxNumRetry: 0,
                retryDelayMs: 0,
                maxRetryDelayMs: 0
            },
            errorRetry: {
                maxNumRetry: 0,
                retryDelayMs: 1e3,
                maxRetryDelayMs: 8e3
            }
        }
    },
    manifestLoadingTimeOut: 1e4,
    manifestLoadingMaxRetry: 1,
    manifestLoadingRetryDelay: 1e3,
    manifestLoadingMaxRetryTimeout: 64e3,
    levelLoadingTimeOut: 1e4,
    levelLoadingMaxRetry: 4,
    levelLoadingRetryDelay: 1e3,
    levelLoadingMaxRetryTimeout: 64e3,
    fragLoadingTimeOut: 2e4,
    fragLoadingMaxRetry: 6,
    fragLoadingRetryDelay: 1e3,
    fragLoadingMaxRetryTimeout: 64e3
}, SA()), {}, {
    subtitleStreamController: OI,
    subtitleTrackController: bI,
    timelineController: oA,
    audioStreamController: vL,
    audioTrackController: EL,
    emeController: mr,
    cmcdController: EI,
    contentSteeringController: TI,
    interstitialsController: NI
});
function SA() {
    return {
        cueHandler: uA,
        enableWebVTT: !0,
        enableIMSC1: !0,
        enableCEA708Captions: !0,
        captionsTextTrack1Label: "English",
        captionsTextTrack1LanguageCode: "en",
        captionsTextTrack2Label: "Spanish",
        captionsTextTrack2LanguageCode: "es",
        captionsTextTrack3Label: "Unknown CC",
        captionsTextTrack3LanguageCode: "",
        captionsTextTrack4Label: "Unknown CC",
        captionsTextTrack4LanguageCode: "",
        renderTextTracksNatively: !0
    }
}
function TA(s, e, t) {
    if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration))
        throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
    if (e.liveMaxLatencyDurationCount !== void 0 && (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount))
        throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
    if (e.liveMaxLatencyDuration !== void 0 && (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration <= e.liveSyncDuration))
        throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
    const n = uu(s)
      , r = ["manifest", "level", "frag"]
      , i = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
    return r.forEach(a => {
        const o = `${a === "level" ? "playlist" : a}LoadPolicy`
          , l = e[o] === void 0
          , c = [];
        i.forEach(u => {
            const d = `${a}Loading${u}`
              , h = e[d];
            if (h !== void 0 && l) {
                c.push(d);
                const f = n[o].default;
                switch (e[o] = {
                    default: f
                },
                u) {
                case "TimeOut":
                    f.maxLoadTimeMs = h,
                    f.maxTimeToFirstByteMs = h;
                    break;
                case "MaxRetry":
                    f.errorRetry.maxNumRetry = h,
                    f.timeoutRetry.maxNumRetry = h;
                    break;
                case "RetryDelay":
                    f.errorRetry.retryDelayMs = h,
                    f.timeoutRetry.retryDelayMs = h;
                    break;
                case "MaxRetryTimeout":
                    f.errorRetry.maxRetryDelayMs = h,
                    f.timeoutRetry.maxRetryDelayMs = h;
                    break
                }
            }
        }
        ),
        c.length && t.warn(`hls.js config: "${c.join('", "')}" setting(s) are deprecated, use "${o}": ${Te(e[o])}`)
    }
    ),
    pe(pe({}, n), e)
}
function uu(s) {
    return s && typeof s == "object" ? Array.isArray(s) ? s.map(uu) : Object.keys(s).reduce( (e, t) => (e[t] = uu(s[t]),
    e), {}) : s
}
function LA(s, e) {
    const t = s.loader;
    t !== cm && t !== py ? (e.log("[config]: Custom loader detected, cannot enable progressive streaming"),
    s.progressive = !1) : dA() && (s.loader = cm,
    s.progressive = !0,
    s.enableSoftwareAES = !0,
    e.log("[config]: Progressive streaming enabled, using FetchLoader"))
}
const Va = 2
  , IA = .1
  , AA = .05
  , bA = 100;
class RA extends d0 {
    constructor(e, t) {
        super("gap-controller", e.logger),
        this.hls = void 0,
        this.fragmentTracker = void 0,
        this.media = null,
        this.mediaSource = void 0,
        this.nudgeRetry = 0,
        this.stallReported = !1,
        this.stalled = null,
        this.moved = !1,
        this.seeking = !1,
        this.buffered = {},
        this.lastCurrentTime = 0,
        this.ended = 0,
        this.waiting = 0,
        this.onMediaPlaying = () => {
            this.ended = 0,
            this.waiting = 0
        }
        ,
        this.onMediaWaiting = () => {
            var n;
            (n = this.media) != null && n.seeking || (this.waiting = self.performance.now(),
            this.tick())
        }
        ,
        this.onMediaEnded = () => {
            if (this.hls) {
                var n;
                this.ended = ((n = this.media) == null ? void 0 : n.currentTime) || 1,
                this.hls.trigger(S.MEDIA_ENDED, {
                    stalled: !1
                })
            }
        }
        ,
        this.hls = e,
        this.fragmentTracker = t,
        this.registerListeners()
    }
    registerListeners() {
        const {hls: e} = this;
        e && (e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(S.BUFFER_APPENDED, this.onBufferAppended, this))
    }
    unregisterListeners() {
        const {hls: e} = this;
        e && (e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(S.BUFFER_APPENDED, this.onBufferAppended, this))
    }
    destroy() {
        super.destroy(),
        this.unregisterListeners(),
        this.media = this.hls = this.fragmentTracker = null,
        this.mediaSource = void 0
    }
    onMediaAttached(e, t) {
        this.setInterval(bA),
        this.mediaSource = t.mediaSource;
        const n = this.media = t.media;
        lt(n, "playing", this.onMediaPlaying),
        lt(n, "waiting", this.onMediaWaiting),
        lt(n, "ended", this.onMediaEnded)
    }
    onMediaDetaching(e, t) {
        this.clearInterval();
        const {media: n} = this;
        n && (yt(n, "playing", this.onMediaPlaying),
        yt(n, "waiting", this.onMediaWaiting),
        yt(n, "ended", this.onMediaEnded),
        this.media = null),
        this.mediaSource = void 0
    }
    onBufferAppended(e, t) {
        this.buffered = t.timeRanges
    }
    get hasBuffered() {
        return Object.keys(this.buffered).length > 0
    }
    tick() {
        var e;
        if (!((e = this.media) != null && e.readyState) || !this.hasBuffered)
            return;
        const t = this.media.currentTime;
        this.poll(t, this.lastCurrentTime),
        this.lastCurrentTime = t
    }
    poll(e, t) {
        var n, r;
        const i = (n = this.hls) == null ? void 0 : n.config;
        if (!i)
            return;
        const a = this.media;
        if (!a)
            return;
        const {seeking: o} = a
          , l = this.seeking && !o
          , c = !this.seeking && o
          , u = a.paused && !o || a.ended || a.playbackRate === 0;
        if (this.seeking = o,
        e !== t) {
            t && (this.ended = 0),
            this.moved = !0,
            o || (this.nudgeRetry = 0,
            i.nudgeOnVideoHole && !u && e > t && this.nudgeOnVideoHole(e, t)),
            this.waiting === 0 && this.stallResolved(e);
            return
        }
        if (c || l) {
            l && this.stallResolved(e);
            return
        }
        if (u) {
            this.nudgeRetry = 0,
            this.stallResolved(e),
            !this.ended && a.ended && this.hls && (this.ended = e || 1,
            this.hls.trigger(S.MEDIA_ENDED, {
                stalled: !1
            }));
            return
        }
        if (!ie.getBuffered(a).length) {
            this.nudgeRetry = 0;
            return
        }
        const d = ie.bufferInfo(a, e, 0)
          , h = d.nextStart || 0
          , f = this.fragmentTracker;
        if (o && f && this.hls) {
            const R = um(this.hls.inFlightFragments, e)
              , I = d.len > Va
              , A = !h || R || h - e > Va && !f.getPartialFragment(e);
            if (I || A)
                return;
            this.moved = !1
        }
        const m = (r = this.hls) == null ? void 0 : r.latestLevelDetails;
        if (!this.moved && this.stalled !== null && f) {
            if (!(d.len > 0) && !h)
                return;
            const I = Math.max(h, d.start || 0) - e
              , C = !!(m != null && m.live) ? m.targetduration * 2 : Va
              , b = Ea(e, f);
            if (I > 0 && (I <= C || b)) {
                a.paused || this._trySkipBufferHole(b);
                return
            }
        }
        const p = i.detectStallWithCurrentTimeMs
          , x = self.performance.now()
          , y = this.waiting;
        let v = this.stalled;
        if (v === null)
            if (y > 0 && x - y < p)
                v = this.stalled = y;
            else {
                this.stalled = x;
                return
            }
        const E = x - v;
        if (!o && (E >= p || y) && this.hls) {
            var T;
            if (((T = this.mediaSource) == null ? void 0 : T.readyState) === "ended" && !(m != null && m.live) && Math.abs(e - ((m == null ? void 0 : m.edge) || 0)) < 1) {
                if (this.ended)
                    return;
                this.ended = e || 1,
                this.hls.trigger(S.MEDIA_ENDED, {
                    stalled: !0
                });
                return
            }
            if (this._reportStall(d),
            !this.media || !this.hls)
                return
        }
        const L = ie.bufferInfo(a, e, i.maxBufferHole);
        this._tryFixBufferStall(L, E, e)
    }
    stallResolved(e) {
        const t = this.stalled;
        if (t && this.hls && (this.stalled = null,
        this.stallReported)) {
            const n = self.performance.now() - t;
            this.log(`playback not stuck anymore @${e}, after ${Math.round(n)}ms`),
            this.stallReported = !1,
            this.waiting = 0,
            this.hls.trigger(S.STALL_RESOLVED, {})
        }
    }
    nudgeOnVideoHole(e, t) {
        var n;
        const r = this.buffered.video;
        if (this.hls && this.media && this.fragmentTracker && (n = this.buffered.audio) != null && n.length && r && r.length > 1 && e > r.end(0)) {
            const i = ie.bufferedInfo(ie.timeRangesToArray(this.buffered.audio), e, 0);
            if (i.len > 1 && t >= i.start) {
                const a = ie.timeRangesToArray(r)
                  , o = ie.bufferedInfo(a, t, 0).bufferedIndex;
                if (o > -1 && o < a.length - 1) {
                    const l = ie.bufferedInfo(a, e, 0).bufferedIndex
                      , c = a[o].end
                      , u = a[o + 1].start;
                    if ((l === -1 || l > o) && u - c < 1 && e - c < 2) {
                        const d = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${e} hole: ${c} -> ${u} buffered index: ${l}`);
                        this.warn(d.message),
                        this.media.currentTime += 1e-6;
                        let h = Ea(e, this.fragmentTracker);
                        h && "fragment"in h ? h = h.fragment : h || (h = void 0);
                        const f = ie.bufferInfo(this.media, e, 0);
                        this.hls.trigger(S.ERROR, {
                            type: q.MEDIA_ERROR,
                            details: N.BUFFER_SEEK_OVER_HOLE,
                            fatal: !1,
                            error: d,
                            reason: d.message,
                            frag: h,
                            buffer: f.len,
                            bufferInfo: f
                        })
                    }
                }
            }
        }
    }
    _tryFixBufferStall(e, t, n) {
        var r, i;
        const {fragmentTracker: a, media: o} = this
          , l = (r = this.hls) == null ? void 0 : r.config;
        if (!o || !a || !l)
            return;
        const c = (i = this.hls) == null ? void 0 : i.latestLevelDetails
          , u = Ea(n, a);
        if ((u || c != null && c.live && n < c.fragmentStart) && (this._trySkipBufferHole(u) || !this.media))
            return;
        const d = e.buffered
          , h = this.adjacentTraversal(e, n);
        (d && d.length > 1 && e.len > l.maxBufferHole || e.nextStart && (e.nextStart - n < l.maxBufferHole || h)) && (t > l.highBufferWatchdogPeriod * 1e3 || this.waiting) && (this.warn("Trying to nudge playhead over buffer-hole"),
        this._tryNudgeBuffer(e))
    }
    adjacentTraversal(e, t) {
        const n = this.fragmentTracker
          , r = e.nextStart;
        if (n && r) {
            const i = n.getFragAtPos(t, X.MAIN)
              , a = n.getFragAtPos(r, X.MAIN);
            if (i && a)
                return a.sn - i.sn < 2
        }
        return !1
    }
    _reportStall(e) {
        const {hls: t, media: n, stallReported: r, stalled: i} = this;
        if (!r && i !== null && n && t) {
            this.stallReported = !0;
            const a = new Error(`Playback stalling at @${n.currentTime} due to low buffer (${Te(e)})`);
            this.warn(a.message),
            t.trigger(S.ERROR, {
                type: q.MEDIA_ERROR,
                details: N.BUFFER_STALLED_ERROR,
                fatal: !1,
                error: a,
                buffer: e.len,
                bufferInfo: e,
                stalled: {
                    start: i
                }
            })
        }
    }
    _trySkipBufferHole(e) {
        var t;
        const {fragmentTracker: n, media: r} = this
          , i = (t = this.hls) == null ? void 0 : t.config;
        if (!r || !n || !i)
            return 0;
        const a = r.currentTime
          , o = ie.bufferInfo(r, a, 0)
          , l = a < o.start ? o.start : o.nextStart;
        if (l && this.hls) {
            const u = o.len <= i.maxBufferHole
              , d = o.len > 0 && o.len < 1 && r.readyState < 3
              , h = l - a;
            if (h > 0 && (u || d)) {
                if (h > i.maxBufferHole) {
                    let m = !1;
                    if (a === 0) {
                        const p = n.getAppendedFrag(0, X.MAIN);
                        p && l < p.end && (m = !0)
                    }
                    if (!m && e) {
                        var c;
                        if (!((c = this.hls.loadLevelObj) != null && c.details) || um(this.hls.inFlightFragments, l))
                            return 0;
                        let x = !1
                          , y = e.end;
                        for (; y < l; ) {
                            const v = Ea(y, n);
                            if (v)
                                y += v.duration;
                            else {
                                x = !0;
                                break
                            }
                        }
                        if (x)
                            return 0
                    }
                }
                const f = Math.max(l + AA, a + IA);
                if (this.warn(`skipping hole, adjusting currentTime from ${a} to ${f}`),
                this.moved = !0,
                r.currentTime = f,
                !(e != null && e.gap)) {
                    const m = new Error(`fragment loaded with buffer holes, seeking from ${a} to ${f}`)
                      , p = {
                        type: q.MEDIA_ERROR,
                        details: N.BUFFER_SEEK_OVER_HOLE,
                        fatal: !1,
                        error: m,
                        reason: m.message,
                        buffer: o.len,
                        bufferInfo: o
                    };
                    e && ("fragment"in e ? p.part = e : p.frag = e),
                    this.hls.trigger(S.ERROR, p)
                }
                return f
            }
        }
        return 0
    }
    _tryNudgeBuffer(e) {
        const {hls: t, media: n, nudgeRetry: r} = this
          , i = t == null ? void 0 : t.config;
        if (!n || !i)
            return 0;
        const a = n.currentTime;
        if (this.nudgeRetry++,
        r < i.nudgeMaxRetry) {
            const o = a + (r + 1) * i.nudgeOffset
              , l = new Error(`Nudging 'currentTime' from ${a} to ${o}`);
            this.warn(l.message),
            n.currentTime = o,
            t.trigger(S.ERROR, {
                type: q.MEDIA_ERROR,
                details: N.BUFFER_NUDGE_ON_STALL,
                error: l,
                fatal: !1,
                buffer: e.len,
                bufferInfo: e
            })
        } else {
            const o = new Error(`Playhead still not moving while enough data buffered @${a} after ${i.nudgeMaxRetry} nudges`);
            this.error(o.message),
            t.trigger(S.ERROR, {
                type: q.MEDIA_ERROR,
                details: N.BUFFER_STALLED_ERROR,
                error: o,
                fatal: !0,
                buffer: e.len,
                bufferInfo: e
            })
        }
    }
}
function um(s, e) {
    const t = dm(s.main);
    if (t && t.start <= e)
        return t;
    const n = dm(s.audio);
    return n && n.start <= e ? n : null
}
function dm(s) {
    if (!s)
        return null;
    switch (s.state) {
    case U.IDLE:
    case U.STOPPED:
    case U.ENDED:
    case U.ERROR:
        return null
    }
    return s.frag
}
function Ea(s, e) {
    return e.getAppendedFrag(s, X.MAIN) || e.getPartialFragment(s)
}
const wA = .25;
function du() {
    if (!(typeof self > "u"))
        return self.VTTCue || self.TextTrackCue
}
function Xl(s, e, t, n, r) {
    let i = new s(e,t,"");
    try {
        i.value = n,
        r && (i.type = r)
    } catch {
        i = new s(e,t,Te(r ? pe({
            type: r
        }, n) : n))
    }
    return i
}
const Sa = ( () => {
    const s = du();
    try {
        s && new s(0,Number.POSITIVE_INFINITY,"")
    } catch {
        return Number.MAX_VALUE
    }
    return Number.POSITIVE_INFINITY
}
)();
class CA {
    constructor(e) {
        this.hls = void 0,
        this.id3Track = null,
        this.media = null,
        this.dateRangeCuesAppended = {},
        this.removeCues = !0,
        this.assetCue = void 0,
        this.onEventCueEnter = () => {
            this.hls && this.hls.trigger(S.EVENT_CUE_ENTER, {})
        }
        ,
        this.hls = e,
        this._registerListeners()
    }
    destroy() {
        this._unregisterListeners(),
        this.id3Track = null,
        this.media = null,
        this.dateRangeCuesAppended = {},
        this.hls = this.onEventCueEnter = null
    }
    _registerListeners() {
        const {hls: e} = this;
        e && (e.on(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
        e.on(S.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.on(S.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.on(S.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this))
    }
    _unregisterListeners() {
        const {hls: e} = this;
        e && (e.off(S.MEDIA_ATTACHING, this.onMediaAttaching, this),
        e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this),
        e.off(S.BUFFER_FLUSHING, this.onBufferFlushing, this),
        e.off(S.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.off(S.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this))
    }
    onMediaAttaching(e, t) {
        var n;
        this.media = t.media,
        ((n = t.overrides) == null ? void 0 : n.cueRemoval) === !1 && (this.removeCues = !1)
    }
    onMediaAttached() {
        var e;
        const t = (e = this.hls) == null ? void 0 : e.latestLevelDetails;
        t && this.updateDateRangeCues(t)
    }
    onMediaDetaching(e, t) {
        this.media = null,
        !t.transferMedia && (this.id3Track && (this.removeCues && nr(this.id3Track, this.onEventCueEnter),
        this.id3Track = null),
        this.dateRangeCuesAppended = {})
    }
    onManifestLoading() {
        this.dateRangeCuesAppended = {}
    }
    createTrack(e) {
        const t = this.getID3Track(e.textTracks);
        return t.mode = "hidden",
        t
    }
    getID3Track(e) {
        if (this.media) {
            for (let t = 0; t < e.length; t++) {
                const n = e[t];
                if (n.kind === "metadata" && n.label === "id3")
                    return ry(n, this.media),
                    n
            }
            return this.media.addTextTrack("metadata", "id3")
        }
    }
    onFragParsingMetadata(e, t) {
        if (!this.media || !this.hls)
            return;
        const {enableEmsgMetadataCues: n, enableID3MetadataCues: r} = this.hls.config;
        if (!n && !r)
            return;
        const {samples: i} = t;
        this.id3Track || (this.id3Track = this.createTrack(this.media));
        const a = du();
        if (a)
            for (let o = 0; o < i.length; o++) {
                const l = i[o].type;
                if (l === At.emsg && !n || !r)
                    continue;
                const c = D0(i[o].data)
                  , u = i[o].pts;
                let d = u + i[o].duration;
                d > Sa && (d = Sa),
                d - u <= 0 && (d = u + wA);
                for (let f = 0; f < c.length; f++) {
                    const m = c[f];
                    if (!P0(m)) {
                        this.updateId3CueEnds(u, l);
                        const p = Xl(a, u, d, m, l);
                        p && this.id3Track.addCue(p)
                    }
                }
            }
    }
    updateId3CueEnds(e, t) {
        var n;
        const r = (n = this.id3Track) == null ? void 0 : n.cues;
        if (r)
            for (let i = r.length; i--; ) {
                const a = r[i];
                a.type === t && a.startTime < e && a.endTime === Sa && (a.endTime = e)
            }
    }
    onBufferFlushing(e, {startOffset: t, endOffset: n, type: r}) {
        const {id3Track: i, hls: a} = this;
        if (!a)
            return;
        const {config: {enableEmsgMetadataCues: o, enableID3MetadataCues: l}} = a;
        if (i && (o || l)) {
            let c;
            r === "audio" ? c = u => u.type === At.audioId3 && l : r === "video" ? c = u => u.type === At.emsg && o : c = u => u.type === At.audioId3 && l || u.type === At.emsg && o,
            lu(i, t, n, c)
        }
    }
    onLevelUpdated(e, {details: t}) {
        this.updateDateRangeCues(t, !0)
    }
    onLevelPtsUpdated(e, t) {
        Math.abs(t.drift) > .01 && this.updateDateRangeCues(t.details)
    }
    updateDateRangeCues(e, t) {
        if (!this.hls || !this.media)
            return;
        const {assetPlayerId: n, timelineOffset: r, enableDateRangeMetadataCues: i, interstitialsController: a} = this.hls.config;
        if (!i)
            return;
        const o = du();
        if (n && r && !a) {
            const {fragmentStart: p, fragmentEnd: x} = e;
            let y = this.assetCue;
            y ? (y.startTime = p,
            y.endTime = x) : o && (y = this.assetCue = Xl(o, p, x, {
                assetPlayerId: this.hls.config.assetPlayerId
            }, "hlsjs.interstitial.asset"),
            y && (y.id = n,
            this.id3Track || (this.id3Track = this.createTrack(this.media)),
            this.id3Track.addCue(y),
            y.addEventListener("enter", this.onEventCueEnter)))
        }
        if (!e.hasProgramDateTime)
            return;
        const {id3Track: l} = this
          , {dateRanges: c} = e
          , u = Object.keys(c);
        let d = this.dateRangeCuesAppended;
        if (l && t) {
            var h;
            if ((h = l.cues) != null && h.length) {
                const p = Object.keys(d).filter(x => !u.includes(x));
                for (let x = p.length; x--; ) {
                    var f;
                    const y = p[x]
                      , v = (f = d[y]) == null ? void 0 : f.cues;
                    delete d[y],
                    v && Object.keys(v).forEach(E => {
                        const T = v[E];
                        if (T) {
                            T.removeEventListener("enter", this.onEventCueEnter);
                            try {
                                l.removeCue(T)
                            } catch {}
                        }
                    }
                    )
                }
            } else
                d = this.dateRangeCuesAppended = {}
        }
        const m = e.fragments[e.fragments.length - 1];
        if (!(u.length === 0 || !z(m == null ? void 0 : m.programDateTime))) {
            this.id3Track || (this.id3Track = this.createTrack(this.media));
            for (let p = 0; p < u.length; p++) {
                const x = u[p]
                  , y = c[x]
                  , v = y.startTime
                  , E = d[x]
                  , T = (E == null ? void 0 : E.cues) || {};
                let L = (E == null ? void 0 : E.durationKnown) || !1
                  , R = Sa;
                const {duration: I, endDate: A} = y;
                if (A && I !== null)
                    R = v + I,
                    L = !0;
                else if (y.endOnNext && !L) {
                    const b = u.reduce( (O, _) => {
                        if (_ !== y.id) {
                            const $ = c[_];
                            if ($.class === y.class && $.startDate > y.startDate && (!O || y.startDate < O.startDate))
                                return $
                        }
                        return O
                    }
                    , null);
                    b && (R = b.startTime,
                    L = !0)
                }
                const C = Object.keys(y.attr);
                for (let b = 0; b < C.length; b++) {
                    const O = C[b];
                    if (!XT(O))
                        continue;
                    const _ = T[O];
                    if (_)
                        L && !(E != null && E.durationKnown) ? _.endTime = R : Math.abs(_.startTime - v) > .01 && (_.startTime = v,
                        _.endTime = R);
                    else if (o) {
                        let $ = y.attr[O];
                        ZT(O) && ($ = Yp($));
                        const W = Xl(o, v, R, {
                            key: O,
                            data: $
                        }, At.dateRange);
                        W && (W.id = x,
                        this.id3Track.addCue(W),
                        T[O] = W,
                        a && (O === "X-ASSET-LIST" || O === "X-ASSET-URL") && W.addEventListener("enter", this.onEventCueEnter))
                    }
                }
                d[x] = {
                    cues: T,
                    dateRange: y,
                    durationKnown: L
                }
            }
        }
    }
}
class kA {
    constructor(e) {
        this.hls = void 0,
        this.config = void 0,
        this.media = null,
        this.currentTime = 0,
        this.stallCount = 0,
        this._latency = null,
        this._targetLatencyUpdated = !1,
        this.onTimeupdate = () => {
            const {media: t} = this
              , n = this.levelDetails;
            if (!t || !n)
                return;
            this.currentTime = t.currentTime;
            const r = this.computeLatency();
            if (r === null)
                return;
            this._latency = r;
            const {lowLatencyMode: i, maxLiveSyncPlaybackRate: a} = this.config;
            if (!i || a === 1 || !n.live)
                return;
            const o = this.targetLatency;
            if (o === null)
                return;
            const l = r - o
              , c = Math.min(this.maxLatency, o + n.targetduration);
            if (l < c && l > .05 && this.forwardBufferLength > 1) {
                const d = Math.min(2, Math.max(1, a))
                  , h = Math.round(2 / (1 + Math.exp(-.75 * l - this.edgeStalled)) * 20) / 20
                  , f = Math.min(d, Math.max(1, h));
                this.changeMediaPlaybackRate(t, f)
            } else
                t.playbackRate !== 1 && t.playbackRate !== 0 && this.changeMediaPlaybackRate(t, 1)
        }
        ,
        this.hls = e,
        this.config = e.config,
        this.registerListeners()
    }
    get levelDetails() {
        var e;
        return ((e = this.hls) == null ? void 0 : e.latestLevelDetails) || null
    }
    get latency() {
        return this._latency || 0
    }
    get maxLatency() {
        const {config: e} = this;
        if (e.liveMaxLatencyDuration !== void 0)
            return e.liveMaxLatencyDuration;
        const t = this.levelDetails;
        return t ? e.liveMaxLatencyDurationCount * t.targetduration : 0
    }
    get targetLatency() {
        const e = this.levelDetails;
        if (e === null || this.hls === null)
            return null;
        const {holdBack: t, partHoldBack: n, targetduration: r} = e
          , {liveSyncDuration: i, liveSyncDurationCount: a, lowLatencyMode: o} = this.config
          , l = this.hls.userConfig;
        let c = o && n || t;
        (this._targetLatencyUpdated || l.liveSyncDuration || l.liveSyncDurationCount || c === 0) && (c = i !== void 0 ? i : a * r);
        const u = r;
        return c + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, u)
    }
    set targetLatency(e) {
        this.stallCount = 0,
        this.config.liveSyncDuration = e,
        this._targetLatencyUpdated = !0
    }
    get liveSyncPosition() {
        const e = this.estimateLiveEdge()
          , t = this.targetLatency;
        if (e === null || t === null)
            return null;
        const n = this.levelDetails;
        if (n === null)
            return null;
        const r = n.edge
          , i = e - t - this.edgeStalled
          , a = r - n.totalduration
          , o = r - (this.config.lowLatencyMode && n.partTarget || n.targetduration);
        return Math.min(Math.max(a, i), o)
    }
    get drift() {
        const e = this.levelDetails;
        return e === null ? 1 : e.drift
    }
    get edgeStalled() {
        const e = this.levelDetails;
        if (e === null)
            return 0;
        const t = (this.config.lowLatencyMode && e.partTarget || e.targetduration) * 3;
        return Math.max(e.age - t, 0)
    }
    get forwardBufferLength() {
        const {media: e} = this
          , t = this.levelDetails;
        if (!e || !t)
            return 0;
        const n = e.buffered.length;
        return (n ? e.buffered.end(n - 1) : t.edge) - this.currentTime
    }
    destroy() {
        this.unregisterListeners(),
        this.onMediaDetaching(),
        this.hls = null
    }
    registerListeners() {
        const {hls: e} = this;
        e && (e.on(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.on(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.on(S.ERROR, this.onError, this))
    }
    unregisterListeners() {
        const {hls: e} = this;
        e && (e.off(S.MEDIA_ATTACHED, this.onMediaAttached, this),
        e.off(S.MEDIA_DETACHING, this.onMediaDetaching, this),
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.LEVEL_UPDATED, this.onLevelUpdated, this),
        e.off(S.ERROR, this.onError, this))
    }
    onMediaAttached(e, t) {
        this.media = t.media,
        this.media.addEventListener("timeupdate", this.onTimeupdate)
    }
    onMediaDetaching() {
        this.media && (this.media.removeEventListener("timeupdate", this.onTimeupdate),
        this.media = null)
    }
    onManifestLoading() {
        this._latency = null,
        this.stallCount = 0
    }
    onLevelUpdated(e, {details: t}) {
        t.advanced && this.onTimeupdate(),
        !t.live && this.media && this.media.removeEventListener("timeupdate", this.onTimeupdate)
    }
    onError(e, t) {
        var n;
        t.details === N.BUFFER_STALLED_ERROR && (this.stallCount++,
        this.hls && (n = this.levelDetails) != null && n.live && this.hls.logger.warn("[latency-controller]: Stall detected, adjusting target latency"))
    }
    changeMediaPlaybackRate(e, t) {
        var n, r;
        e.playbackRate !== t && ((n = this.hls) == null || n.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(r = this.targetLatency) == null ? void 0 : r.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${e.playbackRate} to ${t}`),
        e.playbackRate = t)
    }
    estimateLiveEdge() {
        const e = this.levelDetails;
        return e === null ? null : e.edge + e.age
    }
    computeLatency() {
        const e = this.estimateLiveEdge();
        return e === null ? null : e - this.currentTime
    }
}
class _A extends Cd {
    constructor(e, t) {
        super(e, "level-controller"),
        this._levels = [],
        this._firstLevel = -1,
        this._maxAutoLevel = -1,
        this._startLevel = void 0,
        this.currentLevel = null,
        this.currentLevelIndex = -1,
        this.manualLevelIndex = -1,
        this.steering = void 0,
        this.onParsedComplete = void 0,
        this.steering = t,
        this._registerListeners()
    }
    _registerListeners() {
        const {hls: e} = this;
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.on(S.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(S.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(S.FRAG_BUFFERED, this.onFragBuffered, this),
        e.on(S.ERROR, this.onError, this)
    }
    _unregisterListeners() {
        const {hls: e} = this;
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.MANIFEST_LOADED, this.onManifestLoaded, this),
        e.off(S.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(S.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(S.FRAG_BUFFERED, this.onFragBuffered, this),
        e.off(S.ERROR, this.onError, this)
    }
    destroy() {
        this._unregisterListeners(),
        this.steering = null,
        this.resetLevels(),
        super.destroy()
    }
    stopLoad() {
        this._levels.forEach(t => {
            t.loadError = 0,
            t.fragmentError = 0
        }
        ),
        super.stopLoad()
    }
    resetLevels() {
        this._startLevel = void 0,
        this.manualLevelIndex = -1,
        this.currentLevelIndex = -1,
        this.currentLevel = null,
        this._levels = [],
        this._maxAutoLevel = -1
    }
    onManifestLoading(e, t) {
        this.resetLevels()
    }
    onManifestLoaded(e, t) {
        const n = this.hls.config.preferManagedMediaSource
          , r = []
          , i = {}
          , a = {};
        let o = !1
          , l = !1
          , c = !1;
        t.levels.forEach(u => {
            const d = u.attrs;
            let {audioCodec: h, videoCodec: f} = u;
            h && (u.audioCodec = h = Eo(h, n) || void 0),
            f && (f = u.videoCodec = hT(f));
            const {width: m, height: p, unknownCodecs: x} = u;
            let y = x ? x.length : 0;
            if (x)
                for (let b = y; b--; ) {
                    const O = x[b];
                    this.isAudioSupported(O) ? (u.audioCodec = h = h ? `${h},${O}` : O,
                    y--,
                    Lr.audio[h.substring(0, 4)] = 2) : this.isVideoSupported(O) && (u.videoCodec = f = f ? `${f},${O}` : O,
                    y--,
                    Lr.video[f.substring(0, 4)] = 2)
                }
            if (o || (o = !!(m && p)),
            l || (l = !!f),
            c || (c = !!h),
            y || h && !this.isAudioSupported(h) || f && !this.isVideoSupported(f)) {
                this.log(`Some or all CODECS not supported "${d.CODECS}"`);
                return
            }
            const {CODECS: v, "FRAME-RATE": E, "HDCP-LEVEL": T, "PATHWAY-ID": L, RESOLUTION: R, "VIDEO-RANGE": I} = d
              , C = `${`${L || "."}-`}${u.bitrate}-${R}-${E}-${v}-${I}-${T}`;
            if (i[C])
                if (i[C].uri !== u.url && !u.attrs["PATHWAY-ID"]) {
                    const b = a[C] += 1;
                    u.attrs["PATHWAY-ID"] = new Array(b + 1).join(".");
                    const O = this.createLevel(u);
                    i[C] = O,
                    r.push(O)
                } else
                    i[C].addGroupId("audio", d.AUDIO),
                    i[C].addGroupId("text", d.SUBTITLES);
            else {
                const b = this.createLevel(u);
                i[C] = b,
                a[C] = 1,
                r.push(b)
            }
        }
        ),
        this.filterAndSortMediaOptions(r, t, o, l, c)
    }
    createLevel(e) {
        const t = new bi(e)
          , n = e.supplemental;
        if (n != null && n.videoCodec && !this.isVideoSupported(n.videoCodec)) {
            const r = new Error(`SUPPLEMENTAL-CODECS not supported "${n.videoCodec}"`);
            this.log(r.message),
            t.supportedResult = i0(r, [])
        }
        return t
    }
    isAudioSupported(e) {
        return Yc(e, "audio", this.hls.config.preferManagedMediaSource)
    }
    isVideoSupported(e) {
        return Yc(e, "video", this.hls.config.preferManagedMediaSource)
    }
    filterAndSortMediaOptions(e, t, n, r, i) {
        let a = []
          , o = []
          , l = e;
        if ((n || r) && i && (l = l.filter( ({videoCodec: x, videoRange: y, width: v, height: E}) => (!!x || !!(v && E)) && TT(y))),
        l.length === 0) {
            Promise.resolve().then( () => {
                if (this.hls) {
                    let x = "no level with compatible codecs found in manifest"
                      , y = x;
                    t.levels.length && (y = `one or more CODECS in variant not supported: ${Te(t.levels.map(E => E.attrs.CODECS).filter( (E, T, L) => L.indexOf(E) === T))}`,
                    this.warn(y),
                    x += ` (${y})`);
                    const v = new Error(x);
                    this.hls.trigger(S.ERROR, {
                        type: q.MEDIA_ERROR,
                        details: N.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                        fatal: !0,
                        url: t.url,
                        error: v,
                        reason: y
                    })
                }
            }
            );
            return
        }
        t.audioTracks && (a = t.audioTracks.filter(x => !x.audioCodec || this.isAudioSupported(x.audioCodec)),
        hm(a)),
        t.subtitles && (o = t.subtitles,
        hm(o));
        const c = l.slice(0);
        l.sort( (x, y) => {
            if (x.attrs["HDCP-LEVEL"] !== y.attrs["HDCP-LEVEL"])
                return (x.attrs["HDCP-LEVEL"] || "") > (y.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
            if (n && x.height !== y.height)
                return x.height - y.height;
            if (x.frameRate !== y.frameRate)
                return x.frameRate - y.frameRate;
            if (x.videoRange !== y.videoRange)
                return So.indexOf(x.videoRange) - So.indexOf(y.videoRange);
            if (x.videoCodec !== y.videoCodec) {
                const v = rf(x.videoCodec)
                  , E = rf(y.videoCodec);
                if (v !== E)
                    return E - v
            }
            if (x.uri === y.uri && x.codecSet !== y.codecSet) {
                const v = vo(x.codecSet)
                  , E = vo(y.codecSet);
                if (v !== E)
                    return E - v
            }
            return x.averageBitrate !== y.averageBitrate ? x.averageBitrate - y.averageBitrate : 0
        }
        );
        let u = c[0];
        if (this.steering && (l = this.steering.filterParsedLevels(l),
        l.length !== c.length)) {
            for (let x = 0; x < c.length; x++)
                if (c[x].pathwayId === l[0].pathwayId) {
                    u = c[x];
                    break
                }
        }
        this._levels = l;
        for (let x = 0; x < l.length; x++)
            if (l[x] === u) {
                var d;
                this._firstLevel = x;
                const y = u.bitrate
                  , v = this.hls.bandwidthEstimate;
                if (this.log(`manifest loaded, ${l.length} level(s) found, first bitrate: ${y}`),
                ((d = this.hls.userConfig) == null ? void 0 : d.abrEwmaDefaultEstimate) === void 0) {
                    const E = Math.min(y, this.hls.config.abrEwmaDefaultEstimateMax);
                    E > v && v === this.hls.abrEwmaDefaultEstimate && (this.hls.bandwidthEstimate = E)
                }
                break
            }
        const h = i && !r
          , f = this.hls.config
          , m = !!(f.audioStreamController && f.audioTrackController)
          , p = {
            levels: l,
            audioTracks: a,
            subtitleTracks: o,
            sessionData: t.sessionData,
            sessionKeys: t.sessionKeys,
            firstLevel: this._firstLevel,
            stats: t.stats,
            audio: i,
            video: r,
            altAudio: m && !h && a.some(x => !!x.url)
        };
        this.hls.trigger(S.MANIFEST_PARSED, p)
    }
    get levels() {
        return this._levels.length === 0 ? null : this._levels
    }
    get loadLevelObj() {
        return this.currentLevel
    }
    get level() {
        return this.currentLevelIndex
    }
    set level(e) {
        const t = this._levels;
        if (t.length === 0)
            return;
        if (e < 0 || e >= t.length) {
            const u = new Error("invalid level idx")
              , d = e < 0;
            if (this.hls.trigger(S.ERROR, {
                type: q.OTHER_ERROR,
                details: N.LEVEL_SWITCH_ERROR,
                level: e,
                fatal: d,
                error: u,
                reason: u.message
            }),
            d)
                return;
            e = Math.min(e, t.length - 1)
        }
        const n = this.currentLevelIndex
          , r = this.currentLevel
          , i = r ? r.attrs["PATHWAY-ID"] : void 0
          , a = t[e]
          , o = a.attrs["PATHWAY-ID"];
        if (this.currentLevelIndex = e,
        this.currentLevel = a,
        n === e && r && i === o)
            return;
        this.log(`Switching to level ${e} (${a.height ? a.height + "p " : ""}${a.videoRange ? a.videoRange + " " : ""}${a.codecSet ? a.codecSet + " " : ""}@${a.bitrate})${o ? " with Pathway " + o : ""} from level ${n}${i ? " with Pathway " + i : ""}`);
        const l = {
            level: e,
            attrs: a.attrs,
            details: a.details,
            bitrate: a.bitrate,
            averageBitrate: a.averageBitrate,
            maxBitrate: a.maxBitrate,
            realBitrate: a.realBitrate,
            width: a.width,
            height: a.height,
            codecSet: a.codecSet,
            audioCodec: a.audioCodec,
            videoCodec: a.videoCodec,
            audioGroups: a.audioGroups,
            subtitleGroups: a.subtitleGroups,
            loaded: a.loaded,
            loadError: a.loadError,
            fragmentError: a.fragmentError,
            name: a.name,
            id: a.id,
            uri: a.uri,
            url: a.url,
            urlId: 0,
            audioGroupIds: a.audioGroupIds,
            textGroupIds: a.textGroupIds
        };
        this.hls.trigger(S.LEVEL_SWITCHING, l);
        const c = a.details;
        if (!c || c.live) {
            const u = this.switchParams(a.uri, r == null ? void 0 : r.details, c);
            this.loadPlaylist(u)
        }
    }
    get manualLevel() {
        return this.manualLevelIndex
    }
    set manualLevel(e) {
        this.manualLevelIndex = e,
        this._startLevel === void 0 && (this._startLevel = e),
        e !== -1 && (this.level = e)
    }
    get firstLevel() {
        return this._firstLevel
    }
    set firstLevel(e) {
        this._firstLevel = e
    }
    get startLevel() {
        if (this._startLevel === void 0) {
            const e = this.hls.config.startLevel;
            return e !== void 0 ? e : this.hls.firstAutoLevel
        }
        return this._startLevel
    }
    set startLevel(e) {
        this._startLevel = e
    }
    get pathways() {
        return this.steering ? this.steering.pathways() : []
    }
    get pathwayPriority() {
        return this.steering ? this.steering.pathwayPriority : null
    }
    set pathwayPriority(e) {
        if (this.steering) {
            const t = this.steering.pathways()
              , n = e.filter(r => t.indexOf(r) !== -1);
            if (e.length < 1) {
                this.warn(`pathwayPriority ${e} should contain at least one pathway from list: ${t}`);
                return
            }
            this.steering.pathwayPriority = n
        }
    }
    onError(e, t) {
        t.fatal || !t.context || t.context.type === le.LEVEL && t.context.level === this.level && this.checkRetry(t)
    }
    onFragBuffered(e, {frag: t}) {
        if (t !== void 0 && t.type === X.MAIN) {
            const n = t.elementaryStreams;
            if (!Object.keys(n).some(i => !!n[i]))
                return;
            const r = this._levels[t.level];
            r != null && r.loadError && (this.log(`Resetting level error count of ${r.loadError} on frag buffered`),
            r.loadError = 0)
        }
    }
    onLevelLoaded(e, t) {
        var n;
        const {level: r, details: i} = t
          , a = t.levelInfo;
        if (!a) {
            var o;
            this.warn(`Invalid level index ${r}`),
            (o = t.deliveryDirectives) != null && o.skip && (i.deltaUpdateFailed = !0);
            return
        }
        if (a === this.currentLevel || t.withoutMultiVariant) {
            a.fragmentError === 0 && (a.loadError = 0);
            let l = a.details;
            l === t.details && l.advanced && (l = void 0),
            this.playlistLoaded(r, t, l)
        } else
            (n = t.deliveryDirectives) != null && n.skip && (i.deltaUpdateFailed = !0)
    }
    loadPlaylist(e) {
        super.loadPlaylist(),
        this.shouldLoadPlaylist(this.currentLevel) && this.scheduleLoading(this.currentLevel, e)
    }
    loadingPlaylist(e, t) {
        super.loadingPlaylist(e, t);
        const n = this.getUrlWithDirectives(e.uri, t)
          , r = this.currentLevelIndex
          , i = e.attrs["PATHWAY-ID"]
          , a = e.details
          , o = a == null ? void 0 : a.age;
        this.log(`Loading level index ${r}${(t == null ? void 0 : t.msn) !== void 0 ? " at sn " + t.msn + " part " + t.part : ""}${i ? " Pathway " + i : ""}${o && a.live ? " age " + o.toFixed(1) + (a.type && " " + a.type || "") : ""} ${n}`),
        this.hls.trigger(S.LEVEL_LOADING, {
            url: n,
            level: r,
            levelInfo: e,
            pathwayId: e.attrs["PATHWAY-ID"],
            id: 0,
            deliveryDirectives: t || null
        })
    }
    get nextLoadLevel() {
        return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel
    }
    set nextLoadLevel(e) {
        this.level = e,
        this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e)
    }
    removeLevel(e) {
        var t;
        if (this._levels.length === 1)
            return;
        const n = this._levels.filter( (i, a) => a !== e ? !0 : (this.steering && this.steering.removeLevel(i),
        i === this.currentLevel && (this.currentLevel = null,
        this.currentLevelIndex = -1,
        i.details && i.details.fragments.forEach(o => o.level = -1)),
        !1));
        T0(n),
        this._levels = n,
        this.currentLevelIndex > -1 && (t = this.currentLevel) != null && t.details && (this.currentLevelIndex = this.currentLevel.details.fragments[0].level),
        this.manualLevelIndex > -1 && (this.manualLevelIndex = this.currentLevelIndex);
        const r = n.length - 1;
        this._firstLevel = Math.min(this._firstLevel, r),
        this._startLevel && (this._startLevel = Math.min(this._startLevel, r)),
        this.hls.trigger(S.LEVELS_UPDATED, {
            levels: n
        })
    }
    onLevelsUpdated(e, {levels: t}) {
        this._levels = t
    }
    checkMaxAutoUpdated() {
        const {autoLevelCapping: e, maxAutoLevel: t, maxHdcpLevel: n} = this.hls;
        this._maxAutoLevel !== t && (this._maxAutoLevel = t,
        this.hls.trigger(S.MAX_AUTO_LEVEL_UPDATED, {
            autoLevelCapping: e,
            levels: this.levels,
            maxAutoLevel: t,
            minAutoLevel: this.hls.minAutoLevel,
            maxHdcpLevel: n
        }))
    }
}
function hm(s) {
    const e = {};
    s.forEach(t => {
        const n = t.groupId || "";
        t.id = e[n] = e[n] || 0,
        e[n]++
    }
    )
}
function yy() {
    return self.SourceBuffer || self.WebKitSourceBuffer
}
function xy() {
    if (!on())
        return !1;
    const e = yy();
    return !e || e.prototype && typeof e.prototype.appendBuffer == "function" && typeof e.prototype.remove == "function"
}
function DA() {
    if (!xy())
        return !1;
    const s = on();
    return typeof (s == null ? void 0 : s.isTypeSupported) == "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some(e => s.isTypeSupported(Ai(e, "video"))) || ["mp4a.40.2", "fLaC"].some(e => s.isTypeSupported(Ai(e, "audio"))))
}
function PA() {
    var s;
    const e = yy();
    return typeof (e == null || (s = e.prototype) == null ? void 0 : s.changeType) == "function"
}
const NA = 100;
class OA extends Sd {
    constructor(e, t, n) {
        super(e, t, n, "stream-controller", X.MAIN),
        this.audioCodecSwap = !1,
        this.level = -1,
        this._forceStartLoad = !1,
        this._hasEnoughToStart = !1,
        this.altAudio = 0,
        this.audioOnly = !1,
        this.fragPlaying = null,
        this.fragLastKbps = 0,
        this.couldBacktrack = !1,
        this.backtrackFragment = null,
        this.audioCodecSwitch = !1,
        this.videoBuffer = null,
        this.onMediaPlaying = () => {
            this.tick()
        }
        ,
        this.onMediaSeeked = () => {
            const r = this.media
              , i = r ? r.currentTime : null;
            if (i === null || !z(i) || (this.log(`Media seeked to ${i.toFixed(3)}`),
            !this.getBufferedFrag(i)))
                return;
            const a = this.getFwdBufferInfoAtPos(r, i, X.MAIN, 0);
            if (a === null || a.len === 0) {
                this.warn(`Main forward buffer length at ${i} on "seeked" event ${a ? a.len : "empty"})`);
                return
            }
            this.tick()
        }
        ,
        this.registerListeners()
    }
    registerListeners() {
        super.registerListeners();
        const {hls: e} = this;
        e.on(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.on(S.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(S.LEVEL_LOADED, this.onLevelLoaded, this),
        e.on(S.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this),
        e.on(S.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.on(S.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
        e.on(S.BUFFER_CREATED, this.onBufferCreated, this),
        e.on(S.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.on(S.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.on(S.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    unregisterListeners() {
        super.unregisterListeners();
        const {hls: e} = this;
        e.off(S.MANIFEST_PARSED, this.onManifestParsed, this),
        e.off(S.LEVEL_LOADED, this.onLevelLoaded, this),
        e.off(S.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this),
        e.off(S.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this),
        e.off(S.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this),
        e.off(S.BUFFER_CREATED, this.onBufferCreated, this),
        e.off(S.BUFFER_FLUSHED, this.onBufferFlushed, this),
        e.off(S.LEVELS_UPDATED, this.onLevelsUpdated, this),
        e.off(S.FRAG_BUFFERED, this.onFragBuffered, this)
    }
    onHandlerDestroying() {
        this.onMediaPlaying = this.onMediaSeeked = null,
        this.unregisterListeners(),
        super.onHandlerDestroying()
    }
    startLoad(e, t) {
        if (this.levels) {
            const {lastCurrentTime: n, hls: r} = this;
            if (this.stopLoad(),
            this.setInterval(NA),
            this.level = -1,
            !this.startFragRequested) {
                let i = r.startLevel;
                i === -1 && (r.config.testBandwidth && this.levels.length > 1 ? (i = 0,
                this.bitrateTest = !0) : i = r.firstAutoLevel),
                r.nextLoadLevel = i,
                this.level = r.loadLevel,
                this._hasEnoughToStart = !!t
            }
            n > 0 && e === -1 && !t && (this.log(`Override startPosition with lastCurrentTime @${n.toFixed(3)}`),
            e = n),
            this.state = U.IDLE,
            this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset,
            this.startPosition = t ? -1 : e,
            this.tick()
        } else
            this._forceStartLoad = !0,
            this.state = U.STOPPED
    }
    stopLoad() {
        this._forceStartLoad = !1,
        super.stopLoad()
    }
    doTick() {
        switch (this.state) {
        case U.WAITING_LEVEL:
            {
                const {levels: e, level: t} = this
                  , n = e == null ? void 0 : e[t]
                  , r = n == null ? void 0 : n.details;
                if (r && (!r.live || this.levelLastLoaded === n && !this.waitForLive(n))) {
                    if (this.waitForCdnTuneIn(r))
                        break;
                    this.state = U.IDLE;
                    break
                } else if (this.hls.nextLoadLevel !== this.level) {
                    this.state = U.IDLE;
                    break
                }
                break
            }
        case U.FRAG_LOADING_WAITING_RETRY:
            this.checkRetryDate();
            break
        }
        this.state === U.IDLE && this.doTickIdle(),
        this.onTickEnd()
    }
    onTickEnd() {
        var e;
        super.onTickEnd(),
        (e = this.media) != null && e.readyState && this.media.seeking === !1 && (this.lastCurrentTime = this.media.currentTime),
        this.checkFragmentChanged()
    }
    doTickIdle() {
        const {hls: e, levelLastLoaded: t, levels: n, media: r} = this;
        if (t === null || !r && !this.primaryPrefetch && (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio && this.audioOnly)
            return;
        const i = this.buffering ? e.nextLoadLevel : e.loadLevel;
        if (!(n != null && n[i]))
            return;
        const a = n[i]
          , o = this.getMainFwdBufferInfo();
        if (o === null)
            return;
        const l = this.getLevelDetails();
        if (l && this._streamEnded(o, l)) {
            const p = {};
            this.altAudio === 2 && (p.type = "video"),
            this.hls.trigger(S.BUFFER_EOS, p),
            this.state = U.ENDED;
            return
        }
        if (!this.buffering)
            return;
        e.loadLevel !== i && e.manualLevel === -1 && this.log(`Adapting to level ${i} from level ${this.level}`),
        this.level = e.nextLoadLevel = i;
        const c = a.details;
        if (!c || this.state === U.WAITING_LEVEL || this.waitForLive(a)) {
            this.level = i,
            this.state = U.WAITING_LEVEL,
            this.startFragRequested = !1;
            return
        }
        const u = o.len
          , d = this.getMaxBufferLength(a.maxBitrate);
        if (u >= d)
            return;
        this.backtrackFragment && this.backtrackFragment.start > o.end && (this.backtrackFragment = null);
        const h = this.backtrackFragment ? this.backtrackFragment.start : o.end;
        let f = this.getNextFragment(h, c);
        if (this.couldBacktrack && !this.fragPrevious && f && Fe(f) && this.fragmentTracker.getState(f) !== Ve.OK) {
            var m;
            const x = ((m = this.backtrackFragment) != null ? m : f).sn - c.startSN
              , y = c.fragments[x - 1];
            y && f.cc === y.cc && (f = y,
            this.fragmentTracker.removeFragment(y))
        } else
            this.backtrackFragment && o.len && (this.backtrackFragment = null);
        if (f && this.isLoopLoading(f, h)) {
            if (!f.gap) {
                const x = this.audioOnly && !this.altAudio ? xe.AUDIO : xe.VIDEO
                  , y = (x === xe.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
                y && this.afterBufferFlushed(y, x, X.MAIN)
            }
            f = this.getNextFragmentLoopLoading(f, c, o, X.MAIN, d)
        }
        f && (f.initSegment && !f.initSegment.data && !this.bitrateTest && (f = f.initSegment),
        this.loadFragment(f, a, h))
    }
    loadFragment(e, t, n) {
        const r = this.fragmentTracker.getState(e);
        r === Ve.NOT_LOADED || r === Ve.PARTIAL ? Fe(e) ? this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`),
        this._loadBitrateTestFrag(e, t)) : super.loadFragment(e, t, n) : this._loadInitSegment(e, t) : this.clearTrackerIfNeeded(e)
    }
    getBufferedFrag(e) {
        return this.fragmentTracker.getBufferedFrag(e, X.MAIN)
    }
    followingBufferedFrag(e) {
        return e ? this.getBufferedFrag(e.end + .5) : null
    }
    immediateLevelSwitch() {
        this.abortCurrentFrag(),
        this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
    }
    nextLevelSwitch() {
        const {levels: e, media: t} = this;
        if (t != null && t.readyState) {
            let n;
            const r = this.getAppendedFrag(t.currentTime);
            r && r.start > 1 && this.flushMainBuffer(0, r.start - 1);
            const i = this.getLevelDetails();
            if (i != null && i.live) {
                const o = this.getMainFwdBufferInfo();
                if (!o || o.len < i.targetduration * 2)
                    return
            }
            if (!t.paused && e) {
                const o = this.hls.nextLoadLevel
                  , l = e[o]
                  , c = this.fragLastKbps;
                c && this.fragCurrent ? n = this.fragCurrent.duration * l.maxBitrate / (1e3 * c) + 1 : n = 0
            } else
                n = 0;
            const a = this.getBufferedFrag(t.currentTime + n);
            if (a) {
                const o = this.followingBufferedFrag(a);
                if (o) {
                    this.abortCurrentFrag();
                    const l = o.maxStartPTS ? o.maxStartPTS : o.start
                      , c = o.duration
                      , u = Math.max(a.end, l + Math.min(Math.max(c - this.config.maxFragLookUpTolerance, c * (this.couldBacktrack ? .5 : .125)), c * (this.couldBacktrack ? .75 : .25)));
                    this.flushMainBuffer(u, Number.POSITIVE_INFINITY)
                }
            }
        }
    }
    abortCurrentFrag() {
        const e = this.fragCurrent;
        switch (this.fragCurrent = null,
        this.backtrackFragment = null,
        e && (e.abortRequests(),
        this.fragmentTracker.removeFragment(e)),
        this.state) {
        case U.KEY_LOADING:
        case U.FRAG_LOADING:
        case U.FRAG_LOADING_WAITING_RETRY:
        case U.PARSING:
        case U.PARSED:
            this.state = U.IDLE;
            break
        }
        this.nextLoadPosition = this.getLoadPosition()
    }
    flushMainBuffer(e, t) {
        super.flushMainBuffer(e, t, this.altAudio === 2 ? "video" : null)
    }
    onMediaAttached(e, t) {
        super.onMediaAttached(e, t);
        const n = t.media;
        lt(n, "playing", this.onMediaPlaying),
        lt(n, "seeked", this.onMediaSeeked)
    }
    onMediaDetaching(e, t) {
        const {media: n} = this;
        n && (yt(n, "playing", this.onMediaPlaying),
        yt(n, "seeked", this.onMediaSeeked)),
        this.videoBuffer = null,
        this.fragPlaying = null,
        super.onMediaDetaching(e, t),
        !t.transferMedia && (this._hasEnoughToStart = !1)
    }
    onManifestLoading() {
        super.onManifestLoading(),
        this.log("Trigger BUFFER_RESET"),
        this.hls.trigger(S.BUFFER_RESET, void 0),
        this.couldBacktrack = !1,
        this.fragLastKbps = 0,
        this.fragPlaying = this.backtrackFragment = null,
        this.altAudio = 0,
        this.audioOnly = !1
    }
    onManifestParsed(e, t) {
        let n = !1
          , r = !1;
        for (let i = 0; i < t.levels.length; i++) {
            const a = t.levels[i].audioCodec;
            a && (n = n || a.indexOf("mp4a.40.2") !== -1,
            r = r || a.indexOf("mp4a.40.5") !== -1)
        }
        this.audioCodecSwitch = n && r && !PA(),
        this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"),
        this.levels = t.levels,
        this.startFragRequested = !1
    }
    onLevelLoading(e, t) {
        const {levels: n} = this;
        if (!n || this.state !== U.IDLE)
            return;
        const r = t.levelInfo;
        (!r.details || r.details.live && (this.levelLastLoaded !== r || r.details.expired) || this.waitForCdnTuneIn(r.details)) && (this.state = U.WAITING_LEVEL)
    }
    onLevelLoaded(e, t) {
        var n;
        const {levels: r, startFragRequested: i} = this
          , a = t.level
          , o = t.details
          , l = o.totalduration;
        if (!r) {
            this.warn(`Levels were reset while loading level ${a}`);
            return
        }
        this.log(`Level ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : ""}, cc [${o.startCC}, ${o.endCC}] duration:${l}`);
        const c = t.levelInfo
          , u = this.fragCurrent;
        u && (this.state === U.FRAG_LOADING || this.state === U.FRAG_LOADING_WAITING_RETRY) && u.level !== t.level && u.loader && this.abortCurrentFrag();
        let d = 0;
        if (o.live || (n = c.details) != null && n.live) {
            var h;
            if (this.checkLiveUpdate(o),
            o.deltaUpdateFailed)
                return;
            d = this.alignPlaylists(o, c.details, (h = this.levelLastLoaded) == null ? void 0 : h.details)
        }
        if (c.details = o,
        this.levelLastLoaded = c,
        i || this.setStartPosition(o, d),
        this.hls.trigger(S.LEVEL_UPDATED, {
            details: o,
            level: a
        }),
        this.state === U.WAITING_LEVEL) {
            if (this.waitForCdnTuneIn(o))
                return;
            this.state = U.IDLE
        }
        i && o.live && this.synchronizeToLiveEdge(o),
        this.tick()
    }
    synchronizeToLiveEdge(e) {
        const {config: t, media: n} = this;
        if (!n)
            return;
        const r = this.hls.liveSyncPosition
          , i = this.getLoadPosition()
          , a = e.fragmentStart
          , o = e.edge
          , l = i >= a - t.maxFragLookUpTolerance && i <= o;
        if (r !== null && n.duration > r && (i < r || !l)) {
            const u = t.liveMaxLatencyDuration !== void 0 ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;
            if ((!l && n.readyState < 4 || i < o - u) && (this._hasEnoughToStart || (this.nextLoadPosition = r),
            n.readyState))
                if (this.warn(`Playback: ${i.toFixed(3)} is located too far from the end of live sliding playlist: ${o}, reset currentTime to : ${r.toFixed(3)}`),
                this.config.liveSyncMode === "buffered") {
                    var c;
                    const d = ie.bufferInfo(n, r, 0);
                    if (!((c = d.buffered) != null && c.length)) {
                        n.currentTime = r;
                        return
                    }
                    if (d.start <= i) {
                        n.currentTime = r;
                        return
                    }
                    const {nextStart: f} = ie.bufferedInfo(d.buffered, i, 0);
                    f && (n.currentTime = f)
                } else
                    n.currentTime = r
        }
    }
    _handleFragmentLoadProgress(e) {
        var t;
        const n = e.frag
          , {part: r, payload: i} = e
          , {levels: a} = this;
        if (!a) {
            this.warn(`Levels were reset while fragment load was in progress. Fragment ${n.sn} of level ${n.level} will not be buffered`);
            return
        }
        const o = a[n.level];
        if (!o) {
            this.warn(`Level ${n.level} not found on progress`);
            return
        }
        const l = o.details;
        if (!l) {
            this.warn(`Dropping fragment ${n.sn} of level ${n.level} after level details were reset`),
            this.fragmentTracker.removeFragment(n);
            return
        }
        const c = o.videoCodec
          , u = l.PTSKnown || !l.live
          , d = (t = n.initSegment) == null ? void 0 : t.data
          , h = this._getAudioCodec(o)
          , f = this.transmuxer = this.transmuxer || new H0(this.hls,X.MAIN,this._handleTransmuxComplete.bind(this),this._handleTransmuxerFlush.bind(this))
          , m = r ? r.index : -1
          , p = m !== -1
          , x = new xd(n.level,n.sn,n.stats.chunkCount,i.byteLength,m,p)
          , y = this.initPTS[n.cc];
        f.push(i, d, h, c, n, r, l.totalduration, u, x, y)
    }
    onAudioTrackSwitching(e, t) {
        const n = this.hls
          , r = this.altAudio === 2;
        if (To(t.url, n))
            this.altAudio = 1;
        else {
            if (this.mediaBuffer !== this.media) {
                this.log("Switching on main audio, use media.buffered to schedule main fragment loading"),
                this.mediaBuffer = this.media;
                const a = this.fragCurrent;
                a && (this.log("Switching to main audio track, cancel main fragment load"),
                a.abortRequests(),
                this.fragmentTracker.removeFragment(a)),
                this.resetTransmuxer(),
                this.resetLoadingState()
            } else
                this.audioOnly && this.resetTransmuxer();
            if (r) {
                this.fragmentTracker.removeAllFragments(),
                n.once(S.BUFFER_FLUSHED, () => {
                    this.hls && this.hls.trigger(S.AUDIO_TRACK_SWITCHED, t)
                }
                ),
                n.trigger(S.BUFFER_FLUSHING, {
                    startOffset: 0,
                    endOffset: Number.POSITIVE_INFINITY,
                    type: null
                });
                return
            }
            n.trigger(S.AUDIO_TRACK_SWITCHED, t)
        }
    }
    onAudioTrackSwitched(e, t) {
        const n = To(t.url, this.hls);
        if (n) {
            const r = this.videoBuffer;
            r && this.mediaBuffer !== r && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"),
            this.mediaBuffer = r)
        }
        this.altAudio = n ? 2 : 0,
        this.tick()
    }
    onBufferCreated(e, t) {
        const n = t.tracks;
        let r, i, a = !1;
        for (const o in n) {
            const l = n[o];
            if (l.id === "main") {
                if (i = o,
                r = l,
                o === "video") {
                    const c = n[o];
                    c && (this.videoBuffer = c.buffer)
                }
            } else
                a = !0
        }
        a && r ? (this.log(`Alternate track found, use ${i}.buffered to schedule main fragment loading`),
        this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media
    }
    onFragBuffered(e, t) {
        const {frag: n, part: r} = t
          , i = n.type === X.MAIN;
        if (i) {
            if (this.fragContextChanged(n)) {
                this.warn(`Fragment ${n.sn}${r ? " p: " + r.index : ""} of level ${n.level} finished buffering, but was aborted. state: ${this.state}`),
                this.state === U.PARSED && (this.state = U.IDLE);
                return
            }
            const o = r ? r.stats : n.stats;
            this.fragLastKbps = Math.round(8 * o.total / (o.buffering.end - o.loading.first)),
            Fe(n) && (this.fragPrevious = n),
            this.fragBufferedComplete(n, r)
        }
        const a = this.media;
        a && (!this._hasEnoughToStart && ie.getBuffered(a).length && (this._hasEnoughToStart = !0,
        this.seekToStartPos()),
        i && this.tick())
    }
    get hasEnoughToStart() {
        return this._hasEnoughToStart
    }
    onError(e, t) {
        var n;
        if (t.fatal) {
            this.state = U.ERROR;
            return
        }
        switch (t.details) {
        case N.FRAG_GAP:
        case N.FRAG_PARSING_ERROR:
        case N.FRAG_DECRYPT_ERROR:
        case N.FRAG_LOAD_ERROR:
        case N.FRAG_LOAD_TIMEOUT:
        case N.KEY_LOAD_ERROR:
        case N.KEY_LOAD_TIMEOUT:
            this.onFragmentOrKeyLoadError(X.MAIN, t);
            break;
        case N.LEVEL_LOAD_ERROR:
        case N.LEVEL_LOAD_TIMEOUT:
        case N.LEVEL_PARSING_ERROR:
            !t.levelRetry && this.state === U.WAITING_LEVEL && ((n = t.context) == null ? void 0 : n.type) === le.LEVEL && (this.state = U.IDLE);
            break;
        case N.BUFFER_ADD_CODEC_ERROR:
        case N.BUFFER_APPEND_ERROR:
            if (t.parent !== "main")
                return;
            this.reduceLengthAndFlushBuffer(t) && this.resetLoadingState();
            break;
        case N.BUFFER_FULL_ERROR:
            if (t.parent !== "main")
                return;
            this.reduceLengthAndFlushBuffer(t) && (!this.config.interstitialsController && this.config.assetPlayerId ? this._hasEnoughToStart = !0 : this.flushMainBuffer(0, Number.POSITIVE_INFINITY));
            break;
        case N.INTERNAL_EXCEPTION:
            this.recoverWorkerError(t);
            break
        }
    }
    onFragLoadEmergencyAborted() {
        this.state = U.IDLE,
        this._hasEnoughToStart || (this.startFragRequested = !1,
        this.nextLoadPosition = this.lastCurrentTime),
        this.tickImmediate()
    }
    onBufferFlushed(e, {type: t}) {
        if (t !== xe.AUDIO || !this.altAudio) {
            const n = (t === xe.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
            n && (this.afterBufferFlushed(n, t, X.MAIN),
            this.tick())
        }
    }
    onLevelsUpdated(e, t) {
        this.level > -1 && this.fragCurrent && (this.level = this.fragCurrent.level,
        this.level === -1 && this.resetWhenMissingContext(this.fragCurrent)),
        this.levels = t.levels
    }
    swapAudioCodec() {
        this.audioCodecSwap = !this.audioCodecSwap
    }
    seekToStartPos() {
        const {media: e} = this;
        if (!e)
            return;
        const t = e.currentTime;
        let n = this.startPosition;
        if (n >= 0 && t < n) {
            if (e.seeking) {
                this.log(`could not seek to ${n}, already seeking at ${t}`);
                return
            }
            const r = this.timelineOffset;
            r && n && (n += r);
            const i = this.getLevelDetails()
              , a = ie.getBuffered(e)
              , o = a.length ? a.start(0) : 0
              , l = o - n
              , c = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);
            (this.config.startOnSegmentBoundary || l > 0 && (l < c || this.loadingParts && l < 2 * ((i == null ? void 0 : i.partTarget) || 0))) && (this.log(`adjusting start position by ${l} to match buffer start`),
            n += l,
            this.startPosition = n),
            t < n && (this.log(`seek to target start position ${n} from current time ${t} buffer start ${o}`),
            e.currentTime = n)
        }
    }
    _getAudioCodec(e) {
        let t = this.config.defaultAudioCodec || e.audioCodec;
        return this.audioCodecSwap && t && (this.log("Swapping audio codec"),
        t.indexOf("mp4a.40.5") !== -1 ? t = "mp4a.40.2" : t = "mp4a.40.5"),
        t
    }
    _loadBitrateTestFrag(e, t) {
        e.bitrateTest = !0,
        this._doFragLoad(e, t).then(n => {
            const {hls: r} = this
              , i = n == null ? void 0 : n.frag;
            if (!i || this.fragContextChanged(i))
                return;
            t.fragmentError = 0,
            this.state = U.IDLE,
            this.startFragRequested = !1,
            this.bitrateTest = !1;
            const a = i.stats;
            a.parsing.start = a.parsing.end = a.buffering.start = a.buffering.end = self.performance.now(),
            r.trigger(S.FRAG_LOADED, n),
            i.bitrateTest = !1
        }
        ).catch(n => {
            this.state === U.STOPPED || this.state === U.ERROR || (this.warn(n),
            this.resetFragmentLoading(e))
        }
        )
    }
    _handleTransmuxComplete(e) {
        const t = this.playlistType
          , {hls: n} = this
          , {remuxResult: r, chunkMeta: i} = e
          , a = this.getCurrentContext(i);
        if (!a) {
            this.resetWhenMissingContext(i);
            return
        }
        const {frag: o, part: l, level: c} = a
          , {video: u, text: d, id3: h, initSegment: f} = r
          , {details: m} = c
          , p = this.altAudio ? void 0 : r.audio;
        if (this.fragContextChanged(o)) {
            this.fragmentTracker.removeFragment(o);
            return
        }
        if (this.state = U.PARSING,
        f) {
            const x = f.tracks;
            if (x) {
                const T = o.initSegment || o;
                if (this.unhandledEncryptionError(f, o))
                    return;
                this._bufferInitSegment(c, x, T, i),
                n.trigger(S.FRAG_PARSING_INIT_SEGMENT, {
                    frag: T,
                    id: t,
                    tracks: x
                })
            }
            const y = f.initPTS
              , v = f.timescale
              , E = this.initPTS[o.cc];
            if (z(y) && (!E || E.baseTime !== y || E.timescale !== v)) {
                const T = f.trackId;
                this.initPTS[o.cc] = {
                    baseTime: y,
                    timescale: v,
                    trackId: T
                },
                n.trigger(S.INIT_PTS_FOUND, {
                    frag: o,
                    id: t,
                    initPTS: y,
                    timescale: v,
                    trackId: T
                })
            }
        }
        if (u && m) {
            p && u.type === "audiovideo" && this.logMuxedErr(o);
            const x = m.fragments[o.sn - 1 - m.startSN]
              , y = o.sn === m.startSN
              , v = !x || o.cc > x.cc;
            if (r.independent !== !1) {
                const {startPTS: E, endPTS: T, startDTS: L, endDTS: R} = u;
                if (l)
                    l.elementaryStreams[u.type] = {
                        startPTS: E,
                        endPTS: T,
                        startDTS: L,
                        endDTS: R
                    };
                else if (u.firstKeyFrame && u.independent && i.id === 1 && !v && (this.couldBacktrack = !0),
                u.dropped && u.independent) {
                    const I = this.getMainFwdBufferInfo()
                      , A = (I ? I.end : this.getLoadPosition()) + this.config.maxBufferHole
                      , C = u.firstKeyFramePTS ? u.firstKeyFramePTS : E;
                    if (!y && A < C - this.config.maxBufferHole && !v) {
                        this.backtrack(o);
                        return
                    } else
                        v && (o.gap = !0);
                    o.setElementaryStreamInfo(u.type, o.start, T, o.start, R, !0)
                } else
                    y && E - (m.appliedTimelineOffset || 0) > Va && (o.gap = !0);
                o.setElementaryStreamInfo(u.type, E, T, L, R),
                this.backtrackFragment && (this.backtrackFragment = o),
                this.bufferFragmentData(u, o, l, i, y || v)
            } else if (y || v)
                o.gap = !0;
            else {
                this.backtrack(o);
                return
            }
        }
        if (p) {
            const {startPTS: x, endPTS: y, startDTS: v, endDTS: E} = p;
            l && (l.elementaryStreams[xe.AUDIO] = {
                startPTS: x,
                endPTS: y,
                startDTS: v,
                endDTS: E
            }),
            o.setElementaryStreamInfo(xe.AUDIO, x, y, v, E),
            this.bufferFragmentData(p, o, l, i)
        }
        if (m && h != null && h.samples.length) {
            const x = {
                id: t,
                frag: o,
                details: m,
                samples: h.samples
            };
            n.trigger(S.FRAG_PARSING_METADATA, x)
        }
        if (m && d) {
            const x = {
                id: t,
                frag: o,
                details: m,
                samples: d.samples
            };
            n.trigger(S.FRAG_PARSING_USERDATA, x)
        }
    }
    logMuxedErr(e) {
        this.warn(`${Fe(e) ? "Media" : "Init"} segment with muxed audiovideo where only video expected: ${e.url}`)
    }
    _bufferInitSegment(e, t, n, r) {
        if (this.state !== U.PARSING)
            return;
        this.audioOnly = !!t.audio && !t.video,
        this.altAudio && !this.audioOnly && (delete t.audio,
        t.audiovideo && this.logMuxedErr(n));
        const {audio: i, video: a, audiovideo: o} = t;
        if (i) {
            const c = e.audioCodec;
            let u = Ma(i.codec, c);
            u === "mp4a" && (u = "mp4a.40.5");
            const d = navigator.userAgent.toLowerCase();
            if (this.audioCodecSwitch) {
                u && (u.indexOf("mp4a.40.5") !== -1 ? u = "mp4a.40.2" : u = "mp4a.40.5");
                const h = i.metadata;
                h && "channelCount"in h && (h.channelCount || 1) !== 1 && d.indexOf("firefox") === -1 && (u = "mp4a.40.5")
            }
            u && u.indexOf("mp4a.40.5") !== -1 && d.indexOf("android") !== -1 && i.container !== "audio/mpeg" && (u = "mp4a.40.2",
            this.log(`Android: force audio codec to ${u}`)),
            c && c !== u && this.log(`Swapping manifest audio codec "${c}" for "${u}"`),
            i.levelCodec = u,
            i.id = X.MAIN,
            this.log(`Init audio buffer, container:${i.container}, codecs[selected/level/parsed]=[${u || ""}/${c || ""}/${i.codec}]`),
            delete t.audiovideo
        }
        if (a) {
            a.levelCodec = e.videoCodec,
            a.id = X.MAIN;
            const c = a.codec;
            if ((c == null ? void 0 : c.length) === 4)
                switch (c) {
                case "hvc1":
                case "hev1":
                    a.codec = "hvc1.1.6.L120.90";
                    break;
                case "av01":
                    a.codec = "av01.0.04M.08";
                    break;
                case "avc1":
                    a.codec = "avc1.42e01e";
                    break
                }
            this.log(`Init video buffer, container:${a.container}, codecs[level/parsed]=[${e.videoCodec || ""}/${c}]${a.codec !== c ? " parsed-corrected=" + a.codec : ""}${a.supplemental ? " supplemental=" + a.supplemental : ""}`),
            delete t.audiovideo
        }
        o && (this.log(`Init audiovideo buffer, container:${o.container}, codecs[level/parsed]=[${e.codecs}/${o.codec}]`),
        delete t.video,
        delete t.audio);
        const l = Object.keys(t);
        if (l.length) {
            if (this.hls.trigger(S.BUFFER_CODECS, t),
            !this.hls)
                return;
            l.forEach(c => {
                const d = t[c].initSegment;
                d != null && d.byteLength && this.hls.trigger(S.BUFFER_APPENDING, {
                    type: c,
                    data: d,
                    frag: n,
                    part: null,
                    chunkMeta: r,
                    parent: n.type
                })
            }
            )
        }
        this.tickImmediate()
    }
    getMainFwdBufferInfo() {
        const e = this.mediaBuffer && this.altAudio === 2 ? this.mediaBuffer : this.media;
        return this.getFwdBufferInfo(e, X.MAIN)
    }
    get maxBufferLength() {
        const {levels: e, level: t} = this
          , n = e == null ? void 0 : e[t];
        return n ? this.getMaxBufferLength(n.maxBitrate) : this.config.maxBufferLength
    }
    backtrack(e) {
        this.couldBacktrack = !0,
        this.backtrackFragment = e,
        this.resetTransmuxer(),
        this.flushBufferGap(e),
        this.fragmentTracker.removeFragment(e),
        this.fragPrevious = null,
        this.nextLoadPosition = e.start,
        this.state = U.IDLE
    }
    checkFragmentChanged() {
        const e = this.media;
        let t = null;
        if (e && e.readyState > 1 && e.seeking === !1) {
            const n = e.currentTime;
            if (ie.isBuffered(e, n) ? t = this.getAppendedFrag(n) : ie.isBuffered(e, n + .1) && (t = this.getAppendedFrag(n + .1)),
            t) {
                this.backtrackFragment = null;
                const r = this.fragPlaying
                  , i = t.level;
                (!r || t.sn !== r.sn || r.level !== i) && (this.fragPlaying = t,
                this.hls.trigger(S.FRAG_CHANGED, {
                    frag: t
                }),
                (!r || r.level !== i) && this.hls.trigger(S.LEVEL_SWITCHED, {
                    level: i
                }))
            }
        }
    }
    get nextLevel() {
        const e = this.nextBufferedFrag;
        return e ? e.level : -1
    }
    get currentFrag() {
        var e;
        if (this.fragPlaying)
            return this.fragPlaying;
        const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
        return z(t) ? this.getAppendedFrag(t) : null
    }
    get currentProgramDateTime() {
        var e;
        const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;
        if (z(t)) {
            const n = this.getLevelDetails()
              , r = this.currentFrag || (n ? Pn(null, n.fragments, t) : null);
            if (r) {
                const i = r.programDateTime;
                if (i !== null) {
                    const a = i + (t - r.start) * 1e3;
                    return new Date(a)
                }
            }
        }
        return null
    }
    get currentLevel() {
        const e = this.currentFrag;
        return e ? e.level : -1
    }
    get nextBufferedFrag() {
        const e = this.currentFrag;
        return e ? this.followingBufferedFrag(e) : null
    }
    get forceStartLoad() {
        return this._forceStartLoad
    }
}
class MA extends Gt {
    constructor(e, t) {
        super("key-loader", t),
        this.config = void 0,
        this.keyIdToKeyInfo = {},
        this.emeController = null,
        this.config = e
    }
    abort(e) {
        for (const n in this.keyIdToKeyInfo) {
            const r = this.keyIdToKeyInfo[n].loader;
            if (r) {
                var t;
                if (e && e !== ((t = r.context) == null ? void 0 : t.frag.type))
                    return;
                r.abort()
            }
        }
    }
    detach() {
        for (const e in this.keyIdToKeyInfo) {
            const t = this.keyIdToKeyInfo[e];
            (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) && delete this.keyIdToKeyInfo[e]
        }
    }
    destroy() {
        this.detach();
        for (const e in this.keyIdToKeyInfo) {
            const t = this.keyIdToKeyInfo[e].loader;
            t && t.destroy()
        }
        this.keyIdToKeyInfo = {}
    }
    createKeyLoadError(e, t=N.KEY_LOAD_ERROR, n, r, i) {
        return new Ls({
            type: q.NETWORK_ERROR,
            details: t,
            fatal: !1,
            frag: e,
            response: i,
            error: n,
            networkDetails: r
        })
    }
    loadClear(e, t, n) {
        if (this.emeController && this.config.emeEnabled && !this.emeController.getSelectedKeySystemFormats().length) {
            if (t.length)
                for (let r = 0, i = t.length; r < i; r++) {
                    const a = t[r];
                    if (e.cc <= a.cc && (!Fe(e) || !Fe(a) || e.sn < a.sn) || !n && r == i - 1)
                        return this.emeController.selectKeySystemFormat(a).then(o => {
                            if (!this.emeController)
                                return;
                            a.setKeyFormat(o);
                            const l = Ua(o);
                            if (l)
                                return this.emeController.getKeySystemAccess([l])
                        }
                        )
                }
            if (this.config.requireKeySystemAccessOnStart) {
                const r = zr(this.config);
                if (r.length)
                    return this.emeController.getKeySystemAccess(r)
            }
        }
        return null
    }
    load(e) {
        return !e.decryptdata && e.encrypted && this.emeController && this.config.emeEnabled ? this.emeController.selectKeySystemFormat(e).then(t => this.loadInternal(e, t)) : this.loadInternal(e)
    }
    loadInternal(e, t) {
        var n, r;
        t && e.setKeyFormat(t);
        const i = e.decryptdata;
        if (!i) {
            const u = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : "Missing decryption data on fragment in onKeyLoading");
            return Promise.reject(this.createKeyLoadError(e, N.KEY_LOAD_ERROR, u))
        }
        const a = i.uri;
        if (!a)
            return Promise.reject(this.createKeyLoadError(e, N.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${a}"`)));
        const o = Zl(i);
        let l = this.keyIdToKeyInfo[o];
        if ((n = l) != null && n.decryptdata.key)
            return i.key = l.decryptdata.key,
            Promise.resolve({
                frag: e,
                keyInfo: l
            });
        if ((r = l) != null && r.keyLoadPromise) {
            var c;
            switch ((c = l.mediaKeySessionContext) == null ? void 0 : c.keyStatus) {
            case "usable":
            case "usable-in-future":
                return l.keyLoadPromise.then(d => {
                    const {keyInfo: h} = d;
                    return i.key = h.decryptdata.key,
                    {
                        frag: e,
                        keyInfo: h
                    }
                }
                )
            }
        }
        switch (this.log(`Loading key ${It(i.keyId || [])} from ${e.type} ${e.level}`),
        l = this.keyIdToKeyInfo[o] = {
            decryptdata: i,
            keyLoadPromise: null,
            loader: null,
            mediaKeySessionContext: null
        },
        i.method) {
        case "SAMPLE-AES":
        case "SAMPLE-AES-CENC":
        case "SAMPLE-AES-CTR":
            return i.keyFormat === "identity" ? this.loadKeyHTTP(l, e) : this.loadKeyEME(l, e);
        case "AES-128":
        case "AES-256":
        case "AES-256-CTR":
            return this.loadKeyHTTP(l, e);
        default:
            return Promise.reject(this.createKeyLoadError(e, N.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${i.method}"`)))
        }
    }
    loadKeyEME(e, t) {
        const n = {
            frag: t,
            keyInfo: e
        };
        if (this.emeController && this.config.emeEnabled) {
            const r = this.emeController.loadKey(n);
            return (e.keyLoadPromise = r.then(i => (e.mediaKeySessionContext = i,
            n))).catch(i => {
                throw e.keyLoadPromise = null,
                i.data && (i.data.frag = t),
                i
            }
            )
        }
        return Promise.resolve(n)
    }
    loadKeyHTTP(e, t) {
        const n = this.config
          , r = n.loader
          , i = new r(n);
        return t.keyLoader = e.loader = i,
        e.keyLoadPromise = new Promise( (a, o) => {
            const l = {
                keyInfo: e,
                frag: t,
                responseType: "arraybuffer",
                url: e.decryptdata.uri
            }
              , c = n.keyLoadPolicy.default
              , u = {
                loadPolicy: c,
                timeout: c.maxLoadTimeMs,
                maxRetry: 0,
                retryDelay: 0,
                maxRetryDelay: 0
            }
              , d = {
                onSuccess: (h, f, m, p) => {
                    const {frag: x, keyInfo: y, url: v} = m
                      , E = Zl(y.decryptdata) || v;
                    if (!x.decryptdata || y !== this.keyIdToKeyInfo[E])
                        return o(this.createKeyLoadError(x, N.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), p));
                    y.decryptdata.key = x.decryptdata.key = new Uint8Array(h.data),
                    x.keyLoader = null,
                    y.loader = null,
                    a({
                        frag: x,
                        keyInfo: y
                    })
                }
                ,
                onError: (h, f, m, p) => {
                    this.resetLoader(f),
                    o(this.createKeyLoadError(t, N.KEY_LOAD_ERROR, new Error(`HTTP Error ${h.code} loading key ${h.text}`), m, pe({
                        url: l.url,
                        data: void 0
                    }, h)))
                }
                ,
                onTimeout: (h, f, m) => {
                    this.resetLoader(f),
                    o(this.createKeyLoadError(t, N.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), m))
                }
                ,
                onAbort: (h, f, m) => {
                    this.resetLoader(f),
                    o(this.createKeyLoadError(t, N.INTERNAL_ABORTED, new Error("key loading aborted"), m))
                }
            };
            i.load(l, u, d)
        }
        )
    }
    resetLoader(e) {
        const {frag: t, keyInfo: n, url: r} = e
          , i = n.loader;
        t.keyLoader === i && (t.keyLoader = null,
        n.loader = null);
        const a = Zl(n.decryptdata) || r;
        delete this.keyIdToKeyInfo[a],
        i && i.destroy()
    }
}
function Zl(s) {
    const e = s.keyId;
    return e ? It(e) : s.uri
}
function fm(s) {
    const {type: e} = s;
    switch (e) {
    case le.AUDIO_TRACK:
        return X.AUDIO;
    case le.SUBTITLE_TRACK:
        return X.SUBTITLE;
    default:
        return X.MAIN
    }
}
function ql(s, e) {
    let t = s.url;
    return (t === void 0 || t.indexOf("data:") === 0) && (t = e.url),
    t
}
class FA {
    constructor(e) {
        this.hls = void 0,
        this.loaders = Object.create(null),
        this.variableList = null,
        this.onManifestLoaded = this.checkAutostartLoad,
        this.hls = e,
        this.registerListeners()
    }
    startLoad(e) {}
    stopLoad() {
        this.destroyInternalLoaders()
    }
    registerListeners() {
        const {hls: e} = this;
        e.on(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.on(S.LEVEL_LOADING, this.onLevelLoading, this),
        e.on(S.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
        e.on(S.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this),
        e.on(S.LEVELS_UPDATED, this.onLevelsUpdated, this)
    }
    unregisterListeners() {
        const {hls: e} = this;
        e.off(S.MANIFEST_LOADING, this.onManifestLoading, this),
        e.off(S.LEVEL_LOADING, this.onLevelLoading, this),
        e.off(S.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this),
        e.off(S.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this),
        e.off(S.LEVELS_UPDATED, this.onLevelsUpdated, this)
    }
    createInternalLoader(e) {
        const t = this.hls.config
          , n = t.pLoader
          , r = t.loader
          , i = n || r
          , a = new i(t);
        return this.loaders[e.type] = a,
        a
    }
    getInternalLoader(e) {
        return this.loaders[e.type]
    }
    resetInternalLoader(e) {
        this.loaders[e] && delete this.loaders[e]
    }
    destroyInternalLoaders() {
        for (const e in this.loaders) {
            const t = this.loaders[e];
            t && t.destroy(),
            this.resetInternalLoader(e)
        }
    }
    destroy() {
        this.variableList = null,
        this.unregisterListeners(),
        this.destroyInternalLoaders()
    }
    onManifestLoading(e, t) {
        const {url: n} = t;
        this.variableList = null,
        this.load({
            id: null,
            level: 0,
            responseType: "text",
            type: le.MANIFEST,
            url: n,
            deliveryDirectives: null,
            levelOrTrack: null
        })
    }
    onLevelLoading(e, t) {
        const {id: n, level: r, pathwayId: i, url: a, deliveryDirectives: o, levelInfo: l} = t;
        this.load({
            id: n,
            level: r,
            pathwayId: i,
            responseType: "text",
            type: le.LEVEL,
            url: a,
            deliveryDirectives: o,
            levelOrTrack: l
        })
    }
    onAudioTrackLoading(e, t) {
        const {id: n, groupId: r, url: i, deliveryDirectives: a, track: o} = t;
        this.load({
            id: n,
            groupId: r,
            level: null,
            responseType: "text",
            type: le.AUDIO_TRACK,
            url: i,
            deliveryDirectives: a,
            levelOrTrack: o
        })
    }
    onSubtitleTrackLoading(e, t) {
        const {id: n, groupId: r, url: i, deliveryDirectives: a, track: o} = t;
        this.load({
            id: n,
            groupId: r,
            level: null,
            responseType: "text",
            type: le.SUBTITLE_TRACK,
            url: i,
            deliveryDirectives: a,
            levelOrTrack: o
        })
    }
    onLevelsUpdated(e, t) {
        const n = this.loaders[le.LEVEL];
        if (n) {
            const r = n.context;
            r && !t.levels.some(i => i === r.levelOrTrack) && (n.abort(),
            delete this.loaders[le.LEVEL])
        }
    }
    load(e) {
        var t;
        const n = this.hls.config;
        let r = this.getInternalLoader(e);
        if (r) {
            const c = this.hls.logger
              , u = r.context;
            if (u && u.levelOrTrack === e.levelOrTrack && (u.url === e.url || u.deliveryDirectives && !e.deliveryDirectives)) {
                u.url === e.url ? c.log(`[playlist-loader]: ignore ${e.url} ongoing request`) : c.log(`[playlist-loader]: ignore ${e.url} in favor of ${u.url}`);
                return
            }
            c.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`),
            r.abort()
        }
        let i;
        if (e.type === le.MANIFEST ? i = n.manifestLoadPolicy.default : i = ye({}, n.playlistLoadPolicy.default, {
            timeoutRetry: null,
            errorRetry: null
        }),
        r = this.createInternalLoader(e),
        z((t = e.deliveryDirectives) == null ? void 0 : t.part)) {
            let c;
            if (e.type === le.LEVEL && e.level !== null ? c = this.hls.levels[e.level].details : e.type === le.AUDIO_TRACK && e.id !== null ? c = this.hls.audioTracks[e.id].details : e.type === le.SUBTITLE_TRACK && e.id !== null && (c = this.hls.subtitleTracks[e.id].details),
            c) {
                const u = c.partTarget
                  , d = c.targetduration;
                if (u && d) {
                    const h = Math.max(u * 3, d * .8) * 1e3;
                    i = ye({}, i, {
                        maxTimeToFirstByteMs: Math.min(h, i.maxTimeToFirstByteMs),
                        maxLoadTimeMs: Math.min(h, i.maxTimeToFirstByteMs)
                    })
                }
            }
        }
        const a = i.errorRetry || i.timeoutRetry || {}
          , o = {
            loadPolicy: i,
            timeout: i.maxLoadTimeMs,
            maxRetry: a.maxNumRetry || 0,
            retryDelay: a.retryDelayMs || 0,
            maxRetryDelay: a.maxRetryDelayMs || 0
        }
          , l = {
            onSuccess: (c, u, d, h) => {
                const f = this.getInternalLoader(d);
                this.resetInternalLoader(d.type);
                const m = c.data;
                if (m.indexOf("#EXTM3U") !== 0) {
                    this.handleManifestParsingError(c, d, new Error("no EXTM3U delimiter"), h || null, u);
                    return
                }
                u.parsing.start = performance.now(),
                cs.isMediaPlaylist(m) || d.type !== le.MANIFEST ? this.handleTrackOrLevelPlaylist(c, u, d, h || null, f) : this.handleMasterPlaylist(c, u, d, h)
            }
            ,
            onError: (c, u, d, h) => {
                this.handleNetworkError(u, d, !1, c, h)
            }
            ,
            onTimeout: (c, u, d) => {
                this.handleNetworkError(u, d, !0, void 0, c)
            }
        };
        r.load(e, o, l)
    }
    checkAutostartLoad() {
        if (!this.hls)
            return;
        const {config: {autoStartLoad: e, startPosition: t}, forceStartLoad: n} = this.hls;
        (e || n) && (this.hls.logger.log(`${e ? "auto" : "force"} startLoad with configured startPosition ${t}`),
        this.hls.startLoad(t))
    }
    handleMasterPlaylist(e, t, n, r) {
        const i = this.hls
          , a = e.data
          , o = ql(e, n)
          , l = cs.parseMasterPlaylist(a, o);
        if (l.playlistParsingError) {
            this.handleManifestParsingError(e, n, l.playlistParsingError, r, t);
            return
        }
        const {contentSteering: c, levels: u, sessionData: d, sessionKeys: h, startTimeOffset: f, variableList: m} = l;
        this.variableList = m;
        const {AUDIO: p=[], SUBTITLES: x, "CLOSED-CAPTIONS": y} = cs.parseMasterPlaylistMedia(a, o, l);
        p.length && !p.some(E => !E.url) && u[0].audioCodec && !u[0].attrs.AUDIO && (this.hls.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"),
        p.unshift({
            type: "main",
            name: "main",
            groupId: "main",
            default: !1,
            autoselect: !1,
            forced: !1,
            id: -1,
            attrs: new Ae({}),
            bitrate: 0,
            url: ""
        })),
        i.trigger(S.MANIFEST_LOADED, {
            levels: u,
            audioTracks: p,
            subtitles: x,
            captions: y,
            contentSteering: c,
            url: o,
            stats: t,
            networkDetails: r,
            sessionData: d,
            sessionKeys: h,
            startTimeOffset: f,
            variableList: m
        })
    }
    handleTrackOrLevelPlaylist(e, t, n, r, i) {
        const a = this.hls
          , {id: o, level: l, type: c} = n
          , u = ql(e, n)
          , d = z(l) ? l : z(o) ? o : 0
          , h = fm(n)
          , f = cs.parseLevelPlaylist(e.data, u, d, h, 0, this.variableList);
        if (c === le.MANIFEST) {
            const m = {
                attrs: new Ae({}),
                bitrate: 0,
                details: f,
                name: "",
                url: u
            };
            f.requestScheduled = t.loading.start + v0(f, 0),
            a.trigger(S.MANIFEST_LOADED, {
                levels: [m],
                audioTracks: [],
                url: u,
                stats: t,
                networkDetails: r,
                sessionData: null,
                sessionKeys: null,
                contentSteering: null,
                startTimeOffset: null,
                variableList: null
            })
        }
        t.parsing.end = performance.now(),
        n.levelDetails = f,
        this.handlePlaylistLoaded(f, e, t, n, r, i)
    }
    handleManifestParsingError(e, t, n, r, i) {
        this.hls.trigger(S.ERROR, {
            type: q.NETWORK_ERROR,
            details: N.MANIFEST_PARSING_ERROR,
            fatal: t.type === le.MANIFEST,
            url: e.url,
            err: n,
            error: n,
            reason: n.message,
            response: e,
            context: t,
            networkDetails: r,
            stats: i
        })
    }
    handleNetworkError(e, t, n=!1, r, i) {
        let a = `A network ${n ? "timeout" : "error" + (r ? " (status " + r.code + ")" : "")} occurred while loading ${e.type}`;
        e.type === le.LEVEL ? a += `: ${e.level} id: ${e.id}` : (e.type === le.AUDIO_TRACK || e.type === le.SUBTITLE_TRACK) && (a += ` id: ${e.id} group-id: "${e.groupId}"`);
        const o = new Error(a);
        this.hls.logger.warn(`[playlist-loader]: ${a}`);
        let l = N.UNKNOWN
          , c = !1;
        const u = this.getInternalLoader(e);
        switch (e.type) {
        case le.MANIFEST:
            l = n ? N.MANIFEST_LOAD_TIMEOUT : N.MANIFEST_LOAD_ERROR,
            c = !0;
            break;
        case le.LEVEL:
            l = n ? N.LEVEL_LOAD_TIMEOUT : N.LEVEL_LOAD_ERROR,
            c = !1;
            break;
        case le.AUDIO_TRACK:
            l = n ? N.AUDIO_TRACK_LOAD_TIMEOUT : N.AUDIO_TRACK_LOAD_ERROR,
            c = !1;
            break;
        case le.SUBTITLE_TRACK:
            l = n ? N.SUBTITLE_TRACK_LOAD_TIMEOUT : N.SUBTITLE_LOAD_ERROR,
            c = !1;
            break
        }
        u && this.resetInternalLoader(e.type);
        const d = {
            type: q.NETWORK_ERROR,
            details: l,
            fatal: c,
            url: e.url,
            loader: u,
            context: e,
            error: o,
            networkDetails: t,
            stats: i
        };
        if (r) {
            const h = (t == null ? void 0 : t.url) || e.url;
            d.response = pe({
                url: h,
                data: void 0
            }, r)
        }
        this.hls.trigger(S.ERROR, d)
    }
    handlePlaylistLoaded(e, t, n, r, i, a) {
        const o = this.hls
          , {type: l, level: c, id: u, groupId: d, deliveryDirectives: h} = r
          , f = ql(t, r)
          , m = fm(r)
          , p = typeof r.level == "number" && m === X.MAIN ? c : void 0;
        if (!e.fragments.length) {
            const y = e.playlistParsingError = new Error("No Segments found in Playlist");
            o.trigger(S.ERROR, {
                type: q.NETWORK_ERROR,
                details: N.LEVEL_EMPTY_ERROR,
                fatal: !1,
                url: f,
                error: y,
                reason: y.message,
                response: t,
                context: r,
                level: p,
                parent: m,
                networkDetails: i,
                stats: n
            });
            return
        }
        e.targetduration || (e.playlistParsingError = new Error("Missing Target Duration"));
        const x = e.playlistParsingError;
        if (x) {
            if (this.hls.logger.warn(`${x} ${e.url}`),
            !o.config.ignorePlaylistParsingErrors) {
                o.trigger(S.ERROR, {
                    type: q.NETWORK_ERROR,
                    details: N.LEVEL_PARSING_ERROR,
                    fatal: !1,
                    url: f,
                    error: x,
                    reason: x.message,
                    response: t,
                    context: r,
                    level: p,
                    parent: m,
                    networkDetails: i,
                    stats: n
                });
                return
            }
            e.playlistParsingError = null
        }
        switch (e.live && a && (a.getCacheAge && (e.ageHeader = a.getCacheAge() || 0),
        (!a.getCacheAge || isNaN(e.ageHeader)) && (e.ageHeader = 0)),
        l) {
        case le.MANIFEST:
        case le.LEVEL:
            o.trigger(S.LEVEL_LOADED, {
                details: e,
                levelInfo: r.levelOrTrack || o.levels[0],
                level: p || 0,
                id: u || 0,
                stats: n,
                networkDetails: i,
                deliveryDirectives: h,
                withoutMultiVariant: l === le.MANIFEST
            });
            break;
        case le.AUDIO_TRACK:
            o.trigger(S.AUDIO_TRACK_LOADED, {
                details: e,
                track: r.levelOrTrack,
                id: u || 0,
                groupId: d || "",
                stats: n,
                networkDetails: i,
                deliveryDirectives: h
            });
            break;
        case le.SUBTITLE_TRACK:
            o.trigger(S.SUBTITLE_TRACK_LOADED, {
                details: e,
                track: r.levelOrTrack,
                id: u || 0,
                groupId: d || "",
                stats: n,
                networkDetails: i,
                deliveryDirectives: h
            });
            break
        }
    }
}
class ot {
    static get version() {
        return Ri
    }
    static isMSESupported() {
        return xy()
    }
    static isSupported() {
        return DA()
    }
    static getMediaSource() {
        return on()
    }
    static get Events() {
        return S
    }
    static get MetadataSchema() {
        return At
    }
    static get ErrorTypes() {
        return q
    }
    static get ErrorDetails() {
        return N
    }
    static get DefaultConfig() {
        return ot.defaultConfig ? ot.defaultConfig : EA
    }
    static set DefaultConfig(e) {
        ot.defaultConfig = e
    }
    constructor(e={}) {
        this.config = void 0,
        this.userConfig = void 0,
        this.logger = void 0,
        this.coreComponents = void 0,
        this.networkControllers = void 0,
        this._emitter = new Td,
        this._autoLevelCapping = -1,
        this._maxHdcpLevel = null,
        this.abrController = void 0,
        this.bufferController = void 0,
        this.capLevelController = void 0,
        this.latencyController = void 0,
        this.levelController = void 0,
        this.streamController = void 0,
        this.audioStreamController = void 0,
        this.subtititleStreamController = void 0,
        this.audioTrackController = void 0,
        this.subtitleTrackController = void 0,
        this.interstitialsController = void 0,
        this.gapController = void 0,
        this.emeController = void 0,
        this.cmcdController = void 0,
        this._media = null,
        this._url = null,
        this._sessionId = void 0,
        this.triggeringException = void 0,
        this.started = !1;
        const t = this.logger = KS(e.debug || !1, "Hls instance", e.assetPlayerId)
          , n = this.config = TA(ot.DefaultConfig, e, t);
        this.userConfig = e,
        n.progressive && LA(n, t);
        const {abrController: r, bufferController: i, capLevelController: a, errorController: o, fpsController: l} = n
          , c = new o(this)
          , u = this.abrController = new r(this)
          , d = new FT(this)
          , h = n.interstitialsController
          , f = h ? this.interstitialsController = new h(this,ot) : null
          , m = this.bufferController = new i(this,d)
          , p = this.capLevelController = new a(this)
          , x = new l(this)
          , y = new FA(this)
          , v = n.contentSteeringController
          , E = v ? new v(this) : null
          , T = this.levelController = new _A(this,E)
          , L = new CA(this)
          , R = new MA(this.config,this.logger)
          , I = this.streamController = new OA(this,d,R)
          , A = this.gapController = new RA(this,d);
        p.setStreamController(I),
        x.setStreamController(I);
        const C = [y, T, I];
        f && C.splice(1, 0, f),
        E && C.splice(1, 0, E),
        this.networkControllers = C;
        const b = [u, m, A, p, x, L, d];
        this.audioTrackController = this.createController(n.audioTrackController, C);
        const O = n.audioStreamController;
        O && C.push(this.audioStreamController = new O(this,d,R)),
        this.subtitleTrackController = this.createController(n.subtitleTrackController, C);
        const _ = n.subtitleStreamController;
        _ && C.push(this.subtititleStreamController = new _(this,d,R)),
        this.createController(n.timelineController, b),
        R.emeController = this.emeController = this.createController(n.emeController, b),
        this.cmcdController = this.createController(n.cmcdController, b),
        this.latencyController = this.createController(kA, b),
        this.coreComponents = b,
        C.push(c);
        const $ = c.onErrorOut;
        typeof $ == "function" && this.on(S.ERROR, $, c),
        this.on(S.MANIFEST_LOADED, y.onManifestLoaded, y)
    }
    createController(e, t) {
        if (e) {
            const n = new e(this);
            return t && t.push(n),
            n
        }
        return null
    }
    on(e, t, n=this) {
        this._emitter.on(e, t, n)
    }
    once(e, t, n=this) {
        this._emitter.once(e, t, n)
    }
    removeAllListeners(e) {
        this._emitter.removeAllListeners(e)
    }
    off(e, t, n=this, r) {
        this._emitter.off(e, t, n, r)
    }
    listeners(e) {
        return this._emitter.listeners(e)
    }
    emit(e, t, n) {
        return this._emitter.emit(e, t, n)
    }
    trigger(e, t) {
        if (this.config.debug)
            return this.emit(e, e, t);
        try {
            return this.emit(e, e, t)
        } catch (n) {
            if (this.logger.error("An internal error happened while handling event " + e + '. Error message: "' + n.message + '". Here is a stacktrace:', n),
            !this.triggeringException) {
                this.triggeringException = !0;
                const r = e === S.ERROR;
                this.trigger(S.ERROR, {
                    type: q.OTHER_ERROR,
                    details: N.INTERNAL_EXCEPTION,
                    fatal: r,
                    event: e,
                    error: n
                }),
                this.triggeringException = !1
            }
        }
        return !1
    }
    listenerCount(e) {
        return this._emitter.listenerCount(e)
    }
    destroy() {
        this.logger.log("destroy"),
        this.trigger(S.DESTROYING, void 0),
        this.detachMedia(),
        this.removeAllListeners(),
        this._autoLevelCapping = -1,
        this._url = null,
        this.networkControllers.forEach(t => t.destroy()),
        this.networkControllers.length = 0,
        this.coreComponents.forEach(t => t.destroy()),
        this.coreComponents.length = 0;
        const e = this.config;
        e.xhrSetup = e.fetchSetup = void 0,
        this.userConfig = null
    }
    attachMedia(e) {
        if (!e || "media"in e && !e.media) {
            const i = new Error(`attachMedia failed: invalid argument (${e})`);
            this.trigger(S.ERROR, {
                type: q.OTHER_ERROR,
                details: N.ATTACH_MEDIA_ERROR,
                fatal: !0,
                error: i
            });
            return
        }
        this.logger.log("attachMedia"),
        this._media && (this.logger.warn("media must be detached before attaching"),
        this.detachMedia());
        const t = "media"in e
          , n = t ? e.media : e
          , r = t ? e : {
            media: n
        };
        this._media = n,
        this.trigger(S.MEDIA_ATTACHING, r)
    }
    detachMedia() {
        this.logger.log("detachMedia"),
        this.trigger(S.MEDIA_DETACHING, {}),
        this._media = null
    }
    transferMedia() {
        this._media = null;
        const e = this.bufferController.transferMedia();
        return this.trigger(S.MEDIA_DETACHING, {
            transferMedia: e
        }),
        e
    }
    loadSource(e) {
        this.stopLoad();
        const t = this.media
          , n = this._url
          , r = this._url = dd.buildAbsoluteURL(self.location.href, e, {
            alwaysNormalize: !0
        });
        this._autoLevelCapping = -1,
        this._maxHdcpLevel = null,
        this.logger.log(`loadSource:${r}`),
        t && n && (n !== r || this.bufferController.hasSourceTypes()) && (this.detachMedia(),
        this.attachMedia(t)),
        this.trigger(S.MANIFEST_LOADING, {
            url: e
        })
    }
    get url() {
        return this._url
    }
    get hasEnoughToStart() {
        return this.streamController.hasEnoughToStart
    }
    get startPosition() {
        return this.streamController.startPositionValue
    }
    startLoad(e=-1, t) {
        this.logger.log(`startLoad(${e + (t ? ", <skip seek to start>" : "")})`),
        this.started = !0,
        this.resumeBuffering();
        for (let n = 0; n < this.networkControllers.length && (this.networkControllers[n].startLoad(e, t),
        !(!this.started || !this.networkControllers)); n++)
            ;
    }
    stopLoad() {
        this.logger.log("stopLoad"),
        this.started = !1;
        for (let e = 0; e < this.networkControllers.length && (this.networkControllers[e].stopLoad(),
        !(this.started || !this.networkControllers)); e++)
            ;
    }
    get loadingEnabled() {
        return this.started
    }
    get bufferingEnabled() {
        return this.streamController.bufferingEnabled
    }
    resumeBuffering() {
        this.bufferingEnabled || (this.logger.log("resume buffering"),
        this.networkControllers.forEach(e => {
            e.resumeBuffering && e.resumeBuffering()
        }
        ))
    }
    pauseBuffering() {
        this.bufferingEnabled && (this.logger.log("pause buffering"),
        this.networkControllers.forEach(e => {
            e.pauseBuffering && e.pauseBuffering()
        }
        ))
    }
    get inFlightFragments() {
        const e = {
            [X.MAIN]: this.streamController.inFlightFrag
        };
        return this.audioStreamController && (e[X.AUDIO] = this.audioStreamController.inFlightFrag),
        this.subtititleStreamController && (e[X.SUBTITLE] = this.subtititleStreamController.inFlightFrag),
        e
    }
    swapAudioCodec() {
        this.logger.log("swapAudioCodec"),
        this.streamController.swapAudioCodec()
    }
    recoverMediaError() {
        this.logger.log("recoverMediaError");
        const e = this._media
          , t = e == null ? void 0 : e.currentTime;
        this.detachMedia(),
        e && (this.attachMedia(e),
        t && this.startLoad(t))
    }
    removeLevel(e) {
        this.levelController.removeLevel(e)
    }
    get sessionId() {
        let e = this._sessionId;
        return e || (e = this._sessionId = RI()),
        e
    }
    get levels() {
        const e = this.levelController.levels;
        return e || []
    }
    get latestLevelDetails() {
        return this.streamController.getLevelDetails() || null
    }
    get loadLevelObj() {
        return this.levelController.loadLevelObj
    }
    get currentLevel() {
        return this.streamController.currentLevel
    }
    set currentLevel(e) {
        this.logger.log(`set currentLevel:${e}`),
        this.levelController.manualLevel = e,
        this.streamController.immediateLevelSwitch()
    }
    get nextLevel() {
        return this.streamController.nextLevel
    }
    set nextLevel(e) {
        this.logger.log(`set nextLevel:${e}`),
        this.levelController.manualLevel = e,
        this.streamController.nextLevelSwitch()
    }
    get loadLevel() {
        return this.levelController.level
    }
    set loadLevel(e) {
        this.logger.log(`set loadLevel:${e}`),
        this.levelController.manualLevel = e
    }
    get nextLoadLevel() {
        return this.levelController.nextLoadLevel
    }
    set nextLoadLevel(e) {
        this.levelController.nextLoadLevel = e
    }
    get firstLevel() {
        return Math.max(this.levelController.firstLevel, this.minAutoLevel)
    }
    set firstLevel(e) {
        this.logger.log(`set firstLevel:${e}`),
        this.levelController.firstLevel = e
    }
    get startLevel() {
        const e = this.levelController.startLevel;
        return e === -1 && this.abrController.forcedAutoLevel > -1 ? this.abrController.forcedAutoLevel : e
    }
    set startLevel(e) {
        this.logger.log(`set startLevel:${e}`),
        e !== -1 && (e = Math.max(e, this.minAutoLevel)),
        this.levelController.startLevel = e
    }
    get capLevelToPlayerSize() {
        return this.config.capLevelToPlayerSize
    }
    set capLevelToPlayerSize(e) {
        const t = !!e;
        t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(),
        this.autoLevelCapping = -1,
        this.streamController.nextLevelSwitch()),
        this.config.capLevelToPlayerSize = t)
    }
    get autoLevelCapping() {
        return this._autoLevelCapping
    }
    get bandwidthEstimate() {
        const {bwEstimator: e} = this.abrController;
        return e ? e.getEstimate() : NaN
    }
    set bandwidthEstimate(e) {
        this.abrController.resetEstimator(e)
    }
    get abrEwmaDefaultEstimate() {
        const {bwEstimator: e} = this.abrController;
        return e ? e.defaultEstimate : NaN
    }
    get ttfbEstimate() {
        const {bwEstimator: e} = this.abrController;
        return e ? e.getEstimateTTFB() : NaN
    }
    set autoLevelCapping(e) {
        this._autoLevelCapping !== e && (this.logger.log(`set autoLevelCapping:${e}`),
        this._autoLevelCapping = e,
        this.levelController.checkMaxAutoUpdated())
    }
    get maxHdcpLevel() {
        return this._maxHdcpLevel
    }
    set maxHdcpLevel(e) {
        ST(e) && this._maxHdcpLevel !== e && (this._maxHdcpLevel = e,
        this.levelController.checkMaxAutoUpdated())
    }
    get autoLevelEnabled() {
        return this.levelController.manualLevel === -1
    }
    get manualLevel() {
        return this.levelController.manualLevel
    }
    get minAutoLevel() {
        const {levels: e, config: {minAutoBitrate: t}} = this;
        if (!e)
            return 0;
        const n = e.length;
        for (let r = 0; r < n; r++)
            if (e[r].maxBitrate >= t)
                return r;
        return 0
    }
    get maxAutoLevel() {
        const {levels: e, autoLevelCapping: t, maxHdcpLevel: n} = this;
        let r;
        if (t === -1 && e != null && e.length ? r = e.length - 1 : r = t,
        n)
            for (let i = r; i--; ) {
                const a = e[i].attrs["HDCP-LEVEL"];
                if (a && a <= n)
                    return i
            }
        return r
    }
    get firstAutoLevel() {
        return this.abrController.firstAutoLevel
    }
    get nextAutoLevel() {
        return this.abrController.nextAutoLevel
    }
    set nextAutoLevel(e) {
        this.abrController.nextAutoLevel = e
    }
    get playingDate() {
        return this.streamController.currentProgramDateTime
    }
    get mainForwardBufferInfo() {
        return this.streamController.getMainFwdBufferInfo()
    }
    get maxBufferLength() {
        return this.streamController.maxBufferLength
    }
    setAudioOption(e) {
        var t;
        return ((t = this.audioTrackController) == null ? void 0 : t.setAudioOption(e)) || null
    }
    setSubtitleOption(e) {
        var t;
        return ((t = this.subtitleTrackController) == null ? void 0 : t.setSubtitleOption(e)) || null
    }
    get allAudioTracks() {
        const e = this.audioTrackController;
        return e ? e.allAudioTracks : []
    }
    get audioTracks() {
        const e = this.audioTrackController;
        return e ? e.audioTracks : []
    }
    get audioTrack() {
        const e = this.audioTrackController;
        return e ? e.audioTrack : -1
    }
    set audioTrack(e) {
        const t = this.audioTrackController;
        t && (t.audioTrack = e)
    }
    get allSubtitleTracks() {
        const e = this.subtitleTrackController;
        return e ? e.allSubtitleTracks : []
    }
    get subtitleTracks() {
        const e = this.subtitleTrackController;
        return e ? e.subtitleTracks : []
    }
    get subtitleTrack() {
        const e = this.subtitleTrackController;
        return e ? e.subtitleTrack : -1
    }
    get media() {
        return this._media
    }
    set subtitleTrack(e) {
        const t = this.subtitleTrackController;
        t && (t.subtitleTrack = e)
    }
    get subtitleDisplay() {
        const e = this.subtitleTrackController;
        return e ? e.subtitleDisplay : !1
    }
    set subtitleDisplay(e) {
        const t = this.subtitleTrackController;
        t && (t.subtitleDisplay = e)
    }
    get lowLatencyMode() {
        return this.config.lowLatencyMode
    }
    set lowLatencyMode(e) {
        this.config.lowLatencyMode = e
    }
    get liveSyncPosition() {
        return this.latencyController.liveSyncPosition
    }
    get latency() {
        return this.latencyController.latency
    }
    get maxLatency() {
        return this.latencyController.maxLatency
    }
    get targetLatency() {
        return this.latencyController.targetLatency
    }
    set targetLatency(e) {
        this.latencyController.targetLatency = e
    }
    get drift() {
        return this.latencyController.drift
    }
    get forceStartLoad() {
        return this.streamController.forceStartLoad
    }
    get pathways() {
        return this.levelController.pathways
    }
    get pathwayPriority() {
        return this.levelController.pathwayPriority
    }
    set pathwayPriority(e) {
        this.levelController.pathwayPriority = e
    }
    get bufferedToEnd() {
        var e;
        return !!((e = this.bufferController) != null && e.bufferedToEnd)
    }
    get interstitialsManager() {
        var e;
        return ((e = this.interstitialsController) == null ? void 0 : e.interstitialsManager) || null
    }
    getMediaDecodingInfo(e, t=this.allAudioTracks) {
        const n = l0(t);
        return a0(e, n, navigator.mediaCapabilities)
    }
}
ot.defaultConfig = void 0;
const Od = ({src: s, title: e, onClose: t}) => {
    const n = w.useRef(null)
      , r = w.useRef(null)
      , i = w.useRef(null)
      , a = w.useRef(null)
      , [o,l] = w.useState(!1)
      , [c,u] = w.useState(!1)
      , [d,h] = w.useState(0)
      , [f,m] = w.useState(0)
      , [p,x] = w.useState(1)
      , [y,v] = w.useState(!1)
      , [E,T] = w.useState(!0)
      , [L,R] = w.useState(!0)
      , [I,A] = w.useState(null)
      , [C,b] = w.useState(1)
      , [O,_] = w.useState(!1)
      , [$,K] = w.useState(!1)
      , [W,G] = w.useState(4)
      , [V,D] = w.useState(!1)
      , [B,k] = w.useState(!1)
      , [F,j] = w.useState("")
      , [J,re] = w.useState(0)
      , [Q] = w.useState(3)
      , [se,Le] = w.useState([])
      , [ke,Ne] = w.useState(!1)
      , Dt = [.25, .5, .75, 1, 1.25, 1.5, 1.75, 2]
      , Oe = [{
        level: 1,
        height: 240,
        label: "240p",
        pattern: "_video_VOD240p30.m3u8"
    }, {
        level: 2,
        height: 360,
        label: "360p",
        pattern: "_video_VOD360p30.m3u8"
    }, {
        level: 3,
        height: 480,
        label: "480p",
        pattern: "_video_VOD480p30.m3u8"
    }, {
        level: 4,
        height: 720,
        label: "720p",
        pattern: "_video_VOD720p30.m3u8"
    }];
    w.useEffect( () => {
        const M = s.match(/url=(.+)/)
          , Z = M ? decodeURIComponent(M[1]) : s
          , te = Z.match(/^(.+)_video_VOD\d+p\d+\.m3u8$/);
        if (te)
            j(te[1]),
            console.log(" CloudFront base URL extracted:", te[1]);
        else {
            const ee = Z.match(/^(.+\/)(?:index_\d+\.m3u8|[^/]+\.m3u8)$/);
            ee ? (j(ee[1]),
            console.log(" Index base URL extracted:", ee[1])) : (j(Z.replace(/[^/]+\.m3u8$/, "")),
            console.log(" Fallback base URL:", Z.replace(/[^/]+\.m3u8$/, "")))
        }
    }
    , [s]);
    const ys = M => {
        const Z = Oe.find(ge => ge.level === M);
        if (!Z || !F)
            return console.log(" Quality or base URL not found:", {
                qualityLevel: M,
                baseUrl: F
            }),
            s;
        const te = s.match(/url=(.+)/)
          , ee = te ? decodeURIComponent(te[1]) : s;
        let ue;
        return ee.includes("_video_VOD") && ee.includes(".m3u8") ? ue = `${F}${Z.pattern}` : F.endsWith("/") ? ue = `${F}index_${Z.level}.m3u8` : ue = `${F}${Z.pattern}`,
        console.log(` Generated ${Z.label} URL:`, ue),
        ue
    }
      , Fn = () => {
        a.current && (clearTimeout(a.current),
        a.current = null)
    }
      , fn = (M, Z, te=!1) => {
        var ue;
        if (Z >= Q) {
            !ke && !te ? (console.log(" Max retries reached, trying quality fallback..."),
            Ne(!0),
            Bi(M)) : (A(`Failed to load ${(ue = Oe.find(ge => ge.level === M)) == null ? void 0 : ue.label} quality after ${Q} attempts. Please try another quality or check your connection.`),
            R(!1));
            return
        }
        const ee = Math.min(1e3 * Math.pow(2, Z), 5e3);
        console.log(` Retrying in ${ee}ms (attempt ${Z + 1}/${Q})`),
        a.current = setTimeout( () => {
            re(Z + 1),
            oe(M, Z + 1, te)
        }
        , ee)
    }
      , Bi = M => {
        console.log(" Attempting quality fallback from:", M);
        const Z = Oe.filter(ee => ee.level < M).sort( (ee, ue) => ue.level - ee.level);
        if (Z.length === 0) {
            A("No compatible video quality found. The video may not be available."),
            R(!1);
            return
        }
        const te = Z[0];
        console.log(` Falling back to ${te.label}...`),
        re(0),
        oe(te.level, 0, !0)
    }
      , oe = (M, Z=0, te=!1) => {
        var Xe;
        const ee = n.current;
        if (!ee)
            return;
        Fn(),
        Z === 0 && (re(0),
        te || Ne(!1)),
        R(!0),
        A(null);
        const ue = ys(M)
          , ge = ((Xe = Oe.find(Ke => Ke.level === M)) == null ? void 0 : Xe.label) || "Unknown";
        if (console.log(` Loading video with ${ge} (attempt ${Z + 1}):`, ue),
        i.current && (i.current.destroy(),
        i.current = null),
        ot.isSupported()) {
            const Ke = new ot({
                enableWorker: !0,
                lowLatencyMode: !1,
                backBufferLength: 90,
                maxBufferLength: 60,
                maxMaxBufferLength: 1200,
                debug: !1,
                maxLoadingDelay: 10,
                maxBufferHole: 2,
                highBufferWatchdogPeriod: 5,
                nudgeOffset: .1,
                nudgeMaxRetry: 3,
                maxFragLookUpTolerance: .25,
                liveSyncDurationCount: 3,
                liveMaxLatencyDurationCount: 10,
                fragLoadingTimeOut: 2e4,
                manifestLoadingTimeOut: 1e4,
                levelLoadingTimeOut: 1e4
            });
            i.current = Ke,
            Ke.loadSource(ue),
            Ke.attachMedia(ee),
            Ke.on(ot.Events.MANIFEST_PARSED, (Vt, $e) => {
                console.log(" Manifest parsed for quality:", M, $e),
                R(!1),
                G(M),
                re(0),
                Ne(!1),
                se.includes(M) || Le(Dr => [...Dr, M].sort( (Jo, vy) => vy - Jo))
            }
            ),
            Ke.on(ot.Events.ERROR, (Vt, $e) => {
                if (console.log(" HLS Error:", $e.type, $e.details, $e.fatal ? "(FATAL)" : "(NON-FATAL)"),
                $e.fatal)
                    switch ($e.type) {
                    case ot.ErrorTypes.NETWORK_ERROR:
                        console.log(" Network error detected, attempting retry..."),
                        fn(M, Z, te);
                        break;
                    case ot.ErrorTypes.MEDIA_ERROR:
                        console.log(" Media error detected, attempting recovery...");
                        try {
                            Ke.recoverMediaError()
                        } catch (Dr) {
                            console.error(" Media recovery failed:", Dr),
                            fn(M, Z, te)
                        }
                        break;
                    default:
                        console.error(" Unrecoverable HLS error:", $e),
                        !ke && !te ? (console.log(" Unrecoverable error, trying quality fallback..."),
                        Ne(!0),
                        Bi(M)) : (A(`Failed to load ${ge} quality. Please try another quality.`),
                        R(!1));
                        break
                    }
                else
                    console.log(" Non-fatal HLS error:", $e.details)
            }
            ),
            Ke.on(ot.Events.FRAG_LOAD_ERROR, (Vt, $e) => {
                console.log(" Fragment load error:", $e)
            }
            ),
            Ke.on(ot.Events.LEVEL_LOAD_ERROR, (Vt, $e) => {
                console.log(" Level load error:", $e)
            }
            )
        } else if (ee.canPlayType("application/vnd.apple.mpegurl")) {
            console.log(" Using Safari native HLS for quality:", M),
            ee.src = ue,
            ee.preload = "metadata",
            ee.crossOrigin = "anonymous";
            const Ke = () => {
                R(!1),
                G(M),
                re(0),
                Ne(!1),
                console.log(` Safari video loaded with ${ge}`),
                se.includes(M) || Le($e => [...$e, M].sort( (Dr, Jo) => Jo - Dr)),
                ee.removeEventListener("loadedmetadata", Ke),
                ee.removeEventListener("error", Vt)
            }
              , Vt = $e => {
                console.error(" Safari video error:", $e),
                ee.removeEventListener("loadedmetadata", Ke),
                ee.removeEventListener("error", Vt),
                Z < Q || !ke && !te ? Z < Q ? fn(M, Z, te) : !ke && !te && (console.log(" Safari: Max retries reached, trying quality fallback..."),
                Ne(!0),
                Bi(M)) : (A(`Failed to load ${ge} quality after ${Q} attempts. Please try another quality.`),
                R(!1))
            }
            ;
            ee.addEventListener("loadedmetadata", Ke),
            ee.addEventListener("error", Vt)
        } else
            console.log(" HLS not supported"),
            A("HLS is not supported in this browser."),
            R(!1)
    }
    ;
    w.useEffect( () => {
        F && oe(W)
    }
    , [F]),
    w.useEffect( () => {
        const M = n.current;
        if (!M)
            return;
        const Z = () => h(M.currentTime)
          , te = () => m(M.duration)
          , ee = () => l(!0)
          , ue = () => l(!1);
        return M.addEventListener("timeupdate", Z),
        M.addEventListener("loadedmetadata", te),
        M.addEventListener("play", ee),
        M.addEventListener("pause", ue),
        () => {
            M.removeEventListener("timeupdate", Z),
            M.removeEventListener("loadedmetadata", te),
            M.removeEventListener("play", ee),
            M.removeEventListener("pause", ue)
        }
    }
    , []),
    w.useEffect( () => {
        const M = () => {
            v(!!document.fullscreenElement)
        }
        ;
        return document.addEventListener("fullscreenchange", M),
        () => document.removeEventListener("fullscreenchange", M)
    }
    , []),
    w.useEffect( () => {
        const M = n.current;
        M && (M.playbackRate = C)
    }
    , [C]),
    w.useEffect( () => () => {
        Fn(),
        i.current && (i.current.destroy(),
        i.current = null)
    }
    , []);
    const Be = () => {
        const M = n.current;
        M && (o ? M.pause() : M.play())
    }
      , ht = () => {
        const M = n.current;
        M && (M.muted = !M.muted,
        u(M.muted))
    }
      , xs = M => {
        const Z = n.current;
        if (!Z)
            return;
        const te = parseFloat(M.target.value);
        Z.volume = te,
        x(te),
        u(te === 0)
    }
      , St = M => {
        const Z = n.current;
        if (!Z)
            return;
        const te = parseFloat(M.target.value);
        Z.currentTime = te,
        h(te)
    }
      , Fs = async () => {
        const M = r.current;
        if (M)
            try {
                y ? document.exitFullscreen && await document.exitFullscreen() : M.requestFullscreen && await M.requestFullscreen()
            } catch (Z) {
                console.error("Fullscreen error:", Z)
            }
    }
      , vs = M => {
        b(M),
        _(!1)
    }
      , _r = M => {
        console.log(" Changing quality to level:", M),
        Ne(!1);
        const Z = n.current
          , te = Z ? Z.currentTime : 0
          , ee = o;
        if (oe(M),
        Z) {
            const ue = () => {
                Z.currentTime = te,
                ee && Z.play(),
                Z.removeEventListener("loadedmetadata", ue)
            }
            ;
            Z.addEventListener("loadedmetadata", ue)
        }
        _(!1)
    }
      , mn = M => {
        const Z = Math.floor(M / 60)
          , te = Math.floor(M % 60);
        return `${Z}:${te.toString().padStart(2, "0")}`
    }
      , $i = () => {
        A(null),
        re(0),
        Ne(!1),
        oe(W)
    }
      , gn = () => {
        K(!0)
    }
      , Un = async M => {
        var Z;
        D(!0);
        try {
            const te = M || W
              , ee = ys(te)
              , ue = ((Z = Oe.find(ge => ge.level === te)) == null ? void 0 : Z.label) || "Unknown";
            await navigator.clipboard.writeText(ee),
            k(!0),
            K(!1),
            setTimeout( () => {
                k(!1)
            }
            , 3e3),
            console.log(` ${ue} download link copied:`, ee)
        } catch (te) {
            console.error(" Failed to copy link:", te);
            try {
                const ue = ys(M || W)
                  , ge = document.createElement("textarea");
                ge.value = ue,
                ge.style.position = "fixed",
                ge.style.left = "-999999px",
                ge.style.top = "-999999px",
                document.body.appendChild(ge),
                ge.focus(),
                ge.select();
                const Xe = document.execCommand("copy");
                document.body.removeChild(ge),
                Xe ? (k(!0),
                K(!1),
                setTimeout( () => k(!1), 3e3)) : alert(`Download link: ${ue}`)
            } catch (ee) {
                console.error(" Fallback copy also failed:", ee);
                const ge = ys(M || W);
                alert(`Download link: ${ge}`)
            }
        } finally {
            D(!1)
        }
    }
      , Qo = async () => {
        D(!0);
        try {
            const M = s.match(/url=(.+)/)
              , Z = M ? decodeURIComponent(M[1]) : s;
            await navigator.clipboard.writeText(Z),
            k(!0),
            setTimeout( () => {
                k(!1)
            }
            , 3e3),
            console.log(" Original playing URL copied:", Z)
        } catch (M) {
            console.error(" Failed to copy original playing URL:", M);
            try {
                const Z = s.match(/url=(.+)/)
                  , te = Z ? decodeURIComponent(Z[1]) : s
                  , ee = document.createElement("textarea");
                ee.value = te,
                ee.style.position = "fixed",
                ee.style.left = "-999999px",
                ee.style.top = "-999999px",
                document.body.appendChild(ee),
                ee.focus(),
                ee.select();
                const ue = document.execCommand("copy");
                document.body.removeChild(ee),
                ue ? (k(!0),
                setTimeout( () => k(!1), 3e3)) : alert(`Original playing URL: ${te}`)
            } catch (Z) {
                console.error(" Fallback copy also failed:", Z);
                const te = s.match(/url=(.+)/)
                  , ee = te ? decodeURIComponent(te[1]) : s;
                alert(`Original playing URL: ${ee}`)
            }
        } finally {
            D(!1)
        }
    }
      , ji = async M => {
        var Z, te, ee;
        D(!0);
        try {
            const ue = ys(M)
              , ge = ((Z = Oe.find(Xe => Xe.level === M)) == null ? void 0 : Z.label) || "Unknown";
            await navigator.clipboard.writeText(ue),
            k(!0),
            setTimeout( () => {
                k(!1)
            }
            , 3e3),
            console.log(` ${ge} download link copied:`, ue)
        } catch (ue) {
            console.error(" Failed to copy quality link:", ue);
            try {
                const ge = ys(M)
                  , Xe = document.createElement("textarea");
                Xe.value = ge,
                Xe.style.position = "fixed",
                Xe.style.left = "-999999px",
                Xe.style.top = "-999999px",
                document.body.appendChild(Xe),
                Xe.focus(),
                Xe.select();
                const Ke = document.execCommand("copy");
                if (document.body.removeChild(Xe),
                Ke)
                    k(!0),
                    setTimeout( () => k(!1), 3e3);
                else {
                    const Vt = ((te = Oe.find($e => $e.level === M)) == null ? void 0 : te.label) || "Unknown";
                    alert(`${Vt} download link: ${ge}`)
                }
            } catch (ge) {
                console.error(" Fallback copy also failed:", ge);
                const Xe = ys(M)
                  , Ke = ((ee = Oe.find(Vt => Vt.level === M)) == null ? void 0 : ee.label) || "Unknown";
                alert(`${Ke} download link: ${Xe}`)
            }
        } finally {
            D(!1)
        }
    }
      , pn = () => {
        const M = Oe.find(Z => Z.level === W);
        return M ? `${M.label} HD` : "HD"
    }
    ;
    return g.jsxs("div", {
        className: "fixed inset-0 bg-black flex items-center justify-center z-50",
        children: [g.jsxs("div", {
            ref: r,
            className: `relative ${y ? "w-full h-full" : "w-full max-w-6xl mx-2 sm:mx-4"}`,
            children: [!y && g.jsxs("div", {
                className: "flex items-center justify-between p-2 sm:p-4 bg-black text-white rounded-t-lg border border-gray-700",
                children: [g.jsx("h3", {
                    className: "text-sm sm:text-lg font-semibold truncate pr-2",
                    children: e
                }), g.jsx("button", {
                    onClick: t,
                    className: "p-1 sm:p-2 hover:bg-gray-800 rounded-lg transition-colors border border-gray-600 flex-shrink-0",
                    children: g.jsx(xo, {
                        className: "h-4 w-4 sm:h-5 sm:w-5 text-white"
                    })
                })]
            }), g.jsxs("div", {
                className: `relative bg-black ${y ? "w-full h-full" : "rounded-b-lg"} overflow-hidden`,
                onMouseEnter: () => T(!0),
                onMouseLeave: () => T(!1),
                onTouchStart: () => T(!0),
                children: [g.jsx("video", {
                    ref: n,
                    className: `${y ? "w-full h-full object-contain" : "w-full aspect-video max-h-[70vh] sm:max-h-none"}`,
                    onClick: Be,
                    playsInline: !0,
                    controls: !1
                }), y && E && g.jsx("button", {
                    onClick: t,
                    className: "absolute top-2 right-2 sm:top-4 sm:right-4 p-2 bg-black bg-opacity-75 hover:bg-gray-800 rounded-lg transition-colors text-white border border-gray-600 z-50",
                    children: g.jsx(xo, {
                        className: "h-5 w-5 sm:h-6 sm:w-6 text-white"
                    })
                }), L && g.jsx("div", {
                    className: "absolute inset-0 flex items-center justify-center bg-black bg-opacity-50",
                    children: g.jsxs("div", {
                        className: "text-center text-white",
                        children: [g.jsx("div", {
                            className: "animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4"
                        }), g.jsx("p", {
                            children: "Loading..."
                        }), J > 0 && g.jsxs("p", {
                            className: "text-sm text-gray-300 mt-2",
                            children: ["Retry attempt ", J, "/", Q]
                        })]
                    })
                }), I && g.jsx("div", {
                    className: "absolute inset-0 flex items-center justify-center bg-black bg-opacity-75",
                    children: g.jsxs("div", {
                        className: "text-center text-white max-w-md mx-4",
                        children: [g.jsx("p", {
                            className: "mb-4",
                            children: I
                        }), g.jsxs("div", {
                            className: "flex flex-col gap-3",
                            children: [g.jsxs("button", {
                                onClick: $i,
                                className: "flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors mx-auto",
                                children: [g.jsx(RS, {
                                    className: "h-4 w-4"
                                }), "Retry"]
                            }), J >= Q && g.jsxs("div", {
                                className: "mt-4 p-4 bg-gray-800 rounded-lg border border-gray-600",
                                children: [g.jsxs("p", {
                                    className: "text-sm text-gray-300 mb-3",
                                    children: ["Unable to play video after ", Q, " attempts. You can download it instead:"]
                                }), g.jsxs("div", {
                                    className: "space-y-3",
                                    children: [g.jsxs("div", {
                                        children: [g.jsxs("p", {
                                            className: "text-xs text-gray-400 mb-2",
                                            children: ["Current Quality (", pn(), "):"]
                                        }), g.jsxs("button", {
                                            onClick: () => Un(),
                                            className: "w-full flex items-center justify-center gap-2 px-3 py-2 bg-green-600 hover:bg-green-700 rounded-lg transition-colors text-sm",
                                            children: [g.jsx(Qe, {
                                                className: "h-4 w-4"
                                            }), "Copy ", pn(), " Link"]
                                        })]
                                    }), g.jsxs("div", {
                                        children: [g.jsx("p", {
                                            className: "text-xs text-gray-400 mb-2",
                                            children: "Original Playing URL:"
                                        }), g.jsxs("button", {
                                            onClick: () => Qo(),
                                            className: "w-full flex items-center justify-center gap-2 px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors text-sm",
                                            children: [g.jsx(Qe, {
                                                className: "h-4 w-4"
                                            }), "Copy Playing URL"]
                                        })]
                                    }), g.jsxs("div", {
                                        className: "pt-2 border-t border-gray-600",
                                        children: [g.jsx("p", {
                                            className: "text-xs text-gray-400 mb-2",
                                            children: "All Available Qualities:"
                                        }), g.jsx("div", {
                                            className: "grid grid-cols-2 gap-2",
                                            children: Oe.map(M => g.jsxs("button", {
                                                onClick: () => ji(M.level),
                                                className: "flex items-center justify-center gap-1 px-2 py-1 bg-gray-700 hover:bg-gray-600 rounded text-xs transition-colors",
                                                children: [g.jsx(Qe, {
                                                    className: "h-3 w-3"
                                                }), M.label]
                                            }, M.level))
                                        })]
                                    })]
                                })]
                            })]
                        }), g.jsxs("div", {
                            className: "mt-4 text-center",
                            children: [g.jsx("p", {
                                className: "text-sm text-gray-300 mb-2",
                                children: "Or try a different quality:"
                            }), g.jsx("div", {
                                className: "flex gap-2 justify-center flex-wrap",
                                children: Oe.filter(M => M.level !== W).map(M => g.jsx("button", {
                                    onClick: () => _r(M.level),
                                    className: "px-3 py-1 bg-gray-700 hover:bg-gray-600 rounded text-sm transition-colors",
                                    children: M.label
                                }, M.level))
                            })]
                        })]
                    })
                }), B && g.jsxs("div", {
                    className: "absolute top-4 left-1/2 transform -translate-x-1/2 bg-green-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 z-50",
                    children: [g.jsx(vS, {
                        className: "h-4 w-4"
                    }), "Download link copied to clipboard!"]
                }), $ && g.jsx("div", {
                    className: "absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4",
                    children: g.jsxs("div", {
                        className: "bg-gray-900 rounded-lg p-4 sm:p-6 text-white w-full max-w-sm sm:min-w-80 border border-gray-700 max-h-[80vh] overflow-y-auto",
                        children: [g.jsx("h3", {
                            className: "text-base sm:text-lg font-semibold mb-4",
                            children: "Select Download Quality"
                        }), g.jsx("div", {
                            className: "space-y-3",
                            children: Oe.map(M => g.jsxs("button", {
                                onClick: () => Un(M.level),
                                disabled: V,
                                className: "w-full text-left px-3 sm:px-4 py-2 sm:py-3 bg-gray-800 hover:bg-gray-700 rounded-lg transition-colors disabled:opacity-50 flex items-center justify-between",
                                children: [g.jsxs("div", {
                                    children: [g.jsxs("div", {
                                        className: "text-sm sm:text-base font-medium",
                                        children: [M.label, " HD"]
                                    }), g.jsxs("div", {
                                        className: "text-xs sm:text-sm text-gray-400",
                                        children: [M.height, "p resolution  30fps"]
                                    })]
                                }), W === M.level && g.jsx("div", {
                                    className: "text-green-400 text-xs sm:text-sm",
                                    children: "Current"
                                })]
                            }, M.level))
                        }), g.jsxs("div", {
                            className: "flex flex-col sm:flex-row gap-3 mt-6",
                            children: [g.jsx("button", {
                                onClick: () => K(!1),
                                className: "flex-1 px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors text-sm sm:text-base",
                                children: "Cancel"
                            }), g.jsx("button", {
                                onClick: () => Un(),
                                disabled: V,
                                className: "flex-1 px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg transition-colors disabled:opacity-50 flex items-center justify-center gap-2 text-sm sm:text-base",
                                children: V ? g.jsxs(g.Fragment, {
                                    children: [g.jsx(SS, {
                                        className: "h-4 w-4 animate-pulse"
                                    }), "Copying..."]
                                }) : g.jsxs(g.Fragment, {
                                    children: [g.jsx(Qe, {
                                        className: "h-4 w-4"
                                    }), "Current Quality (", pn(), ")"]
                                })
                            })]
                        })]
                    })
                }), O && g.jsxs("div", {
                    className: "absolute bottom-16 sm:bottom-20 right-2 sm:right-4 bg-black bg-opacity-95 rounded-lg p-3 sm:p-4 text-white min-w-40 sm:min-w-48 border border-gray-700 z-50 backdrop-blur-sm max-h-80 overflow-y-auto",
                    children: [g.jsxs("div", {
                        className: "mb-4",
                        children: [g.jsx("h4", {
                            className: "text-sm font-semibold mb-2",
                            children: "Playback Speed"
                        }), g.jsx("div", {
                            className: "space-y-1",
                            children: Dt.map(M => g.jsxs("button", {
                                onClick: () => vs(M),
                                className: `block w-full text-left px-2 py-1.5 rounded text-sm hover:bg-gray-800 transition-colors ${C === M ? "bg-gray-700 text-red-400" : ""}`,
                                children: [M, "x ", M === 1 ? "(Normal)" : ""]
                            }, M))
                        })]
                    }), g.jsxs("div", {
                        children: [g.jsx("h4", {
                            className: "text-sm font-semibold mb-2",
                            children: "Quality"
                        }), g.jsx("div", {
                            className: "space-y-1",
                            children: Oe.map(M => g.jsx("button", {
                                onClick: () => _r(M.level),
                                className: `block w-full text-left px-2 py-1.5 rounded text-sm hover:bg-gray-800 transition-colors relative ${W === M.level ? "bg-gray-700 text-red-400" : ""}`,
                                children: g.jsxs("div", {
                                    className: "flex items-center justify-between",
                                    children: [g.jsxs("span", {
                                        children: [M.label, " HD", M.level === 4 && g.jsx("span", {
                                            className: "text-xs text-gray-400 ml-2",
                                            children: "(Recommended)"
                                        })]
                                    }), se.includes(M.level) && g.jsx("span", {
                                        className: "text-xs text-green-400",
                                        children: ""
                                    })]
                                })
                            }, M.level))
                        })]
                    })]
                }), (E || window.innerWidth <= 768) && !L && !I && g.jsxs("div", {
                    className: "absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/80 to-transparent p-2 sm:p-4",
                    children: [g.jsxs("div", {
                        className: "mb-2 sm:mb-4",
                        children: [g.jsx("input", {
                            type: "range",
                            min: "0",
                            max: f || 0,
                            value: d,
                            onChange: St,
                            className: "w-full h-1 sm:h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer slider-red"
                        }), g.jsxs("div", {
                            className: "flex justify-between text-xs text-white mt-1 px-1",
                            children: [g.jsx("span", {
                                children: mn(d)
                            }), g.jsx("span", {
                                children: mn(f)
                            })]
                        })]
                    }), g.jsxs("div", {
                        className: "flex items-center justify-between gap-2",
                        children: [g.jsxs("div", {
                            className: "flex items-center gap-2 sm:gap-4",
                            children: [g.jsx("button", {
                                onClick: Be,
                                className: "p-1.5 sm:p-2 hover:bg-gray-800 rounded-full transition-colors",
                                children: o ? g.jsx(bS, {
                                    className: "h-5 w-5 sm:h-6 sm:w-6 text-white"
                                }) : g.jsx(rt, {
                                    className: "h-5 w-5 sm:h-6 sm:w-6 text-white"
                                })
                            }), g.jsxs("div", {
                                className: "hidden sm:flex items-center gap-2",
                                children: [g.jsx("button", {
                                    onClick: ht,
                                    className: "p-2 hover:bg-gray-800 rounded-full transition-colors",
                                    children: c ? g.jsx(_S, {
                                        className: "h-5 w-5 text-white"
                                    }) : g.jsx(kS, {
                                        className: "h-5 w-5 text-white"
                                    })
                                }), g.jsx("input", {
                                    type: "range",
                                    min: "0",
                                    max: "1",
                                    step: "0.1",
                                    value: c ? 0 : p,
                                    onChange: xs,
                                    className: "w-20 h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer slider-red"
                                })]
                            }), g.jsxs("div", {
                                className: "hidden sm:block text-white text-sm font-medium",
                                children: [C, "x"]
                            }), g.jsx("div", {
                                className: "text-white text-sm font-medium",
                                children: pn()
                            })]
                        }), g.jsxs("div", {
                            className: "flex items-center gap-1 sm:gap-2",
                            children: [g.jsx("button", {
                                onClick: gn,
                                className: "p-1.5 sm:p-2 hover:bg-gray-800 rounded-full transition-colors",
                                title: "Download video",
                                children: g.jsx(Qe, {
                                    className: "h-4 w-4 sm:h-5 sm:w-5 text-white"
                                })
                            }), g.jsx("button", {
                                onClick: () => _(!O),
                                className: "p-1.5 sm:p-2 hover:bg-gray-800 rounded-full transition-colors",
                                children: g.jsx(wS, {
                                    className: "h-4 w-4 sm:h-5 sm:w-5 text-white"
                                })
                            }), g.jsx("button", {
                                onClick: Fs,
                                className: "p-1.5 sm:p-2 hover:bg-gray-800 rounded-full transition-colors",
                                children: y ? g.jsx(AS, {
                                    className: "h-5 w-5 text-white"
                                }) : g.jsx(LS, {
                                    className: "h-5 w-5 text-white"
                                })
                            })]
                        })]
                    })]
                })]
            })]
        }), g.jsx("style", {
            jsx: !0,
            children: `
        .slider-red::-webkit-slider-thumb {
          appearance: none;
          height: 14px;
          width: 14px;
          border-radius: 50%;
          background: #ef4444;
          cursor: pointer;
          box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }
        @media (min-width: 640px) {
          .slider-red::-webkit-slider-thumb {
            height: 16px;
            width: 16px;
          }
        }
        .slider-red::-moz-range-thumb {
          height: 14px;
          width: 14px;
          border-radius: 50%;
          background: #ef4444;
          cursor: pointer;
          border: none;
          box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }
        @media (min-width: 640px) {
          .slider-red::-moz-range-thumb {
            height: 16px;
            width: 16px;
          }
        }
        .slider-red::-webkit-slider-track {
          background: #4b5563;
          height: 3px;
          border-radius: 2px;
        }
        @media (min-width: 640px) {
          .slider-red::-webkit-slider-track {
            height: 4px;
          }
        }
        .slider-red::-moz-range-track {
          background: #4b5563;
          height: 3px;
          border-radius: 2px;
        }
        @media (min-width: 640px) {
          .slider-red::-moz-range-track {
            height: 4px;
          }
        }
      `
        })]
    })
}
  , kr = () => g.jsxs("div", {
    className: "bg-white rounded-xl shadow-lg border border-gray-100 overflow-hidden",
    children: [g.jsx("div", {
        className: "shimmer h-48 bg-gray-200"
    }), g.jsxs("div", {
        className: "p-6",
        children: [g.jsx("div", {
            className: "shimmer h-6 bg-gray-200 rounded mb-3"
        }), g.jsx("div", {
            className: "shimmer h-4 bg-gray-200 rounded mb-2"
        }), g.jsx("div", {
            className: "shimmer h-4 bg-gray-200 rounded mb-4 w-3/4"
        }), g.jsx("div", {
            className: "shimmer h-10 bg-gray-200 rounded"
        })]
    })]
})
  , UA = () => {
    const {batchId: s, subjectId: e} = Fp()
      , [t,n] = w.useState([])
      , [r,i] = w.useState([])
      , [a,o] = w.useState([])
      , [l,c] = w.useState(!0)
      , [u,d] = w.useState(null)
      , [h,f] = w.useState(null)
      , [m,p] = w.useState("")
      , [x,y] = w.useState("date")
      , [v,E] = w.useState(!1)
      , [T,L] = w.useState("lectures");
    w.useEffect( () => {
        (async () => {
            c(!0),
            d(null);
            try {
                await Promise.all([R("lectures"), R("notes"), R("dpp")])
            } catch ($) {
                console.error("Error fetching content:", $),
                d("Failed to fetch content. Please try again.")
            } finally {
                c(!1)
            }
        }
        )()
    }
    , [s, e]);
    const R = async _ => {
        try {
            const $ = decodeURIComponent(s || "")
              , K = decodeURIComponent(e || "").toLowerCase();
            console.log(` Fetching ${_} for:`, {
                batch: $,
                subject: K
            });
            const W = Mn.getApiUrl($, K, _);
            if (!W) {
                console.warn(` No ${_} endpoint found for ${K} in ${$}`);
                return
            }
            console.log(` Fetching ${_} from:`, W);
            const G = await fetch(W, {
                method: "GET"
            });
            if (!G.ok)
                throw new Error(`HTTP ${G.status}: ${G.statusText}`);
            const V = await G.json();
            console.log(` ${_} API Response:`, V);
            let D = [];
            if (Array.isArray(V))
                D = V;
            else if (V.data && Array.isArray(V.data))
                D = V.data;
            else if (V.result && Array.isArray(V.result))
                D = V.result;
            else if (V.items && Array.isArray(V.items))
                D = V.items;
            else {
                const B = Object.keys(V).filter(k => Array.isArray(V[k]));
                B.length > 0 && (D = V[B[0]])
            }
            if (console.log(` Processed ${_} data (${D.length} items):`, D),
            _ === "lectures") {
                const B = D.map( (k, F) => ({
                    id: k.id || k._id || `lecture-${F}`,
                    title: I(k.title || k.name || k.subject || `Session ${F + 1}`),
                    description: k.description || k.desc || k.summary || k.topic || "No description available",
                    videoUrl: k.link || k.videoUrl || k.video || k.url || k.stream_url || k.m3u8 || k.meeting_url || "",
                    duration: k.duration || k.time || k.length || "00:00",
                    date: k.date || k.created_at || k.timestamp || k.start_time || k.scheduled_time || new Date().toISOString(),
                    thumbnail: k.thumbnail || k.thumb || k.image || k.poster,
                    image: k.image || k.thumbnail || k.poster,
                    notes: k.notes || k.note || k.pdf || k.document || k.materials,
                    pdf: k.pdf || k.document || k.notes || k.materials,
                    status: k.status || k.state || (K === "live-classes" ? "live" : K === "scheduled-classes" ? "scheduled" : "completed"),
                    instructor: k.instructor || k.teacher || k.faculty || "Expert Teacher",
                    meetingId: k.meeting_id || k.room_id || k.session_id,
                    isLive: k.is_live || k.live || K === "live-classes"
                }));
                console.log(` Processed ${B.length} lectures`),
                n(B)
            } else if (_ === "notes") {
                const B = D.map( (k, F) => ({
                    id: k.id || k._id || `note-${F}`,
                    title: I(k.title || k.name || `Note ${F + 1}`),
                    description: k.description || k.desc || k.summary || "No description available",
                    pdfUrl: k.link || k.pdfUrl || k.pdf || k.url || k.download_url || k.file || "",
                    date: k.date || k.created_at || k.timestamp || new Date().toISOString(),
                    thumbnail: k.thumbnail || k.thumb || k.image || k.poster
                }));
                console.log(` Processed ${B.length} notes`),
                i(B)
            } else if (_ === "dpp") {
                const B = D.map( (k, F) => ({
                    id: k.id || k._id || `dpp-${F}`,
                    title: I(k.title || k.name || `DPP ${F + 1}`),
                    description: k.description || k.desc || k.summary || "No description available",
                    pdfUrl: k.link || k.pdfUrl || k.pdf || k.url || k.download_url || k.file || "",
                    date: k.date || k.created_at || k.timestamp || new Date().toISOString(),
                    thumbnail: k.thumbnail || k.thumb || k.image || k.poster
                }));
                console.log(` Processed ${B.length} DPPs`),
                o(B)
            }
        } catch ($) {
            console.error(` Error fetching ${_}:`, $),
            _ === "lectures" && d(`Failed to fetch ${_}: ${$instanceof Error ? $.message : "Unknown error"}`)
        }
    }
      , I = _ => _.replace(/\[rolexcoder\.xyz\]/gi, "").replace(/\[.*?\]/g, "").replace(/\(.*?\)/g, "").trim()
      , A = (_, $) => {
        try {
            if (!_)
                throw new Error("Download URL not available");
            console.log(" Downloading:", _);
            const K = document.createElement("a");
            K.href = _,
            K.target = "_blank",
            K.rel = "noopener noreferrer",
            $ && !_.includes("drive.google.com") && (K.download = $),
            document.body.appendChild(K),
            K.click(),
            document.body.removeChild(K)
        } catch (K) {
            console.error(" Download failed:", K),
            alert("Download failed. The file may not be available.")
        }
    }
      , C = t.filter(_ => _.title.toLowerCase().includes(m.toLowerCase()) || _.description.toLowerCase().includes(m.toLowerCase())).sort( (_, $) => x === "date" ? new Date($.date).getTime() - new Date(_.date).getTime() : _.title.localeCompare($.title))
      , b = r.filter(_ => _.title.toLowerCase().includes(m.toLowerCase()) || _.description.toLowerCase().includes(m.toLowerCase())).sort( (_, $) => x === "date" ? new Date($.date).getTime() - new Date(_.date).getTime() : _.title.localeCompare($.title))
      , O = a.filter(_ => _.title.toLowerCase().includes(m.toLowerCase()) || _.description.toLowerCase().includes(m.toLowerCase())).sort( (_, $) => x === "date" ? new Date($.date).getTime() - new Date(_.date).getTime() : _.title.localeCompare($.title));
    return h ? g.jsx(Od, {
        src: h.videoUrl,
        title: h.title,
        onClose: () => f(null)
    }) : g.jsx("div", {
        className: "min-h-screen bg-dark-primary",
        children: g.jsxs("div", {
            className: "container mx-auto px-4 py-8",
            children: [g.jsxs("div", {
                className: "mb-8",
                children: [g.jsx("h1", {
                    className: "text-4xl font-bold bg-gradient-to-r from-red-500 to-red-700 bg-clip-text text-transparent mb-2",
                    children: decodeURIComponent(e || "").replace(/-/g, " ").toUpperCase()
                }), g.jsxs("p", {
                    className: "text-gray-400",
                    children: ["Batch: ", decodeURIComponent(s || "")]
                })]
            }), g.jsxs("div", {
                className: "mb-8 space-y-4",
                children: [g.jsxs("div", {
                    className: "flex space-x-1 bg-gray-900 p-1 rounded-lg border border-red-500/30",
                    children: [g.jsxs("button", {
                        onClick: () => L("lectures"),
                        className: `flex-1 flex items-center justify-center gap-2 px-4 py-2 rounded-md transition-all duration-300 ${T === "lectures" ? "bg-gradient-to-r from-red-600 to-red-700 text-white shadow-lg" : "text-gray-400 hover:text-white hover:bg-gray-800"}`,
                        children: [g.jsx(rt, {
                            className: "w-4 h-4"
                        }), "Lectures (", t.length, ")"]
                    }), g.jsxs("button", {
                        onClick: () => L("notes"),
                        className: `flex-1 flex items-center justify-center gap-2 px-4 py-2 rounded-md transition-all duration-300 ${T === "notes" ? "bg-gradient-to-r from-red-600 to-red-700 text-white shadow-lg" : "text-gray-400 hover:text-white hover:bg-gray-800"}`,
                        children: [g.jsx(ws, {
                            className: "w-4 h-4"
                        }), "Notes (", r.length, ")"]
                    }), g.jsxs("button", {
                        onClick: () => L("dpp"),
                        className: `flex-1 flex items-center justify-center gap-2 px-4 py-2 rounded-md transition-all duration-300 ${T === "dpp" ? "bg-gradient-to-r from-red-600 to-red-700 text-white shadow-lg" : "text-gray-400 hover:text-white hover:bg-gray-800"}`,
                        children: [g.jsx(aa, {
                            className: "w-4 h-4"
                        }), "DPP (", a.length, ")"]
                    })]
                }), g.jsxs("div", {
                    className: "flex flex-col sm:flex-row gap-4",
                    children: [g.jsxs("div", {
                        className: "flex-1 relative",
                        children: [g.jsx(zo, {
                            className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-5 h-5"
                        }), g.jsx("input", {
                            type: "text",
                            placeholder: `Search ${T}...`,
                            value: m,
                            onChange: _ => p(_.target.value),
                            className: "w-full pl-10 pr-4 py-3 bg-gray-900 border border-red-500/30 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:border-red-500 focus:ring-2 focus:ring-red-500/20 transition-all duration-300"
                        })]
                    }), g.jsxs("button", {
                        onClick: () => E(!v),
                        className: "flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-gray-800 to-gray-900 text-white rounded-lg hover:from-gray-700 hover:to-gray-800 transition-all duration-300 border border-red-500/30",
                        children: [g.jsx(Kp, {
                            className: "w-5 h-5"
                        }), "Filters", g.jsx(ES, {
                            className: `w-4 h-4 transition-transform duration-300 ${v ? "rotate-180" : ""}`
                        })]
                    })]
                }), v && g.jsx("div", {
                    className: "bg-gradient-to-br from-gray-900 to-black rounded-lg p-4 border border-red-500/20",
                    children: g.jsx("div", {
                        className: "flex flex-wrap gap-4",
                        children: g.jsxs("div", {
                            children: [g.jsx("label", {
                                className: "block text-sm font-medium text-gray-300 mb-2",
                                children: "Sort by"
                            }), g.jsxs("select", {
                                value: x,
                                onChange: _ => y(_.target.value),
                                className: "px-3 py-2 bg-gray-800 border border-red-500/30 rounded-lg text-white focus:outline-none focus:border-red-500",
                                children: [g.jsx("option", {
                                    value: "date",
                                    children: "Date"
                                }), g.jsx("option", {
                                    value: "title",
                                    children: "Title"
                                })]
                            })]
                        })
                    })
                })]
            }), u && g.jsx("div", {
                className: "mb-8 p-6 bg-gradient-to-r from-red-900/50 to-red-800/50 border border-red-500/50 rounded-lg",
                children: g.jsx("p", {
                    className: "text-red-200 text-center",
                    children: u
                })
            }), l && g.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6",
                children: [...Array(6)].map( (_, $) => g.jsx(kr, {}, $))
            }), !l && !u && T === "lectures" && g.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6",
                children: C.map(_ => g.jsxs("div", {
                    className: `group bg-gradient-to-br from-gray-900 to-black rounded-xl overflow-hidden border transition-all duration-300 hover:shadow-2xl ${_.isLive ? "border-red-500/50 hover:border-red-500/70 hover:shadow-red-500/20 animate-pulse" : _.status === "scheduled" ? "border-blue-500/20 hover:border-blue-500/50 hover:shadow-blue-500/10" : "border-green-500/20 hover:border-green-500/50 hover:shadow-green-500/10"}`,
                    children: [g.jsxs("div", {
                        className: "relative h-48 overflow-hidden",
                        children: [_.isLive && g.jsx("div", {
                            className: "absolute top-2 left-2 z-10",
                            children: g.jsxs("div", {
                                className: "bg-red-600 text-white px-2 py-1 rounded-full text-xs font-bold flex items-center gap-1 animate-pulse",
                                children: [g.jsx("div", {
                                    className: "w-2 h-2 bg-white rounded-full animate-ping"
                                }), "LIVE"]
                            })
                        }), !_.isLive && _.status && g.jsx("div", {
                            className: "absolute top-2 left-2 z-10",
                            children: g.jsx("div", {
                                className: `px-2 py-1 rounded-full text-xs font-medium ${_.status === "scheduled" ? "bg-blue-600 text-white" : "bg-green-600 text-white"}`,
                                children: _.status === "scheduled" ? "SCHEDULED" : "RECORDED"
                            })
                        }), _.image || _.thumbnail ? g.jsx("img", {
                            src: _.image || _.thumbnail,
                            alt: _.title,
                            className: "w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
                        }) : g.jsx("div", {
                            className: `w-full h-full bg-gradient-to-br flex items-center justify-center ${_.isLive ? "from-red-900/30 to-red-700/30" : _.status === "scheduled" ? "from-blue-900/30 to-blue-700/30" : "from-green-900/30 to-green-700/30"}`,
                            children: g.jsx(rt, {
                                className: `w-16 h-16 ${_.isLive ? "text-red-400" : _.status === "scheduled" ? "text-blue-400" : "text-green-400"}`
                            })
                        }), g.jsx("div", {
                            className: "absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex items-center justify-center",
                            children: g.jsx("button", {
                                onClick: () => f(_),
                                className: `text-white rounded-full p-4 transform scale-90 group-hover:scale-100 transition-transform duration-300 ${_.isLive ? "bg-red-600 hover:bg-red-700" : _.status === "scheduled" ? "bg-blue-600 hover:bg-blue-700" : "bg-green-600 hover:bg-green-700"}`,
                                children: g.jsx(rt, {
                                    className: "w-8 h-8"
                                })
                            })
                        })]
                    }), g.jsxs("div", {
                        className: "p-6",
                        children: [g.jsx("h3", {
                            className: `text-xl font-semibold text-white mb-2 line-clamp-2 transition-colors duration-300 ${_.isLive ? "group-hover:text-red-400" : _.status === "scheduled" ? "group-hover:text-blue-400" : "group-hover:text-green-400"}`,
                            children: _.title
                        }), g.jsx("p", {
                            className: "text-gray-400 text-sm mb-4 line-clamp-2",
                            children: _.description
                        }), g.jsxs("div", {
                            className: "flex items-center justify-between text-sm text-gray-500 mb-4 flex-wrap gap-2",
                            children: [_.instructor && g.jsxs("div", {
                                className: "flex items-center gap-2",
                                children: [g.jsx(Ii, {
                                    className: "w-4 h-4"
                                }), _.instructor]
                            }), g.jsxs("div", {
                                className: "flex items-center gap-2",
                                children: [g.jsx(nn, {
                                    className: "w-4 h-4"
                                }), _.duration || "Live"]
                            }), g.jsx("div", {
                                className: "flex items-center gap-2 text-xs",
                                children: new Date(_.date).toLocaleDateString()
                            })]
                        }), g.jsxs("div", {
                            className: "flex gap-2",
                            children: [g.jsx("button", {
                                onClick: () => f(_),
                                className: `flex-1 text-white py-2 px-4 rounded-lg transition-all duration-300 text-sm font-medium ${_.isLive ? "bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800" : _.status === "scheduled" ? "bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800" : "bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800"}`,
                                children: _.isLive ? "Join Live" : _.status === "scheduled" ? "View Details" : "Watch Recording"
                            }), (_.notes || _.pdf) && g.jsx("button", {
                                onClick: () => A(_.notes || _.pdf, `${_.title}.pdf`),
                                className: "bg-gradient-to-r from-gray-700 to-gray-800 text-white p-2 rounded-lg hover:from-gray-600 hover:to-gray-700 transition-all duration-300",
                                children: g.jsx(Qe, {
                                    className: "w-4 h-4"
                                })
                            })]
                        })]
                    })]
                }, _.id))
            }), !l && !u && T === "notes" && g.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6",
                children: b.map(_ => g.jsxs("div", {
                    className: "group bg-gradient-to-br from-gray-900 to-black rounded-xl overflow-hidden border border-red-500/20 hover:border-red-500/50 transition-all duration-300 hover:shadow-2xl hover:shadow-red-500/10",
                    children: [g.jsxs("div", {
                        className: "relative h-48 overflow-hidden",
                        children: [_.thumbnail ? g.jsx("img", {
                            src: _.thumbnail,
                            alt: _.title,
                            className: "w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
                        }) : g.jsx("div", {
                            className: "w-full h-full bg-gradient-to-br from-blue-900/30 to-blue-700/30 flex items-center justify-center",
                            children: g.jsx(ws, {
                                className: "w-16 h-16 text-blue-400"
                            })
                        }), g.jsx("div", {
                            className: "absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex items-center justify-center",
                            children: g.jsx("button", {
                                onClick: () => A(_.pdfUrl, `${_.title}.pdf`),
                                className: "bg-blue-600 hover:bg-blue-700 text-white rounded-full p-4 transform scale-90 group-hover:scale-100 transition-transform duration-300",
                                children: g.jsx(Qe, {
                                    className: "w-8 h-8"
                                })
                            })
                        })]
                    }), g.jsxs("div", {
                        className: "p-6",
                        children: [g.jsx("h3", {
                            className: "text-xl font-semibold text-white mb-2 line-clamp-2 group-hover:text-blue-400 transition-colors duration-300",
                            children: _.title
                        }), g.jsx("p", {
                            className: "text-gray-400 text-sm mb-4 line-clamp-2",
                            children: _.description
                        }), g.jsxs("div", {
                            className: "flex items-center justify-between text-sm text-gray-500 mb-4",
                            children: [g.jsxs("div", {
                                className: "flex items-center gap-2",
                                children: [g.jsx(ws, {
                                    className: "w-4 h-4"
                                }), "PDF"]
                            }), g.jsxs("div", {
                                className: "flex items-center gap-2",
                                children: [g.jsx(nn, {
                                    className: "w-4 h-4"
                                }), new Date(_.date).toLocaleDateString()]
                            })]
                        }), g.jsxs("button", {
                            onClick: () => A(_.pdfUrl, `${_.title}.pdf`),
                            className: "w-full bg-gradient-to-r from-blue-600 to-blue-700 text-white py-2 px-4 rounded-lg hover:from-blue-700 hover:to-blue-800 transition-all duration-300 text-sm font-medium flex items-center justify-center gap-2",
                            children: [g.jsx(Qe, {
                                className: "w-4 h-4"
                            }), "Download PDF"]
                        })]
                    })]
                }, _.id))
            }), !l && !u && T === "dpp" && g.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6",
                children: O.map(_ => g.jsxs("div", {
                    className: "group bg-gradient-to-br from-gray-900 to-black rounded-xl overflow-hidden border border-red-500/20 hover:border-red-500/50 transition-all duration-300 hover:shadow-2xl hover:shadow-red-500/10",
                    children: [g.jsxs("div", {
                        className: "relative h-48 overflow-hidden",
                        children: [_.thumbnail ? g.jsx("img", {
                            src: _.thumbnail,
                            alt: _.title,
                            className: "w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
                        }) : g.jsx("div", {
                            className: "w-full h-full bg-gradient-to-br from-green-900/30 to-green-700/30 flex items-center justify-center",
                            children: g.jsx(aa, {
                                className: "w-16 h-16 text-green-400"
                            })
                        }), g.jsx("div", {
                            className: "absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity duration-300 flex items-center justify-center",
                            children: g.jsx("button", {
                                onClick: () => A(_.pdfUrl, `${_.title}.pdf`),
                                className: "bg-green-600 hover:bg-green-700 text-white rounded-full p-4 transform scale-90 group-hover:scale-100 transition-transform duration-300",
                                children: g.jsx(Qe, {
                                    className: "w-8 h-8"
                                })
                            })
                        })]
                    }), g.jsxs("div", {
                        className: "p-6",
                        children: [g.jsx("h3", {
                            className: "text-xl font-semibold text-white mb-2 line-clamp-2 group-hover:text-green-400 transition-colors duration-300",
                            children: _.title
                        }), g.jsx("p", {
                            className: "text-gray-400 text-sm mb-4 line-clamp-2",
                            children: _.description
                        }), g.jsxs("div", {
                            className: "flex items-center justify-between text-sm text-gray-500 mb-4",
                            children: [g.jsxs("div", {
                                className: "flex items-center gap-2",
                                children: [g.jsx(aa, {
                                    className: "w-4 h-4"
                                }), "DPP"]
                            }), g.jsxs("div", {
                                className: "flex items-center gap-2",
                                children: [g.jsx(nn, {
                                    className: "w-4 h-4"
                                }), new Date(_.date).toLocaleDateString()]
                            })]
                        }), g.jsxs("button", {
                            onClick: () => A(_.pdfUrl, `${_.title}.pdf`),
                            className: "w-full bg-gradient-to-r from-green-600 to-green-700 text-white py-2 px-4 rounded-lg hover:from-green-700 hover:to-green-800 transition-all duration-300 text-sm font-medium flex items-center justify-center gap-2",
                            children: [g.jsx(Qe, {
                                className: "w-4 h-4"
                            }), "Download PDF"]
                        })]
                    })]
                }, _.id))
            }), !l && !u && (T === "lectures" && C.length === 0 || T === "notes" && b.length === 0 || T === "dpp" && O.length === 0) && g.jsxs("div", {
                className: "text-center py-12",
                children: [T === "lectures" && g.jsx(rt, {
                    className: "w-16 h-16 text-gray-600 mx-auto mb-4"
                }), T === "notes" && g.jsx(ws, {
                    className: "w-16 h-16 text-gray-600 mx-auto mb-4"
                }), T === "dpp" && g.jsx(aa, {
                    className: "w-16 h-16 text-gray-600 mx-auto mb-4"
                }), g.jsxs("h3", {
                    className: "text-xl font-semibold text-gray-400 mb-2",
                    children: ["No ", T, " found"]
                }), g.jsx("p", {
                    className: "text-gray-500",
                    children: m ? "Try adjusting your search terms" : `No ${T} available for this subject yet`
                })]
            })]
        })
    })
}
  , BA = () => {
    const [s,e] = w.useState([])
      , [t,n] = w.useState(!0)
      , [r,i] = w.useState(null)
      , [a,o] = w.useState("")
      , [l,c] = w.useState(null)
      , u = async () => {
        try {
            n(!0);
            const p = Mn.getApiUrl("AARAMBH 2.O 10th BATCH 25-26", "science", "lectures");
            if (!p)
                throw new Error("API endpoint not configured");
            const x = await fetch(p);
            if (!x.ok)
                throw new Error("Failed to fetch lectures");
            const y = await x.json();
            e(y.data || [])
        } catch (p) {
            i("Failed to load lectures. Please try again later."),
            console.error("Error fetching lectures:", p)
        } finally {
            n(!1)
        }
    }
    ;
    w.useEffect( () => {
        u()
    }
    , []);
    const d = s.filter(p => p.title.toLowerCase().includes(a.toLowerCase()))
      , h = p => {
        c(p)
    }
      , f = p => p.toLowerCase().includes("reproduce") ? "Reproduction" : p.toLowerCase().includes("electricity") ? "Electricity" : p.toLowerCase().includes("metal") ? "Metals & Non-metals" : p.toLowerCase().includes("coordination") ? "Control & Coordination" : p.toLowerCase().includes("eye") ? "Human Eye" : p.toLowerCase().includes("acid") || p.toLowerCase().includes("base") ? "Acids & Bases" : p.toLowerCase().includes("life processes") ? "Life Processes" : p.toLowerCase().includes("light") ? "Light" : p.toLowerCase().includes("chemical") ? "Chemical Reactions" : "General"
      , m = p => {
        const x = {
            Reproduction: "text-pink-600 bg-pink-100",
            Electricity: "text-yellow-600 bg-yellow-100",
            "Metals & Non-metals": "text-purple-600 bg-purple-100",
            "Control & Coordination": "text-green-600 bg-green-100",
            "Human Eye": "text-indigo-600 bg-indigo-100",
            "Acids & Bases": "text-red-600 bg-red-100",
            "Life Processes": "text-blue-600 bg-blue-100",
            Light: "text-orange-600 bg-orange-100",
            "Chemical Reactions": "text-teal-600 bg-teal-100",
            General: "text-gray-600 bg-gray-100"
        };
        return x[p] || x.General
    }
    ;
    return r ? g.jsx("div", {
        className: "min-h-screen bg-gray-50 py-12",
        children: g.jsx("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: g.jsx("div", {
                className: "text-center",
                children: g.jsx("div", {
                    className: "bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg max-w-md mx-auto",
                    children: g.jsx("p", {
                        className: "font-medium",
                        children: r
                    })
                })
            })
        })
    }) : g.jsx("div", {
        className: "min-h-screen dark-container py-6 md:py-12",
        children: g.jsxs("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: [g.jsxs("div", {
                className: "text-center mb-8 md:mb-12",
                children: [g.jsx("h1", {
                    className: "text-2xl md:text-4xl font-bold text-gradient mb-4",
                    children: "Video Lectures"
                }), g.jsx("p", {
                    className: "text-sm md:text-lg text-gray-300 max-w-2xl mx-auto",
                    children: "Master Class 10 Science with our comprehensive video lectures by expert teachers"
                })]
            }), g.jsx("div", {
                className: "bg-white rounded-lg shadow-md p-4 md:p-6 mb-6 md:mb-8",
                children: g.jsxs("div", {
                    className: "relative",
                    children: [g.jsx(zo, {
                        className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5"
                    }), g.jsx("input", {
                        type: "text",
                        placeholder: "Search lectures...",
                        value: a,
                        onChange: p => o(p.target.value),
                        className: "search-input pl-10 text-sm md:text-base"
                    })]
                })
            }), t ? g.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                children: [...Array(6)].map( (p, x) => g.jsx(kr, {}, x))
            }) : g.jsxs(g.Fragment, {
                children: [g.jsxs("div", {
                    className: "mb-4 md:mb-6 text-xs md:text-sm text-gray-300",
                    children: ["Showing ", d.length, " of ", s.length, " lectures"]
                }), g.jsx("div", {
                    className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                    children: d.map( (p, x) => {
                        const y = f(p.title)
                          , v = m(y);
                        return g.jsxs("div", {
                            className: "card overflow-hidden",
                            children: [g.jsxs("div", {
                                className: "relative",
                                children: [g.jsx("div", {
                                    className: "w-full h-40 md:h-48 bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center",
                                    children: g.jsx(rt, {
                                        className: "h-12 w-12 md:h-16 md:w-16 text-white opacity-80"
                                    })
                                }), g.jsx("div", {
                                    className: "absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity duration-300 cursor-pointer",
                                    onClick: () => h(p),
                                    children: g.jsxs("div", {
                                        className: "text-center text-white",
                                        children: [g.jsx(rt, {
                                            className: "h-12 w-12 md:h-16 md:w-16 mx-auto mb-2"
                                        }), g.jsx("p", {
                                            className: "text-xs md:text-sm font-medium",
                                            children: "Click to Watch"
                                        })]
                                    })
                                })]
                            }), g.jsxs("div", {
                                className: "p-4 md:p-6",
                                children: [g.jsx("div", {
                                    className: "flex items-center justify-between mb-3",
                                    children: g.jsx("span", {
                                        className: `text-xs font-medium px-2 py-1 rounded ${v}`,
                                        children: y
                                    })
                                }), g.jsx("h3", {
                                    className: "text-lg md:text-xl font-semibold text-gray-900 mb-3 line-clamp-2",
                                    children: p.title
                                }), g.jsx("p", {
                                    className: "text-gray-600 text-xs md:text-sm mb-4 md:mb-6",
                                    children: "Comprehensive lecture covering important concepts and problem-solving techniques"
                                }), g.jsxs("button", {
                                    onClick: () => h(p),
                                    className: "w-full btn-primary flex items-center justify-center gap-2 text-sm",
                                    children: [g.jsx(rt, {
                                        className: "h-4 w-4"
                                    }), "Watch Now"]
                                })]
                            })]
                        }, x)
                    }
                    )
                }), d.length === 0 && !t && g.jsxs("div", {
                    className: "text-center py-8 md:py-12",
                    children: [g.jsx("div", {
                        className: "text-gray-400 mb-4",
                        children: g.jsx(rt, {
                            className: "h-16 w-16 mx-auto"
                        })
                    }), g.jsx("h3", {
                        className: "text-base md:text-lg font-medium text-gray-900 mb-2",
                        children: "No lectures "
                    }), g.jsx("p", {
                        className: "text-sm md:text-base text-gray-600",
                        children: "Try adjusting your search terms"
                    })]
                })]
            }), l && g.jsx(Od, {
                src: l.link,
                title: l.title,
                onClose: () => c(null)
            })]
        })
    })
}
  , Md = ({searchTerm: s, onSearchChange: e, filterValue: t, onFilterChange: n, filterOptions: r, placeholder: i="Search..."}) => g.jsx("div", {
    className: "bg-white rounded-lg shadow-md p-6 mb-8",
    children: g.jsxs("div", {
        className: "flex flex-col md:flex-row gap-4",
        children: [g.jsxs("div", {
            className: "flex-1 relative",
            children: [g.jsx(zo, {
                className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5"
            }), g.jsx("input", {
                type: "text",
                placeholder: i,
                value: s,
                onChange: a => e(a.target.value),
                className: "search-input pl-10"
            })]
        }), g.jsxs("div", {
            className: "relative min-w-48",
            children: [g.jsx(Kp, {
                className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5"
            }), g.jsxs("select", {
                value: t,
                onChange: a => n(a.target.value),
                className: "search-input pl-10 appearance-none bg-white",
                children: [g.jsx("option", {
                    value: "",
                    children: "All Categories"
                }), r.map(a => g.jsx("option", {
                    value: a,
                    children: a
                }, a))]
            })]
        })]
    })
})
  , $A = () => {
    const [s,e] = w.useState([])
      , [t,n] = w.useState(!0)
      , [r,i] = w.useState(null)
      , [a,o] = w.useState("")
      , [l,c] = w.useState("");
    w.useEffect( () => {
        u()
    }
    , []);
    const u = async () => {
        try {
            n(!0);
            const p = Mn.getApiUrl("AARAMBH 2.O 10th BATCH 25-26", "science", "dpp");
            if (!p)
                throw new Error("API endpoint not configured");
            const x = await fetch(p);
            if (!x.ok)
                throw new Error("Failed to fetch DPPs");
            const y = await x.json();
            e(y.data || [])
        } catch (p) {
            i("Failed to load practice papers. Please try again later."),
            console.error("Error fetching DPPs:", p)
        } finally {
            n(!1)
        }
    }
      , d = s.filter(p => {
        const x = p.title.toLowerCase().includes(a.toLowerCase()) || p.description.toLowerCase().includes(a.toLowerCase())
          , y = l === "" || p.category === l;
        return x && y
    }
    )
      , h = [...new Set(s.map(p => p.category))]
      , f = (p, x) => {
        const y = document.createElement("a");
        y.href = p,
        y.download = `${x}.pdf`,
        y.target = "_blank",
        document.body.appendChild(y),
        y.click(),
        document.body.removeChild(y)
    }
      , m = p => {
        switch (p == null ? void 0 : p.toLowerCase()) {
        case "easy":
            return "text-green-600 bg-green-100";
        case "medium":
            return "text-yellow-600 bg-yellow-100";
        case "hard":
            return "text-red-600 bg-red-100";
        default:
            return "text-blue-600 bg-blue-100"
        }
    }
    ;
    return r ? g.jsx("div", {
        className: "min-h-screen bg-gray-50 py-12",
        children: g.jsx("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: g.jsx("div", {
                className: "text-center",
                children: g.jsxs("div", {
                    className: "bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg max-w-md mx-auto",
                    children: [g.jsx("p", {
                        className: "font-medium",
                        children: r
                    }), g.jsx("button", {
                        onClick: u,
                        className: "mt-2 text-sm underline hover:no-underline",
                        children: "Try Again"
                    })]
                })
            })
        })
    }) : g.jsx("div", {
        className: "min-h-screen dark-container py-6 md:py-12",
        children: g.jsxs("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: [g.jsxs("div", {
                className: "text-center mb-8 md:mb-12",
                children: [g.jsx("h1", {
                    className: "text-2xl md:text-4xl font-bold text-gradient mb-4",
                    children: "Daily Practice Papers"
                }), g.jsx("p", {
                    className: "text-sm md:text-lg text-gray-300 max-w-2xl mx-auto",
                    children: "Strengthen your concepts with carefully curated practice papers for Class 10 Science"
                })]
            }), g.jsx(Md, {
                searchTerm: a,
                onSearchChange: o,
                filterValue: l,
                onFilterChange: c,
                filterOptions: h,
                placeholder: "Search practice papers..."
            }), t ? g.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                children: [...Array(6)].map( (p, x) => g.jsx(kr, {}, x))
            }) : g.jsxs(g.Fragment, {
                children: [g.jsxs("div", {
                    className: "mb-4 md:mb-6 text-xs md:text-sm text-gray-300",
                    children: ["Showing ", d.length, " of ", s.length, " practice papers"]
                }), g.jsx("div", {
                    className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                    children: d.map(p => g.jsx("div", {
                        className: "card",
                        children: g.jsxs("div", {
                            className: "p-4 md:p-6",
                            children: [g.jsxs("div", {
                                className: "flex items-start justify-between mb-4",
                                children: [g.jsxs("div", {
                                    className: "flex-1",
                                    children: [g.jsxs("div", {
                                        className: "flex items-center gap-2 mb-2",
                                        children: [g.jsx("span", {
                                            className: "text-xs font-medium text-blue-600 bg-blue-100 px-2 py-1 rounded",
                                            children: p.category || "Science"
                                        }), p.difficulty && g.jsx("span", {
                                            className: `text-xs font-medium px-2 py-1 rounded ${m(p.difficulty)}`,
                                            children: p.difficulty
                                        })]
                                    }), g.jsx("h3", {
                                        className: "text-lg md:text-xl font-semibold text-gray-900 mb-3",
                                        children: p.title
                                    })]
                                }), g.jsx(ws, {
                                    className: "h-6 w-6 md:h-8 md:w-8 text-green-600 flex-shrink-0"
                                })]
                            }), g.jsx("p", {
                                className: "text-gray-600 text-xs md:text-sm mb-4 line-clamp-3",
                                children: p.description || "Practice paper with comprehensive questions covering all important topics"
                            }), p.date && g.jsxs("div", {
                                className: "flex items-center text-xs md:text-sm text-gray-500 mb-4 md:mb-6",
                                children: [g.jsx(xS, {
                                    className: "h-4 w-4 mr-2"
                                }), new Date(p.date).toLocaleDateString()]
                            }), g.jsxs("button", {
                                onClick: () => f(p.download_url, p.title),
                                className: "w-full btn-primary flex items-center justify-center gap-2 text-sm",
                                children: [g.jsx(Qe, {
                                    className: "h-4 w-4"
                                }), "Download PDF"]
                            })]
                        })
                    }, p.id))
                }), d.length === 0 && !t && g.jsxs("div", {
                    className: "text-center py-8 md:py-12",
                    children: [g.jsx("div", {
                        className: "text-gray-400 mb-4",
                        children: g.jsx(ws, {
                            className: "h-16 w-16 mx-auto"
                        })
                    }), g.jsx("h3", {
                        className: "text-base md:text-lg font-medium text-gray-900 mb-2",
                        children: "No practice papers found"
                    }), g.jsx("p", {
                        className: "text-sm md:text-base text-gray-600",
                        children: "Try adjusting your search terms or filters"
                    })]
                })]
            })]
        })
    })
}
  , jA = () => {
    const [s,e] = w.useState([])
      , [t,n] = w.useState(!0)
      , [r,i] = w.useState(null)
      , [a,o] = w.useState("")
      , [l,c] = w.useState("");
    w.useEffect( () => {
        u()
    }
    , []);
    const u = async () => {
        try {
            n(!0);
            const m = Mn.getApiUrl("AARAMBH 2.O 10th BATCH 25-26", "science", "notes");
            if (!m)
                throw new Error("API endpoint not configured");
            const p = await fetch(m);
            if (!p.ok)
                throw new Error("Failed to fetch notes");
            const x = await p.json();
            e(x.data || [])
        } catch (m) {
            i("Failed to load notes. Please try again later."),
            console.error("Error fetching notes:", m)
        } finally {
            n(!1)
        }
    }
      , d = s.filter(m => {
        var y;
        const p = m.title.toLowerCase().includes(a.toLowerCase()) || m.description.toLowerCase().includes(a.toLowerCase()) || ((y = m.chapter) == null ? void 0 : y.toLowerCase().includes(a.toLowerCase()))
          , x = l === "" || m.category === l;
        return p && x
    }
    )
      , h = [...new Set(s.map(m => m.category))]
      , f = (m, p) => {
        const x = document.createElement("a");
        x.href = m,
        x.download = `${p}.pdf`,
        x.target = "_blank",
        document.body.appendChild(x),
        x.click(),
        document.body.removeChild(x)
    }
    ;
    return r ? g.jsx("div", {
        className: "min-h-screen bg-gray-50 py-12",
        children: g.jsx("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: g.jsx("div", {
                className: "text-center",
                children: g.jsxs("div", {
                    className: "bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg max-w-md mx-auto",
                    children: [g.jsx("p", {
                        className: "font-medium",
                        children: r
                    }), g.jsx("button", {
                        onClick: u,
                        className: "mt-2 text-sm underline hover:no-underline",
                        children: "Try Again"
                    })]
                })
            })
        })
    }) : g.jsx("div", {
        className: "min-h-screen dark-container py-6 md:py-12",
        children: g.jsxs("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: [g.jsxs("div", {
                className: "text-center mb-8 md:mb-12",
                children: [g.jsx("h1", {
                    className: "text-2xl md:text-4xl font-bold text-gradient mb-4",
                    children: "Study Notes"
                }), g.jsx("p", {
                    className: "text-sm md:text-lg text-gray-300 max-w-2xl mx-auto",
                    children: "Comprehensive study notes covering all chapters of Class 10 Science"
                })]
            }), g.jsx(Md, {
                searchTerm: a,
                onSearchChange: o,
                filterValue: l,
                onFilterChange: c,
                filterOptions: h,
                placeholder: "Search notes..."
            }), t ? g.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                children: [...Array(6)].map( (m, p) => g.jsx(kr, {}, p))
            }) : g.jsxs(g.Fragment, {
                children: [g.jsxs("div", {
                    className: "mb-4 md:mb-6 text-xs md:text-sm text-gray-300",
                    children: ["Showing ", d.length, " of ", s.length, " notes"]
                }), g.jsx("div", {
                    className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                    children: d.map(m => g.jsx("div", {
                        className: "card",
                        children: g.jsxs("div", {
                            className: "p-4 md:p-6",
                            children: [g.jsxs("div", {
                                className: "flex items-start justify-between mb-4",
                                children: [g.jsxs("div", {
                                    className: "flex-1",
                                    children: [g.jsxs("div", {
                                        className: "flex items-center gap-2 mb-2",
                                        children: [g.jsx("span", {
                                            className: "text-xs font-medium text-orange-600 bg-orange-100 px-2 py-1 rounded",
                                            children: m.category || "Science"
                                        }), m.chapter && g.jsx("span", {
                                            className: "text-xs font-medium text-gray-600 bg-gray-100 px-2 py-1 rounded",
                                            children: m.chapter
                                        })]
                                    }), g.jsx("h3", {
                                        className: "text-lg md:text-xl font-semibold text-gray-900 mb-3",
                                        children: m.title
                                    })]
                                }), g.jsx(dr, {
                                    className: "h-6 w-6 md:h-8 md:w-8 text-orange-600 flex-shrink-0"
                                })]
                            }), g.jsx("p", {
                                className: "text-gray-600 text-xs md:text-sm mb-4 line-clamp-3",
                                children: m.description || "Comprehensive notes covering all important concepts and formulas"
                            }), g.jsxs("div", {
                                className: "flex items-center gap-4 text-xs md:text-sm text-gray-500 mb-4 md:mb-6",
                                children: [m.pages && g.jsxs("div", {
                                    className: "flex items-center",
                                    children: [g.jsx(CS, {
                                        className: "h-4 w-4 mr-1"
                                    }), m.pages, " pages"]
                                }), m.size && g.jsx("div", {
                                    children: m.size
                                })]
                            }), g.jsxs("button", {
                                onClick: () => f(m.download_url, m.title),
                                className: "w-full btn-primary flex items-center justify-center gap-2 text-sm",
                                children: [g.jsx(Qe, {
                                    className: "h-4 w-4"
                                }), "Download Notes"]
                            })]
                        })
                    }, m.id))
                }), d.length === 0 && !t && g.jsxs("div", {
                    className: "text-center py-8 md:py-12",
                    children: [g.jsx("div", {
                        className: "text-gray-400 mb-4",
                        children: g.jsx("img", {
                            src: "https://i.ibb.co/23bwFnVF/6179079224833460665-1.jpg",
                            alt: "EduSpark Logo",
                            className: "h-16 w-16 rounded-full object-cover mx-auto opacity-40"
                        })
                    }), g.jsx("h3", {
                        className: "text-base md:text-lg font-medium text-gray-900 mb-2",
                        children: "No notes found"
                    }), g.jsx("p", {
                        className: "text-sm md:text-base text-gray-600",
                        children: "Try adjusting your search terms or filters"
                    })]
                })]
            })]
        })
    })
}
  , GA = () => {
    const [s,e] = w.useState([])
      , [t,n] = w.useState(!0)
      , [r,i] = w.useState(null)
      , [a,o] = w.useState("")
      , [l,c] = w.useState(null)
      , u = async () => {
        try {
            n(!0);
            const p = Mn.getApiUrl("AARAMBH 2.O 10th BATCH 25-26", "hindi", "lectures");
            if (!p)
                throw new Error("API endpoint not configured");
            const x = await fetch(p);
            if (!x.ok)
                throw new Error("Failed to fetch lectures");
            const y = await x.json();
            e(y.data || [])
        } catch (p) {
            i("Failed to load lectures. Please try again later."),
            console.error("Error fetching lectures:", p)
        } finally {
            n(!1)
        }
    }
    ;
    w.useEffect( () => {
        u()
    }
    , []);
    const d = s.filter(p => p.title.toLowerCase().includes(a.toLowerCase()))
      , h = p => {
        c(p)
    }
      , f = p => p.includes("  ") ? "  " : p.includes("") ? "" : p.includes("") ? " ()" : p.includes("") ? " " : p.includes("") ? "   " : p.includes("") ? "   " : p.includes("  ") ? "   " : p.includes("") ? "  " : p.includes("") ? "  " : p.includes(" ") ? "   " : p.includes("  ") ? "  " : p.includes("") ? "   " : p.includes(" ") ? "   " : ""
      , m = p => {
        const x = {
            "  ": "text-pink-600 bg-pink-100",
            : "text-yellow-600 bg-yellow-100",
            " ()": "text-purple-600 bg-purple-100",
            " ": "text-green-600 bg-green-100",
            "   ": "text-indigo-600 bg-indigo-100",
            "   ": "text-red-600 bg-red-100",
            "   ": "text-blue-600 bg-blue-100",
            "  ": "text-orange-600 bg-orange-100",
            "  ": "text-teal-600 bg-teal-100",
            "   ": "text-emerald-600 bg-emerald-100",
            "  ": "text-violet-600 bg-violet-100",
            "   ": "text-rose-600 bg-rose-100",
            "   ": "text-cyan-600 bg-cyan-100",
            : "text-gray-600 bg-gray-100"
        };
        return x[p] || x.
    }
    ;
    return r ? g.jsx("div", {
        className: "min-h-screen bg-gray-50 py-12",
        children: g.jsx("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: g.jsx("div", {
                className: "text-center",
                children: g.jsx("div", {
                    className: "bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg max-w-md mx-auto",
                    children: g.jsx("p", {
                        className: "font-medium",
                        children: r
                    })
                })
            })
        })
    }) : g.jsx("div", {
        className: "min-h-screen dark-container py-6 md:py-12",
        children: g.jsxs("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: [g.jsxs("div", {
                className: "text-center mb-8 md:mb-12",
                children: [g.jsx("h1", {
                    className: "text-2xl md:text-4xl font-bold text-gradient mb-4",
                    children: " "
                }), g.jsx("p", {
                    className: "text-sm md:text-lg text-gray-300 max-w-2xl mx-auto",
                    children: " 9         "
                })]
            }), g.jsx("div", {
                className: "bg-white rounded-lg shadow-md p-4 md:p-6 mb-6 md:mb-8",
                children: g.jsxs("div", {
                    className: "relative",
                    children: [g.jsx(zo, {
                        className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-5 w-5"
                    }), g.jsx("input", {
                        type: "text",
                        placeholder: " ...",
                        value: a,
                        onChange: p => o(p.target.value),
                        className: "search-input pl-10 text-sm md:text-base"
                    })]
                })
            }), t ? g.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                children: [...Array(6)].map( (p, x) => g.jsx(kr, {}, x))
            }) : g.jsxs(g.Fragment, {
                children: [g.jsxs("div", {
                    className: "mb-4 md:mb-6 text-xs md:text-sm text-gray-300",
                    children: [d.length, "   ", s.length, "     "]
                }), g.jsx("div", {
                    className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                    children: d.map( (p, x) => {
                        const y = f(p.title)
                          , v = m(y);
                        return g.jsxs("div", {
                            className: "card overflow-hidden",
                            children: [g.jsxs("div", {
                                className: "relative",
                                children: [g.jsx("div", {
                                    className: "w-full h-40 md:h-48 bg-gradient-to-br from-orange-500 to-red-600 flex items-center justify-center",
                                    children: g.jsx(rt, {
                                        className: "h-12 w-12 md:h-16 md:w-16 text-white opacity-80"
                                    })
                                }), g.jsx("div", {
                                    className: "absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center opacity-0 hover:opacity-100 transition-opacity duration-300 cursor-pointer",
                                    onClick: () => h(p),
                                    children: g.jsxs("div", {
                                        className: "text-center text-white",
                                        children: [g.jsx(rt, {
                                            className: "h-12 w-12 md:h-16 md:w-16 mx-auto mb-2"
                                        }), g.jsx("p", {
                                            className: "text-xs md:text-sm font-medium",
                                            children: "    "
                                        })]
                                    })
                                })]
                            }), g.jsxs("div", {
                                className: "p-4 md:p-6",
                                children: [g.jsx("div", {
                                    className: "flex items-center justify-between mb-3",
                                    children: g.jsx("span", {
                                        className: `text-xs font-medium px-2 py-1 rounded ${v}`,
                                        children: y
                                    })
                                }), g.jsx("h3", {
                                    className: "text-lg md:text-xl font-semibold text-gray-900 mb-3 line-clamp-2",
                                    children: p.title
                                }), g.jsx("p", {
                                    className: "text-gray-600 text-xs md:text-sm mb-4 md:mb-6",
                                    children: "        "
                                }), g.jsxs("button", {
                                    onClick: () => h(p),
                                    className: "w-full btn-primary flex items-center justify-center gap-2 text-sm",
                                    children: [g.jsx(rt, {
                                        className: "h-4 w-4"
                                    }), " "]
                                })]
                            })]
                        }, x)
                    }
                    )
                }), d.length === 0 && !t && g.jsxs("div", {
                    className: "text-center py-8 md:py-12",
                    children: [g.jsx("div", {
                        className: "text-gray-400 mb-4",
                        children: g.jsx(rt, {
                            className: "h-16 w-16 mx-auto"
                        })
                    }), g.jsx("h3", {
                        className: "text-base md:text-lg font-medium text-gray-900 mb-2",
                        children: "   "
                    }), g.jsx("p", {
                        className: "text-sm md:text-base text-gray-600",
                        children: "      "
                    })]
                })]
            }), l && g.jsx(Od, {
                src: l.link,
                title: l.title,
                onClose: () => c(null)
            })]
        })
    })
}
  , VA = () => {
    const [s,e] = w.useState([])
      , [t,n] = w.useState(!0)
      , [r,i] = w.useState(null)
      , [a,o] = w.useState("")
      , [l,c] = w.useState("")
      , u = async () => {
        try {
            n(!0);
            const p = Mn.getApiUrl("AARAMBH 2.O 10th BATCH 25-26", "hindi", "notes");
            if (!p)
                throw new Error("API endpoint not configured");
            const x = await fetch(p);
            if (!x.ok)
                throw new Error("Failed to fetch notes");
            const y = await x.json();
            e(y.data || [])
        } catch (p) {
            i("Failed to load notes. Please try again later."),
            console.error("Error fetching notes:", p)
        } finally {
            n(!1)
        }
    }
    ;
    w.useEffect( () => {
        u()
    }
    , []);
    const d = s.filter(p => {
        const x = p.title.toLowerCase().includes(a.toLowerCase())
          , y = l === "" || h(p.title) === l;
        return x && y
    }
    )
      , h = p => p.includes("  ") ? "  " : p.includes("") ? "" : p.includes("") ? " ()" : p.includes("") ? " " : p.includes("") ? "   " : p.includes("") ? "   " : p.includes("  ") ? "   " : p.includes("") ? "  " : p.includes("") ? "  " : p.includes(" ") ? "   " : p.includes("  ") ? "  " : p.includes("") ? "   " : p.includes(" ") ? "   " : ""
      , f = [...new Set(s.map(p => h(p.title)))]
      , m = (p, x) => {
        const y = document.createElement("a");
        y.href = p,
        y.download = `${x}.pdf`,
        y.target = "_blank",
        document.body.appendChild(y),
        y.click(),
        document.body.removeChild(y)
    }
    ;
    return r ? g.jsx("div", {
        className: "min-h-screen bg-gray-50 py-12",
        children: g.jsx("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: g.jsx("div", {
                className: "text-center",
                children: g.jsxs("div", {
                    className: "bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg max-w-md mx-auto",
                    children: [g.jsx("p", {
                        className: "font-medium",
                        children: r
                    }), g.jsx("button", {
                        onClick: () => i(null),
                        className: "mt-2 text-sm underline hover:no-underline",
                        children: "  "
                    })]
                })
            })
        })
    }) : g.jsx("div", {
        className: "min-h-screen dark-container py-6 md:py-12",
        children: g.jsxs("div", {
            className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
            children: [g.jsxs("div", {
                className: "text-center mb-8 md:mb-12",
                children: [g.jsx("h1", {
                    className: "text-2xl md:text-4xl font-bold text-gradient mb-4",
                    children: "  "
                }), g.jsx("p", {
                    className: "text-sm md:text-lg text-gray-300 max-w-2xl mx-auto",
                    children: " 9        "
                })]
            }), g.jsx(Md, {
                searchTerm: a,
                onSearchChange: o,
                filterValue: l,
                onFilterChange: c,
                filterOptions: f,
                placeholder: " ..."
            }), t ? g.jsx("div", {
                className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                children: [...Array(6)].map( (p, x) => g.jsx(kr, {}, x))
            }) : g.jsxs(g.Fragment, {
                children: [g.jsxs("div", {
                    className: "mb-4 md:mb-6 text-xs md:text-sm text-gray-300",
                    children: [d.length, "   ", s.length, "     "]
                }), g.jsx("div", {
                    className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 lg:gap-8",
                    children: d.map( (p, x) => {
                        const y = h(p.title);
                        return g.jsx("div", {
                            className: "card",
                            children: g.jsxs("div", {
                                className: "p-4 md:p-6",
                                children: [g.jsxs("div", {
                                    className: "flex items-start justify-between mb-4",
                                    children: [g.jsxs("div", {
                                        className: "flex-1",
                                        children: [g.jsx("div", {
                                            className: "flex items-center gap-2 mb-2",
                                            children: g.jsx("span", {
                                                className: "text-xs font-medium text-orange-600 bg-orange-100 px-2 py-1 rounded",
                                                children: y
                                            })
                                        }), g.jsx("h3", {
                                            className: "text-lg md:text-xl font-semibold text-gray-900 mb-3",
                                            children: p.title
                                        })]
                                    }), g.jsx(dr, {
                                        className: "h-6 w-6 md:h-8 md:w-8 text-orange-600 flex-shrink-0"
                                    })]
                                }), g.jsx("p", {
                                    className: "text-gray-600 text-xs md:text-sm mb-4 md:mb-6",
                                    children: "         "
                                }), g.jsxs("button", {
                                    onClick: () => m(p.link, p.title),
                                    className: "w-full btn-primary flex items-center justify-center gap-2 text-sm",
                                    children: [g.jsx(Qe, {
                                        className: "h-4 w-4"
                                    }), " "]
                                })]
                            })
                        }, x)
                    }
                    )
                }), d.length === 0 && !t && g.jsxs("div", {
                    className: "text-center py-8 md:py-12",
                    children: [g.jsx("div", {
                        className: "text-gray-400 mb-4",
                        children: g.jsx("img", {
                            src: "https://i.ibb.co/23bwFnVF/6179079224833460665-1.jpg",
                            alt: "EduSpark Logo",
                            className: "h-16 w-16 rounded-full object-cover mx-auto opacity-40"
                        })
                    }), g.jsx("h3", {
                        className: "text-base md:text-lg font-medium text-gray-900 mb-2",
                        children: "   "
                    }), g.jsx("p", {
                        className: "text-sm md:text-base text-gray-600",
                        children: "      "
                    })]
                })]
            })]
        })
    })
}
  , HA = () => {
    const [s,e] = w.useState("");
    w.useState(!1);
    const [t,n] = w.useState(!1)
      , [r,i] = w.useState(!1)
      , [a,o] = w.useState(null)
      , [l,c] = w.useState("")
      , [u,d] = w.useState("info")
      , [h,f] = w.useState(0)
      , [m,p] = w.useState(0)
      , [x,y] = w.useState(0);
    w.useState(null),
    w.useState(!1),
    w.useRef(null);
    const v = w.useRef(null);
    w.useEffect( () => () => {
        v.current && (v.current.destroy(),
        v.current = null)
    }
    , []);
    const E = (A, C) => {
        c(A),
        d(C),
        (C !== "info" || !t) && setTimeout( () => c(""), 5e3)
    }
      , T = () => {
        a && (a.abort(),
        o(null)),
        i(!0),
        n(!1),
        f(0),
        p(0),
        y(0),
        E("Download cancelled by user", "info")
    }
      , L = async () => {
        const A = s.trim();
        if (!A) {
            E("Please enter a valid M3U8 URL first", "error");
            return
        }
        const C = new AbortController;
        o(C),
        i(!1),
        n(!0),
        f(0),
        p(0),
        E("Starting download... This may take a while.", "info");
        try {
            const b = await fetch(A, {
                signal: C.signal
            });
            if (!b.ok)
                throw new Error(`HTTP ${b.status}: ${b.statusText}`);
            const O = await b.text()
              , _ = A.substring(0, A.lastIndexOf("/") + 1)
              , $ = O.split(`
`).filter(D => D.trim() && !D.startsWith("#")).map(D => D.trim());
            if ($.length === 0)
                throw new Error("No video segments found in playlist");
            y($.length),
            E(`Found ${$.length} segments. Starting download...`, "info");
            const K = [];
            for (let D = 0; D < $.length; D++) {
                if (r || C.signal.aborted)
                    throw new Error("Download cancelled");
                const B = $[D].startsWith("http") ? $[D] : _ + $[D];
                try {
                    const k = await fetch(B, {
                        signal: C.signal
                    });
                    if (!k.ok)
                        throw new Error(`Failed to download segment ${D + 1}`);
                    const F = await k.arrayBuffer();
                    K.push(F);
                    const j = Math.round((D + 1) / $.length * 100)
                      , J = D + 1;
                    f(j),
                    p(J),
                    c(`Downloading... ${j}% (${J}/${$.length})`),
                    d("info")
                } catch (k) {
                    if (C.signal.aborted)
                        throw new Error("Download cancelled");
                    console.warn(`Failed to download segment ${D + 1}:`, k)
                }
            }
            if (K.length === 0)
                throw new Error("Failed to download any video segments");
            const W = new Blob(K,{
                type: "video/mp2t"
            })
              , G = URL.createObjectURL(W)
              , V = document.createElement("a");
            V.href = G,
            V.download = "eduspark_video.ts",
            V.style.display = "none",
            document.body.appendChild(V),
            V.click(),
            document.body.removeChild(V),
            setTimeout( () => URL.revokeObjectURL(G), 1e3),
            E(`Download completed! ${K.length} segments downloaded.`, "success")
        } catch (b) {
            b instanceof Error && b.name === "AbortError" || r ? E("Download cancelled by user", "info") : (console.error("Download error:", b),
            E(`Download failed: ${binstanceof Error ? b.message : "Unknown error"}. user canceled.`, "error"))
        } finally {
            n(!1),
            f(0),
            p(0),
            y(0),
            o(null),
            i(!1)
        }
    }
      , R = () => {
        switch (u) {
        case "success":
            return g.jsx(yo, {
                className: "h-5 w-5 text-green-400"
            });
        case "error":
            return g.jsx(ur, {
                className: "h-5 w-5 text-red-400"
            });
        default:
            return g.jsx(ur, {
                className: "h-5 w-5 text-blue-400"
            })
        }
    }
      , I = () => {
        switch (u) {
        case "success":
            return "border-green-500/50 bg-green-900/20 text-green-300";
        case "error":
            return "border-red-500/50 bg-red-900/20 text-red-300";
        default:
            return "border-blue-500/50 bg-blue-900/20 text-blue-300"
        }
    }
    ;
    return g.jsx("div", {
        className: "min-h-screen dark-container py-6 md:py-12",
        children: g.jsxs("div", {
            className: "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8",
            children: [g.jsxs("div", {
                className: "text-center mb-8 md:mb-12",
                children: [g.jsx("div", {
                    className: "flex justify-center mb-6",
                    children: g.jsx("div", {
                        className: "p-0 bg-red-600 rounded-full glow-red pulse-red",
                        children: g.jsx("img", {
                            src: "https://i.ibb.co/23bwFnVF/6179079224833460665-1.jpg",
                            alt: "EduSpark Logo",
                            className: "h-16 w-16 md:h-20 md:w-20 rounded-full object-cover hover:rotate-12 transition-transform duration-500"
                        })
                    })
                }), g.jsx("h1", {
                    className: "text-3xl md:text-4xl lg:text-5xl font-bold text-gradient mb-4 neon-text",
                    children: "EduSpark M3U8 Downloader"
                }), g.jsx("p", {
                    className: "text-base md:text-lg text-gray-300 max-w-2xl mx-auto",
                    children: "Play & download M3U8 videos with EduSpark"
                })]
            }), g.jsxs("div", {
                className: "card-futuristic p-6 md:p-8 relative overflow-hidden",
                children: [g.jsx("div", {
                    className: "absolute inset-0 opacity-10",
                    children: g.jsx("div", {
                        className: "absolute top-0 left-0 w-full h-full bg-gradient-to-br from-red-500/20 via-transparent to-blue-500/20 animate-pulse"
                    })
                }), g.jsxs("div", {
                    className: "relative z-10",
                    children: [g.jsxs("div", {
                        className: "mb-6 md:mb-8",
                        children: [g.jsx("label", {
                            htmlFor: "m3u8url",
                            className: "block text-sm font-medium text-gray-300 mb-3",
                            children: "M3U8 Stream URL"
                        }), g.jsx("input", {
                            id: "m3u8url",
                            type: "text",
                            value: s,
                            onChange: A => e(A.target.value),
                            placeholder: "Enter M3U8 URL (e.g., https://example.com/playlist.m3u8)",
                            className: "w-full px-4 md:px-6 py-3 md:py-4 bg-gray-900 border border-red-500/30 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:border-red-500 focus:ring-2 focus:ring-red-500/20 transition-all duration-300 text-sm md:text-base",
                            style: {
                                boxShadow: "0 0 10px rgba(220, 38, 38, 0.2) inset"
                            },
                            onFocus: A => {
                                A.target.style.boxShadow = "0 0 20px rgba(220, 38, 38, 0.4) inset"
                            }
                            ,
                            onBlur: A => {
                                A.target.style.boxShadow = "0 0 10px rgba(220, 38, 38, 0.2) inset"
                            }
                        })]
                    }), g.jsx("div", {
                        className: "flex flex-col sm:flex-row gap-4 mb-6 md:mb-8",
                        children: t ? g.jsxs("button", {
                            onClick: T,
                            className: "flex-1 flex items-center justify-center gap-2 bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 text-white font-bold py-3 md:py-4 px-6 md:px-8 rounded-lg transition-all duration-300 transform hover:scale-105 text-sm md:text-base",
                            style: {
                                boxShadow: "0 0 20px rgba(220, 38, 38, 0.3)",
                                textShadow: "0 0 5px rgba(255, 255, 255, 0.8)"
                            },
                            children: [g.jsx(ur, {
                                className: "h-5 w-5"
                            }), "Cancel Download"]
                        }) : g.jsxs("button", {
                            onClick: L,
                            disabled: !s.trim(),
                            className: "flex-1 flex items-center justify-center gap-2 bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white font-bold py-3 md:py-4 px-6 md:px-8 rounded-lg transition-all duration-300 transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none text-sm md:text-base",
                            style: {
                                boxShadow: "0 0 20px rgba(34, 197, 94, 0.3)",
                                textShadow: "0 0 5px rgba(255, 255, 255, 0.8)"
                            },
                            children: [g.jsx(Qe, {
                                className: "h-5 w-5"
                            }), "Download Lecture"]
                        })
                    }), l && g.jsxs("div", {
                        className: `flex items-center gap-3 p-4 rounded-lg border mb-6 md:mb-8 ${I()}`,
                        children: [R(), g.jsxs("div", {
                            className: "flex-1",
                            children: [g.jsx("p", {
                                className: "text-sm md:text-base",
                                children: l
                            }), t && h > 0 && g.jsxs("div", {
                                className: "mt-2",
                                children: [g.jsx("div", {
                                    className: "w-full bg-gray-700 rounded-full h-2",
                                    children: g.jsx("div", {
                                        className: "bg-blue-500 h-2 rounded-full transition-all duration-300 ease-out",
                                        style: {
                                            width: `${h}%`
                                        }
                                    })
                                }), g.jsxs("div", {
                                    className: "flex justify-between text-xs text-gray-400 mt-1",
                                    children: [g.jsxs("span", {
                                        children: [h, "%"]
                                    }), g.jsx("span", {
                                        children: x > 0 ? `${m}/${x} segments` : ""
                                    })]
                                })]
                            })]
                        })]
                    }), g.jsxs("div", {
                        className: "bg-gradient-to-r from-gray-900/50 to-black/50 rounded-lg p-4 md:p-6 border border-red-900/30",
                        children: [g.jsx("h3", {
                            className: "text-lg font-semibold text-red-400 mb-3",
                            children: "How to use:"
                        }), g.jsxs("ul", {
                            className: "space-y-2 text-sm md:text-base text-gray-300",
                            children: [g.jsxs("li", {
                                className: "flex items-start gap-2",
                                children: [g.jsx("span", {
                                    className: "text-red-400 mt-1",
                                    children: "1."
                                }), g.jsx("span", {
                                    children: "Paste your M3U8 stream URL in the input field above"
                                })]
                            }), g.jsxs("li", {
                                className: "flex items-start gap-2",
                                children: [g.jsx("span", {
                                    className: "text-red-400 mt-1",
                                    children: "2."
                                }), g.jsx("span", {
                                    children: 'Click "Play Stream" to preview the video'
                                })]
                            }), g.jsxs("li", {
                                className: "flex items-start gap-2",
                                children: [g.jsx("span", {
                                    className: "text-red-400 mt-1",
                                    children: "3."
                                }), g.jsx("span", {
                                    children: 'Click "Download Lecture" to save the video to your device'
                                })]
                            }), g.jsxs("li", {
                                className: "flex items-start gap-2",
                                children: [g.jsx("span", {
                                    className: "text-red-400 mt-1",
                                    children: ""
                                }), g.jsx("span", {
                                    className: "text-yellow-300",
                                    children: "dont mix any multiple links"
                                })]
                            })]
                        })]
                    })]
                })]
            }), g.jsx("div", {
                className: "text-center mt-8 md:mt-12",
                children: g.jsx("p", {
                    className: "text-sm md:text-base text-red-400 font-medium",
                    children: " 2025 EduSpark - Advanced M3U8 Video Downloader"
                })
            })]
        })
    })
}
;
function KA() {
    return g.jsx(rS, {
        children: g.jsxs("div", {
            className: "min-h-screen bg-gray-50",
            children: [g.jsx(PS, {}), g.jsxs(OE, {
                children: [g.jsx(Wt, {
                    path: "/",
                    element: g.jsx(NS, {})
                }), g.jsx(Wt, {
                    path: "/batches",
                    element: g.jsx(OS, {})
                }), g.jsx(Wt, {
                    path: "/batch/:batchId/subjects",
                    element: g.jsx(MS, {})
                }), g.jsx(Wt, {
                    path: "/batch/:batchId/subject/:subjectId",
                    element: g.jsx(UA, {})
                }), g.jsx(Wt, {
                    path: "/lectures",
                    element: g.jsx(BA, {})
                }), g.jsx(Wt, {
                    path: "/dpps",
                    element: g.jsx($A, {})
                }), g.jsx(Wt, {
                    path: "/notes",
                    element: g.jsx(jA, {})
                }), g.jsx(Wt, {
                    path: "/hindi-lectures",
                    element: g.jsx(GA, {})
                }), g.jsx(Wt, {
                    path: "/hindi-notes",
                    element: g.jsx(VA, {})
                }), g.jsx(Wt, {
                    path: "/downloader",
                    element: g.jsx(HA, {})
                })]
            })]
        })
    })
}
bp(document.getElementById("root")).render(g.jsx(w.StrictMode, {
    children: g.jsx(KA, {})
}));
